// B0
// 
// Copyright (C) 2000-2006, Darran Kartaschew.
// All rights reserved.
// 
// Licence
// -------
// 
// Copyright (C) 2000-2006, Darran Kartaschew.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without modification, are permitted
// provided that the following conditions are met:
// 
// *  Redistributions of source code must retain the above copyright notice, this list of conditions
//    and the following disclaimer. 
// 
// *  Redistributions in binary form must reproduce the above copyright notice, this list of 
//    conditions and the following disclaimer in the documentation and/or other materials provided
//    with the distribution. 
// 
// *  Neither the name of 'B0' nor the names of its contributors may be used to endorse or promote 
//    products derived from this software without specific prior written permission. 
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND ANY EXPRESS OR 
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND 
// FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER 
// IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
// OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// 

// Uncomment to build i386 version of the compiler, else default to AMD64 version.
// #define i386

// Note: the resulting compiler is still requires a 64bit system, however the compiler will
// output 32bit code instead of 64bit code. Basically you're building a cross-compiler.

// Uncomment to build the appropriate version, else defaults to LINUX
// #define LINUX;
// #define WIN64;
 #define UNIX_LIBC;

#COMPILER_OPTION UTF8;

lib 'std_char.b0';
lib 'b0.h.b0';

#ifdef WIN64;
	lib 'b0_win64.b0';
#endif;

#ifdef UNIX_LIBC;
	lib 'b0_libc.b0';
#endif;

#ifdef LINUX;
	lib 'b0_linux.b0';
#endif;

#ifndef WIN64;
#ifndef UNIX_LIBC;
#ifndef LINUX;
	#define LINUX;
	lib 'b0_linux.b0';
#endif;
#endif;
#endif;

#ifndef FILENAME_MAX;
	#define FILENAME_MAX = 256;
#endif;

#ifdef WIN64;
	#define PATH_SEPARATOR = CHAR_SCOLON;  // ;
#else;
	#define PATH_SEPARATOR = CHAR_COLON;   // :
#endif;

struc struct_entry {
	m64 hash;
	m64 type;
	m64 size;
	m64 offset;
};

struc hash_table_struc{
	m64 hash;
	m8[TOKEN_MAX_SIZE] token;
	m64 token_type;
	m64 local_offset;		// If a proc, then this holds the current amount of space used for local variables
	m64 define_int;			// If this is a define, it holds the value of the define integer value.
	f64 define_fp;			// If this is a define, it holds the value of the define float value.
	m64 struc_ptr;			// Pointer to structure if a structure.
	m8[TOKEN_MAX_SIZE] token_import_name; // Real name of proc as defined by Windows.
	m64 token_import_lib; 	// hash of the library in which this EPROC belongs to.
};

struc if_while_struc{
	m64 type;
	m64 offset;
	m64 if_while_test1;
	m64 if_while_test2;
	m64 comparison;
};

struc file_struct{
	m64 handle;
	m8[FILENAME_MAX] filename;
	m64 line_count;
	m64 ch;
	m64 look_ahead_ch;
};

struc path_struc{
	m8[FILENAME_MAX] path;
}

m64 argc;						// We define these here rather than as a local variable
m64 argv;						// to allow us to access them without setting up a 
								// local variable frame;

m64 ch;							//current character in queue
m64 look_ahead_ch;				//look ahead character
file_struct[MAX_LIB_DEPTH] file;
								//Lib / Include stack
m64 file_stack_ptr;				//Pointer into the file stack
m64 code;						//pointer to code output file
m64 data;						//pointer to data output file
m64 bss;							//pointer to bss output file

m64 state;						//current instruction state
m64 line_count;					//current line in source
m64[TOKEN_STACK_SIZE] token_stack;		
								//Stack containing the current tokens to be processed.
m64[TOKEN_STACK_SIZE] pp_token_stack;
								//Preparser token stack!
m64 token;						//Pointer to current token within token stack;
m64 global;						//Are we at a global level?
								// If zero, we are global otherwise = hash of proc
								// we are in.
m64 struc_def;					// Hash of current struc being defined!
m64 do_process;					// Flag for structure processing.
m64 target;						// Target Register of line (contains hash).
m64 block_level = 0;				//Indentation level
hash_table_struc[HASH_TABLE_SIZE] hash_table;			
								//hash table
m64 token_hash;					//Hash of current token
m8[TOKEN_MAX_SIZE] token_buffer;	
								//Buffer for tokens
m64 toki; 						// index into above buffer.
m8[FILENAME_MAX] filename;
								//Filename for when opening a file.
m8[FILENAME_MAX] tmp_filename;
								//Temp filename used when searching includes.
m64 ptr_path;					//Pointer to our path statment
m64 ptr_b0_env;					//Pointer to our B0_INCLUE environment variable
m64 total_paths;
path_struc[PATHS_MAX] paths; 				// allow upto 256 paths to be searched.
								
m64 asm_in_string;				//Flag used to see in if string within
								// asm block.

if_while_struc[TOKEN_STACK_SIZE] if_while_stack;
								//Stack which holds the current block type
								//Index by block_level
m64 block_num;					//number of occurance of block.
m64 local_var_offset;
m64 dynamic_string_count;			//Count of the dynamic string decl.

//Timing variables
m64 time_start;
m64 time_end;
m64 duration;

m64 DEBUG = 0;					// Whether to output debugging output.
m64 ContinueOnAbort = 0;			// Flag to set if to continue on abort operation?
#ifdef WIN64;
m64 SOURCE_TYPE = SOURCE_PE;		// Default Source is flat output if building for Windows
#else;
m64 SOURCE_TYPE = SOURCE_ELF;		// Default Source is flat output if building for other.
#endif;
m64 UTF8_STRINGS = 0;  			// Encode strings as UTF8 instead of UTF16
m64 CLI_UTF8_STRINGS = 0;			// UTF8 strings was defined by the CLI
m64 SOURCE_CLI = 0;				// Output format defined by the CLI
m64 HeaderPrinted = 0;			// Header info block has been printed, eg -v CLI switch
m64 STACK_FRAME = 1;			// Generation of stack frame when calling functions.
m64 WarningsDisabled = 0;		// Set to disable generation of warnings

m64[MAX_LIB_DEPTH] pp_GenCode;	// Preparser toggle for code generation.
m64 pp_ptr = 0;					// Pointer into above array.

m64 v_base = 0;       			// Base variable;   (hash)
m64 v_isStruc = 0;     			// The base variable is a Struc (1, or 0)
m64 v_offset = 0;     			// Offset to sub-object; (value)
m64 v_offset_type = 0; 			// Type of offset == state.
m64 v_size = 0;					// Size of structure.
m64 v_index = 0;       			// index into array of struc. (pos on token stack of start of array value;)
m64 v_target = 0;      			// pos of what we are inserting into the variable (pos on token stack).
m64 v_global = 0;      			// Variable is global? (if not then local)
m64 v_reg = 0;					// Variable to hold calculated address of structure.

#ifndef i386;
m8 B0_VERSION = '0.0.19';
#else;
m8 B0_VERSION = '0.0.19 - IA32';
#endif;

m8 B0_COPYRIGHT = 'This is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n';

m8 TOKEN_KEYWORD = 'if\0else\0while\0lib\0asm\0return\0exit\0proc\0push\0pop\0syscall\0sysret\0fdecstp\0fincstp\0extern\0define\0undefine\0ifdef\0endif\0ifndef\0m8\0m16\0m32\0m64\0f32\0f64\0f80\0struc\0call\0jmp\0ret\0in\0out\0as\0COMPILER_OPTION\0\0';
#ifndef i386;
m8 TOKEN_REG = '0\0r0\0r1\0r2\0r3\0r4\0r5\0r6\0r7\0r8\0r9\0r10\0r11\0r12\0r13\0r14\0r15\0\0';
m8 TOKEN_REG_SHORT = 'r0b\0r1b\0r2b\0r3b\0r4b\0r5b\0r6b\0r7b\0r8b\0r9b\0r10b\0r11b\0r12b\0r13b\0r14b\0r15b\0r0w\0r1w\0r2w\0r3w\0r4w\0r5w\0r6w\0r7w\0\0';
m8 TOKEN_REG_SHORT2 = 'r8w\0r9w\0r10w\0r11w\0r12w\0r13w\0r14w\0r15w\0r0d\0r1d\0r2d\0r3d\0r4d\0r5d\0r6d\0r7d\0r8d\0r9d\0r10d\0r11d\0r12d\0r13d\0r14d\0r15d\0\0';
#else;
m8 TOKEN_REG = '0\0r0\0r1\0r2\0r3\0r4\0r5\0r6\0r7\0\0';
m8 TOKEN_REG_SHORT = 'r0b\0r1b\0r2b\0r3b\0r0w\0r1w\0r2w\0r3w\0r4w\0r5w\0r6w\0r7w\0\0';
m8 TOKEN_REG_SHORT2 = '\0\0';
#endif;
m8 TOKEN_REG_FPU = 'fp0\0fp1\0fp2\0fp3\0fp4\0fp5\0fp6\0fp7\0\0';
m8 TOKEN_FLAG = 'CARRY\0NOCARRY\0OVERFLOW\0NOOVERFLOW\0PARITY\0NOPARITY\0ZERO\0NOTZERO\0SIGN\0NOTSIGN\0\0';
m8 TOKEN_RESERVED = 'UTF8\0UTF16\0ELF\0ELFO\0PE\0ENABLESTACKFRAME\0DISABLESTACKFRAME\0\0';

// We include this here so it can directly access all defined variables and definitions.
lib 'b0_stdlib.b0';
lib 'core.b0';

proc getChar(){
	push r0,r1,r2,r3;
	r0 = look_ahead_ch;
	ch = r0;
	r1 = CHAR_LF;            /// UNIX '\n' is really LINE FEED and NOT Carriage RETURN
	r2 = file_stack_ptr;
	
	if (r0 == r1){
		r1 = file[r2].line_count;
		r1 = r1 + 1;
		file[r2].line_count = r1;
		r3 = DEBUG;
		if (r3){ //DEBUG
			push r0;
			echo_string(STDOUT, 'NEW LINE - ');
			echo_integer(STDOUT, r1);
			echo_string(STDOUT, '\n');
			pop r0;
		}
	}
	
	r1 = file[r2].handle;
	r1 = _fgetc(r1);
	r3 = 0ffffffffh;		// Convert EOF to -1;
	if(r1 == r3){
		r1 = EOF;
	}
	look_ahead_ch = r1;	// Get our next character
	
	r3 = DEBUG;
	r2 = r0;
	if (r3){
		echo_string(STDOUT, 'ch = ');
		echo_character(STDOUT, r2);
		echo_string(STDOUT, ', ');
		echo_hex(STDOUT, r2);
		echo_string(STDOUT, ' lch = ');
		echo_character(STDOUT, r1);
		echo_string(STDOUT, ', ');
		echo_hex(STDOUT, r1);
		echo_string(STDOUT, '\n');
	}
	pop r3, r2, r1, r0;
}

proc abort_b0(s){
	push r0, r1;
	r0 = HeaderPrinted;
	if (r0) {
		PrintHeader();
	}
	echo_string(STDOUT, 'Error: ');
	r0 = s;
	echo_string(STDOUT, r0);
	echo_string(STDOUT, '\n');
	r0 = DEBUG;
	if (r0){
		echo_string(STDOUT, 'Char: ');
		r0 = ch;
		echo_character(STDOUT, r0);
		echo_string(STDOUT, ' Token: ');
		r0 = token;
		echo_integer(STDOUT, r0);
		echo_string(STDOUT, '\n');
	}
	echo_string(STDOUT, 'Filename: ');
	r1 = file_stack_ptr;
	r0 = &file[r1].filename;
	echo_string(STDOUT, r0);
	echo_string(STDOUT, ' Line: ');
	r0 = file[r1].line_count;
	echo_integer(STDOUT, r0);
	echo_string(STDOUT, '.\n');
	r0 = ContinueOnAbort;
	r1 = 0;
	if (r0 == r1){
		r0 = _clock();
		r1 = time_start;
		r0 = r0 - r1;	// r0 has our time in ticks
		r1 = r0;
		echo_string(STDOUT, 'Processing Time: ');
		echo_hex(STDOUT, r1);
		echo_string(STDOUT, ' clocks\n');
		r0 = code;		// close our 3 tmp files.
		_fclose(r0);
		r0 = data;
		_fclose(r0);
		r0 = bss;
		_fclose(r0);
		r0 = DEBUG;
		r1 = 0;
		if(r0 == r1){	// If not debugging, then remove the current temp files.
			_remove('c_output.tmp');
			_remove('d_output.tmp');
			_remove('b_output.tmp');
		}
		exit(-1);
	}
	pop r1, r0;
}

proc insert_token(name, token_type){
	push r1, r2, r3;
	r1 = name;
	r0 = ElfHash(r1);
	r3 = 0;
	r2 = HASH_TABLE_SIZE;
	r0 = r0 % r2;  // Get the modulus
	r0 = r0 + 1; // Add one to it. (can't have a has vlaue of 0).
	
	r2 = r2 - 1;
	if (r0 >= r2){	// If our hash is bigger than the table size, then set the hahs to 1.
		r0 = 1;
	}
	hash_table[r0].hash = r0;		// Set the hash tabel entry to used by inserting our hash.
	r2 = &hash_table[r0].token;	// get the address of the token offset in the hash table
	push r0, r1;
	r1 = r1 - 2;
	strcpy(r2, r1);				// Copy our name into the hash_table.
	pop r1, r0;
	r1 = token_type;
	hash_table[r0].token_type = r1;
	r2 = r0;
	r0 = DEBUG;
	if (r0) {
		echo_string(STDOUT, '#define HASH_');
		r0 = name;
		r0 = r0 - 2;
		echo_string(STDOUT, r0);
		echo_string(STDOUT, ' = ');
		r0 = hash_table[r2].hash;
		echo_hex(STDOUT, r0);
		echo_string(STDOUT, ';\n');
		// Neat little hack to help rebuild the b0.h.b0 file if modding the hash table size, eg HASH_TABLE_SIZE in b0.h.b0.
	};
	pop r3, r2, r1;
}

proc insert_token_stack(_token){
	push r1, r2;
	r0 = token;
	r1 = _token;
	r2 = &token_stack;  	// Need this form if building for libc, else a simple 'token_stack[r0] = r1;' could be used.
	[r2+r0*8] = r1;		// see above...
	r0 = r0 + 1;
	token = r0;
	r1 = TOKEN_STACK_SIZE;
	if (r0 >= r1) {
		abort_b0('INTERNAL: Token Stack Overflow! - Increase TOKEN_STACK_SIZE');
	}
	r0 = DEBUG;
	if(r0){
		echo_string(STDOUT, 'Insert token = ');
		r1 = _token;
		echo_hex(STDOUT, r1);
		echo_string(STDOUT, '\n');
	}
	pop r2, r1;
}

proc atStackStart(){
	r0 = token;
	if (r0){
		abort_b0('Invalid construct');
	}
	r0 = r0 + 1;
	token = r0;
	return(1);
}

proc atStackEnd(i){
	push r1;
	r0 = token;
	r1 = i;
	if (r0 != r1){
		abort_b0('Unexpected expression/token');
	}
	pop r1;
	return(1);
}

proc TokenIsLabelType(i){
	push r1, r2;
	r0 = token;
	r2 = &token_stack;
	r0 = [r2+r0*8];
	r1 = HASH_OFFSET;
	if (r0 < r1){
		abort_b0('Expected Token/Label');
	}
	r0 = r0 - r1;
	r1 = hash_table[r0].token_type;	// Get our token_type for the current value being processed
	r2 = i;							// What it should be
	r1 = r1 && r2;
	if (r1 != r2){
		// r2 = the type it should be.
		r1 = TYPE_REG;
		#ifndef i386;
		if (r1 == r2) { abort_b0('64bit Register Expected'); }
		#else;
		if (r1 == r2) { abort_b0('32bit Register Expected'); }
		#endif;
		r1 = TYPE_REG_SHORT;
		#ifndef i386;
		if (r1 == r2) { abort_b0('non-64bit Register Expected'); }
		#else;
		if (r1 == r2) { abort_b0('non-32bit Register Expected'); }
		#endif;
		r1 = TYPE_REG_FPU;
		if (r1 == r2) { abort_b0('FPU Register Expected'); }
		r1 = TYPE_KEYWORD;
		if (r1 == r2) { abort_b0('Keyword Expected'); }
		r1 = TYPE_PROC;
		if (r1 == r2) { abort_b0('Procedure Expected'); }
		r1 = TYPE_EPROC;
		if (r1 == r2) { abort_b0('External Procedure Expected'); }
		r1 = TYPE_ELIB;
		if (r1 == r2) { abort_b0('Expected External DLL Name'); }
		r1 = TYPE_M8;
		if (r1 == r2) { abort_b0('Variable Expected'); }
		r1 = TYPE_M16;
		if (r1 == r2) { abort_b0('Variable Expected'); }
		r1 = TYPE_M32;
		if (r1 == r2) { abort_b0('Variable Expected'); }
		#ifndef i386;
		r1 = TYPE_M64;
		if (r1 == r2) { abort_b0('Variable Expected'); }
		#endif;
		r1 = TYPE_F32;
		if (r1 == r2) { abort_b0('Variable Expected'); }
		r1 = TYPE_F64;
		if (r1 == r2) { abort_b0('Variable Expected'); }
		r1 = TYPE_F80;
		if (r1 == r2) { abort_b0('Variable Expected'); }
		r1 = TYPE_ARRAY;
		if (r1 == r2) { abort_b0('Variable Expected'); }
		r1 = TYPE_LOCAL;
		if (r1 == r2) { abort_b0('Variable Expected'); }
		r1 = TYPE_GLOBAL;
		if (r1 == r2) { abort_b0('Variable Expected'); }
		r1 = TYPE_FLAG;
		if (r1 == r2) { abort_b0('CPU Flag Expected'); }
		r1 = 0;
		if (r1 == r2) { abort_b0('Unable to redefine Label/Token'); }
		abort_b0('Unknown Construct');
	}
	pop r2, r1;
}

proc IsLabelAllocated(){
	push r1, r2;
	r0 = token;
	r2 = &token_stack;
	r1 = [r2+r0*8];
	r2 = HASH_OFFSET;
	if (r1 < r2){
		abort_b0('Expected Token/Label');
	}
	r1 = r1 - r2;
	r0 = hash_table[r1].token_type;
	//r0 = [r2];
	if (r0){
		abort_b0('Unable to redefine Label/Token');
	}
	pop r2, r1;
	return(1);
}

proc isHash(i){
	push r1;
	r0 = i;
	r1 = HASH_OFFSET;
	if (r0 < r1){
		abort_b0('Expected Token/Label');
	}
	pop r1;
	return(1);
}

proc outputString(i){
	push r1, r2, r3, r4, r9, r10, r11, r12;
	r9 = TOKEN_END_STRING;
	r0 = token;
	r1 = i;
	r10 = 0ffffh;
	r2 = 0; // Flag to exit the while statement;
	r4 = data;
	r3 = &token_stack;
	r3 = [r3+r0*8];
	if (r3 != r9){
		if (r0 != r1){
			r2 = 1;
		}
	}
	while (r2){
		push r0;
		if (r3 < r10){
			echo_hex(r4, r3);
			echo_string(r4, ',');
		} else {
			r11 = r3 >> 10;
			r11 = r11 && 03fh;
			r12 = r3 >> 16;
			r12 = r12 - 1;
			r12 = r12 << 6;
			r11 = r11 + r12;
			r11 = r11 + 0d800h;
			echo_hex(r4, r11);
			echo_string(r4, ',');
			r11 = r3 && 03ffh;
			r11 = r11 + 0fc00h;
			echo_hex(r4, r11);
			echo_string(',');
		}
		pop r0;
		r0 = r0 + 1;
		token = r0;
		r2 = 0;
		r3 = &token_stack;
		r3 = [r3+r0*8];
		if (r3 != r9){
			if (r0 != r1){
				r2 = 1;
			}
		}
	}
	echo_string(r4, '0\n');
	pop r12, r11, r10, r9, r4, r3, r2, r1;
	return(1);
}

proc outputStringUTF8(i){
	push r1, r2, r3, r4, r9, r10, r11, r12;
	r9 = TOKEN_END_STRING;
	r0 = token;
	r1 = i;
	r10 = 080h;
	r2 = 0; // Flag to exit the while statement;
	r4 = data;
	r3 = &token_stack;
	r3 = [r3+r0*8];
	if (r3 != r9){
		if (r0 != r1){
			r2 = 1;
		}
	}
	while (r2){
		push r0;
		if (r3 < r10){  // Single byte encoding
			echo_hex(r4, r3);
			echo_string(r4, ',');
		} else {
			r10 = 0800h;
			if (r3 < r10){
				// Double byte encoding
				// fprintf(data, "0%xh,", ((token_stack[token] >> 6) + 0xc0));
				r11 = r3 >> 6;
				r11 = r11 + 0ch;
				echo_hex(r4, r11);
				echo_string(r4, ',');
				// fprintf(data, "0%xh,", ((token_stack[token] & 0x3f) + 0x80));
				r11 = r3 && 03fh;
				r11 = r11 + 80h;
				echo_hex(r4, r11);
				echo_string(r4, ',');
			} else {
				r10 = 010000h;
				if (r3 < r10){
					// 3 byte encoding
					// fprintf(data, "0%xh,", ((token_stack[token] >> 12) + 0xe0));
					r11 = r3 >> 12;
					r11 = r11 + 0e0h;
					echo_hex(r4, r11);
					echo_string(r4, ',');
					// fprintf(data, "0%xh,", (((token_stack[token] >> 6) & 0x3f) + 0x80));
					r11 = r3 >> 6;
					r11 = r11 && 03fh;
					r11 = r11 + 80h;
					echo_hex(r4, r11);
					echo_string(r4, ',');
					// fprintf(data, "0%xh,", ((token_stack[token] & 0x3f) + 0x80));
					r11 = r3 && 03fh;
					r11 = r11 + 80h;
					echo_hex(r4, r11);
					echo_string(r4, ',');
				} else {
					// 4 byte encoding
					// fprintf(data, "0%xh,", ((token_stack[token] >> 18) + 0xf0));
					r11 = r3 >> 18;
					r11 = r11 + 0f0h;
					echo_hex(r4, r11);
					echo_string(r4, ',');
					// fprintf(data, "0%xh,", ((token_stack[token] >> 12) + 0xe0));
					r11 = r3 >> 12;
					r11 = r11 + 0e0h;
					echo_hex(r4, r11);
					echo_string(r4, ',');
					// fprintf(data, "0%xh,", (((token_stack[token] >> 6) & 0x3f) + 0x80));
					r11 = r3 >> 6;
					r11 = r11 && 03fh;
					r11 = r11 + 80h;
					echo_hex(r4, r11);
					echo_string(r4, ',');
					// fprintf(data, "0%xh,", ((token_stack[token] & 0x3f) + 0x80));
					r11 = r3 && 03fh;
					r11 = r11 + 80h;
					echo_hex(r4, r11);
					echo_string(r4, ',');
				}
			}
		}
		pop r0;
		r0 = r0 + 1;
		token = r0;
		r2 = 0;
		r3 = &token_stack;
		r3 = [r3+r0*8];
		if (r3 != r9){
			if (r0 != r1){
				r2 = 1;
			}
		}
	}
	echo_string(r4, '0\n');
	pop r12, r11, r10, r9, r4, r3, r2, r1;
	return(1);		
}

proc outputNumber(i, dec, file_handle){
	m64 dec_flag;
	//echo_string(STDOUT, 'OutputNumber\n');
	push r1, r2, r3, r4, r5, r9, r10, r11, r12;
	r9 = TOKEN_OFFSET;
	r0 = token;
	r1 = i;
	r5 = dec;
	r2 = 0; // Flag to exit the while statement;
	dec_flag = r2;
	r4 = file_handle;
	r3 = &token_stack;
	r3 = [r3+r0*8];
	if (r3 < r9){
		if (r0 != r1){
			r2 = 1;
		}
	}
	while (r2){
		push r0;
		r12 = NUM_DECIMAL;
		if (r5 == r12){
			// Only allow digits and '.' in number
			// if (((token_stack[token] >= 'a') && (token_stack[token] <= 'f')) ||	(token_stack[token] == 'h'))
			//	abort_b0("Unexpected hexadecimal value");
			r0 = CHAR_h;  // == 'h'
			if (r3 == r0){
				abort_b0('Unexpected hexadecimal value');
			}
			r12 = r3 - CHAR_a; 	// sub 'a' from the value to normalise the value
			r0 = 6;				// if between 0 and 5 then we have 'a' -> 'f'.
			if (r12 < r0){		// and a single test is all we need...
				// Lets check for a decimal.
				r0 = dec_flag;
				if(r0){
					r0 = 4;			// we still need to allow 1.0e10 type notation.
					if(r12 != r0){
						abort_b0('Unexpected hexadecimal value');
					} else {
						push r3;
						r3 = &token_stack;
						r0 = token;
						r12 = [r3+r0*8-8];
						pop r3;
						r0 = CHAR_STOP;
						if(r12 == r0){
							// If our previous character was a '.' then we have invalid input.
							abort_b0('Illformed floating point value - please revise');
						}
					}
				} else {
					abort_b0('Unexpected hexadecimal value');
				}
			}			
			// if ((dec_flag == 1)&&(token_stack[token] == '.'))
			//	abort_b0("Unexpected second decimal");
			// if (token_stack[token] == '.')
			//	dec_flag = 1;
			r0 = CHAR_STOP;
			if (r3 == r0){
				r0 = dec_flag;
				if (r0){
					abort_b0('Unexpected second decimal');
				}
				r0 = 1;
				dec_flag = r0;
			}
			// fprintf(code, "%c", token_stack[token] );
			echo_character(r4, r3);
		} else {
			// allow all xdigits except .
			// if (token_stack[token] == '.')
			//	abort_b0("Unexpected floating point value");
			r0 = CHAR_STOP; // r0 = '.';
			if (r3 == r0){
				abort_b0('Unexpected floating point value');
			}
			// fprintf(code, "%c", token_stack[token] );
			echo_character(r4, r3);
		}
		pop r0;
		r0 = r0 + 1;
		token = r0;
		r2 = 0;
		r3 = &token_stack;
		r3 = [r3+r0*8];
		if (r3 < r9){
			if (r0 != r1){
				r2 = 1;
			}
		}
	}
	//if ((dec == NUM_DECIMAL) && (dec_flag == 0))
		//fprintf(data, ".0");
	r1 = dec;
	r0 = NUM_DECIMAL;
	if (r0 == r1){
		r0 = dec_flag;
		r1 = 0;
		if (r0 == r1) {
			echo_string(r4, '.0');
		}
	}
	pop r12, r11, r10, r9, r5, r4, r3, r2, r1;
	//echo_string(STDOUT, 'EndOutputNumber\n');
	return(1);
}

proc SetState(){
	push r3;
	r0 = token;
	r3 = &token_stack;
	r3 = [r3+r0*8];
	r3 = r3 - HASH_OFFSET;
	r0 = hash_table[r3].token_type;
	r0 = r0 && 0fh;
	r3 = TYPE_M8;
	if (r0 == r3){
		r3 = CHAR_b; // 'b'
		state = r3;
		pop r3;
		return(r0);
	}
	r3 = TYPE_M16;
	if (r0 == r3){
		r3 = CHAR_w; // 'w'
		state = r3;
		pop r3;
		return(r0);
	}
	#ifndef i386;
	r3 = TYPE_M32;
	if (r0 == r3){
		r3 = CHAR_d; // 'd'
		state = r3;
		pop r3;
		return(r0);
	}
	r3 = TYPE_M64;
	if (r0 == r3){
		r3 = CHAR_SPACE; // ' '
		state = r3;
		pop r3;
		return(r0);
	}
	#else;
	r3 = TYPE_M32;
	if (r0 == r3){
		r3 = CHAR_SPACE; // ' '
		state = r3;
		pop r3;
		return(r0);
	}	
	#endif;
	r3 = TYPE_F32;
	if (r0 == r3){
		r3 = CHAR_3; // '3'
		state = r3;
		pop r3;
		return(r0);
	}
	r3 = TYPE_F64;
	if (r0 == r3){
		r3 = CHAR_6; // '6'
		state = r3;
		pop r3;
		return(r0);
	}
	r3 = TYPE_F80;
	if (r0 == r3){
		r3 = CHAR_8; // '8'
		state = r3;
		pop r3;
		return(r0);
	}
}

proc TokenIs(tok){
	push r3;
	r0 = token;
	r3 = &token_stack;
	r3 = [r3+r0*8];
	r0 = tok;
	if (r0 != r3){
		r3 = TOKEN_AND;if (r0 == r3) { abort_b0('&& Expected'); }
		r3 = TOKEN_OR; if (r0 == r3) { abort_b0('| Expected'); }
		r3 = TOKEN_XOR; if (r0 == r3) { abort_b0('^ Expected'); }
		r3 = TOKEN_NOT; if (r0 == r3) { abort_b0('! Expected'); }
		r3 = TOKEN_EQUATE; if (r0 == r3) { abort_b0('= Expected'); }
		r3 = TOKEN_ADD; if (r0 == r3) { abort_b0('+ Expected'); }
		r3 = TOKEN_MINUS; if (r0 == r3) { abort_b0('- Expected'); }
		r3 = TOKEN_MULTIPLY; if (r0 == r3) { abort_b0('* Expected'); }
		r3 = TOKEN_DIVIDE; if (r0 == r3) { abort_b0('/ Expected'); }
		r3 = TOKEN_MODULUS; if (r0 == r3) { abort_b0('% Expected'); }
		r3 = TOKEN_S_MULTIPLY; if (r0 == r3) { abort_b0('~* Expected'); }
		r3 = TOKEN_S_DIVIDE; if (r0 == r3) { abort_b0('~/ Expected'); }
		r3 = TOKEN_S_MODULUS; if (r0 == r3) { abort_b0('~% Expected'); }
		r3 = TOKEN_RSHIFT; if (r0 == r3) { abort_b0('>> Expected'); }
		r3 = TOKEN_LSHIFT; if (r0 == r3) { abort_b0('<< Expected'); }
		r3 = TOKEN_RROTATE; if (r0 == r3) { abort_b0('>>> Expected'); }
		r3 = TOKEN_LROTATE; if (r0 == r3) { abort_b0('<<< Expected'); }
		r3 = TOKEN_EQUALS; if (r0 == r3) { abort_b0('== Expected'); }
		r3 = TOKEN_NOTEQUALS; if (r0 == r3) { abort_b0('!= Expected'); }
		r3 = TOKEN_LESSTHAN; if (r0 == r3) { abort_b0('< Expected'); }
		r3 = TOKEN_GREATERTHAN; if (r0 == r3) { abort_b0('> Expected'); }
		r3 = TOKEN_LESSTHANEQUALS; if (r0 == r3) { abort_b0('<= Expected'); }
		r3 = TOKEN_GREATERTHANEQUALS; if (r0 == r3) { abort_b0('>= Expected'); }
		r3 = TOKEN_S_LESSTHAN; if (r0 == r3) { abort_b0('~< Expected'); }
		r3 = TOKEN_S_GREATERTHAN; if (r0 == r3) { abort_b0('~> Expected'); }
		r3 = TOKEN_S_LESSTHANEQUALS; if (r0 == r3) { abort_b0('~<= Expected'); }
		r3 = TOKEN_S_GREATERTHANEQUALS; if (r0 == r3) { abort_b0('~>= Expected'); }
		r3 = TOKEN_STRING; if (r0 == r3) { abort_b0('Start of String Expected'); }
		r3 = TOKEN_END_STRING; if (r0 == r3) { abort_b0('End of String Expected'); }
		r3 = TOKEN_PARA_START; if (r0 == r3) { abort_b0('( Expected'); }
		r3 = TOKEN_PARA_END; if (r0 == r3) { abort_b0(') Expected'); }
		r3 = TOKEN_POINTER; if (r0 == r3) { abort_b0('& Expected'); }
		r3 = TOKEN_ARRAY_START; if (r0 == r3) { abort_b0('[ Expected'); }
		r3 = TOKEN_ARRAY_END; if (r0 == r3) { abort_b0('] Expected'); }
		r3 = TOKEN_FULLSTOP; if (r0 == r3) { abort_b0('. Expected'); }
		abort_b0('Unknown Token');
	}
	pop r3;
	return(1);
}

proc callProc(who, return_reg, i){
	//int local_offset;
	m64 local_offset;
	m64 WarningIssued;
	push r1, r2, r3, r4;
	
	WarningIssued = 0;

	//if(DEBUG)
	//	printf("Processing Function call with target\n");
	
	r0 = DEBUG;
	if (r0){
		echo_string(STDOUT, 'Processing Function call with target\n');
	}
	//local_offset = 0;
	r0 = r0 ^ r0;
	local_offset = r0;
	//token++
	r0 = token;
	r0 = r0 + 1;
	token = r0;
	//TokenIs(TOKEN_PARA_START);
	TokenIs(TOKEN_PARA_START);
	//token++; // Move onto the next token
	r0 = token;
	r0 = r0 + 1;
	token = r0;
	
	// First set our local variable block
	// All we do in save r0 (if required), push esi, and add the amount of space used to nearest 8 bytes
	//if (return_reg != HASH_r0)
	//	fprintf(code, "\tpush r0\n");
	r0 = return_reg;
	r1 = HASH_r0;
	if (r0 != r1){
		r0 = code;
		echo_string(r0, '\tpush r0\n');
	}
	
	//#ifndef i386
	//fprintf(code, "\tpush r6\n\tadd r6, 0%xh\n", (((hash_table[(global-HASH_OFFSET)].local_offset/8)+1)*8) );
	//#else
	//fprintf(code, "\tpush r6\n\tadd r6, 0%xh\n", (((hash_table[(global-HASH_OFFSET)].local_offset/4)+1)*4) );
	//#endif

	r0 = global;
	r0 = r0 - HASH_OFFSET;
	r2 = hash_table[r0].local_offset;
	#ifndef i386;
	r2 = r2 >> 3;	// div 8
	r2 = r2 + 1;
	r2 = r2 << 3;	// mul 8;
	#else;
	r2 = r2 >> 2;	// div 4
	r2 = r2 + 1;
	r2 = r2 << 2;	// mul 4;
	#endif;	
	r1 = code;
	
	r0 = STACK_FRAME;
	if(r0){
		echo_string(r1, '\tpush r6\n\tadd r6, ');
		echo_hex(r1, r2);
		echo_string(r1, '\n');
	}

	r0 = i;
	r1 = token;
	if(r1 >= r0){
		abort_b0('Unexpected end of procedure call');
	}

	
	//while (token_stack[token] != TOKEN_PARA_END){
	r3 = token;
	r2 = &token_stack;
	r3 = [r2+r3*8];
	r2 = TOKEN_PARA_END;
	while(r2 != r3){
		r0 = STACK_FRAME;
		r4 = 0;
		//if((STACK_FRAME == 0)&&(WarningIssued == 0)){
		if(r0 == r4){
			//issue warning that passing local variables, but stack frame has not been setup
			//if(HeaderPrinted == 0)
				//PrintHeader();
			r0 = WarningIssued;
			if(r0 == r4){
				r0 = WarningsDisabled;
				if(r0 == r4){
					r0 = HeaderPrinted;
					if(r0 == r4){
						PrintHeader();
					}
					//printf("WARNING: Stack frame creation has been disabled, current local variable\n frame will be overwritten\n");
					echo_string(STDOUT, 'WARNING: Stack frame creation has been disabled, current local variable\n frame will be overwritten during this procedure call\n');
					//printf("Filename: %s Line: %d.\n",file[file_stack_ptr].filename, (file[file_stack_ptr].line_count));
					echo_string(STDOUT, 'Filename: ');
					r4 = file_stack_ptr;
					r0 = &file[r4].filename;
					echo_string(STDOUT, r0);
					echo_string(STDOUT, ' Line: ');
					r0 = file[r4].line_count;
					echo_integer(STDOUT, r0);
					echo_string(STDOUT, '.\n');
				}
			}
			WarningIssued = 1;
		}
		//if ((token_stack[token] == TOKEN_STRING) || (token_stack[token] == TOKEN_POINTER)) {
		r4 = 0;
		r2 = TOKEN_STRING;
		if (r3 == r2){
			r4 = 1;
		}
		r2 = TOKEN_POINTER;
		if (r3 == r2){
			r4 = 1;
		}
		if (r4){
			//if (token_stack[token] == TOKEN_POINTER){
			//	token++;
			//}
			if (r3 == r2){
				r0 = token;
				r0 = r0 + 1;
				token = r0;
			}
			//TokenIs(TOKEN_STRING);
			TokenIs(TOKEN_STRING);
			//token++;
			r0 = token;
			r0 = r0 + 1;
			token = r0;
			
			//if (UTF8_STRINGS == 0){
			//	fprintf(data, "UTF16_STRING B0_DynStr%d , ", dynamic_string_count);
			//	outputString(i);
			//} else {
			//	fprintf(data, "UTF8_STRING B0_DynStr%d , ", dynamic_string_count);
			//	outputStringUTF8(i);
			//}
			r0 = UTF8_STRINGS;
			if (r0){
				r4 = data;
				r2 = dynamic_string_count;
				r3 = i;
				echo_string(r4, 'UTF8_STRING B0_DynStr');
				echo_integer(r4, r2);
				echo_string(r4, ' , ');
				outputString(r3);
			} else {
				r4 = data;
				r2 = dynamic_string_count;
				r3 = i;
				echo_string(r4, 'UTF16_STRING B0_DynStr');
				echo_integer(r4, r2);
				echo_string(r4, ' , ');
				outputStringUTF8(r3);
			}
			
			//TokenIs(TOKEN_END_STRING);
			TokenIs(TOKEN_END_STRING);
			
			//#ifndef i386
			//fprintf(code, "\tpush r0\n\tmov r0, B0_DynStr%d\n\tmov qword [r6+0%xh], r0\n\tpop r0\n", dynamic_string_count, local_offset);
			//#else
			//fprintf(code, "\tpush r0\n\tmov r0, B0_DynStr%d\n\tmov dword [r6+0%xh], r0\n\tpop r0\n", dynamic_string_count, local_offset);
			//#endif
						// We place the string offset into r0, and then store it rather than using "mov mem64, imm64" as this opcode
						// doesn't exist! fasm truncates the immediate to 32bits to form a valid opcode.
			r4 = code;
			echo_string(r4, '\tpush r0\n\tmov r0, B0_DynStr');
			r2 = dynamic_string_count;
			echo_integer(r4, r2);
			#ifndef i386;
			echo_string(r4, '\n\tmov qword [r6+');
			#else;
			echo_string(r4, '\n\tmov dword [r6+');
			#endif;
			r2 = local_offset;
			echo_hex(r4, r2);
			echo_string(r4, '], r0\n\tpop r0\n');
			
			//dynamic_string_count++; // Inc the number of dynamic strings we have
			r2 = dynamic_string_count;
			r2 = r2 + 1;
			dynamic_string_count = r2;
			
		//} else {
		} else {
			//if ((token_stack[token] < TOKEN_OFFSET) || (token_stack[token] == TOKEN_MINUS)) {
			r4 = 0;
			r2 = TOKEN_OFFSET;
			if (r3 < r2){
				r4 = 1;
			}
			r2 = TOKEN_MINUS;
			if (r3 == r2){
				r4 = 1;
			}
			if(r4){
				// We have an immediate load
				//#ifndef i386
				//fprintf(code, "\tmov qword [r6+0%xh], ", local_offset);
				//#else
				//fprintf(code, "\tmov dword [r6+0%xh], ", local_offset);
				//#endif
				r4 = code;
				r2 = local_offset;
				#ifndef i386;
				echo_string(r4, '\tmov qword [r6+');
				#else;
				echo_string(r4, '\tmov dword [r6+');
				#endif;
				echo_hex(r4, r2);
				echo_string(r4, '], ');
				
				//if (token_stack[token] == TOKEN_MINUS) {
				//	token++;
				//	fprintf(code, "-");
				//}
				r2 = TOKEN_MINUS;
				if (r3 == r2){
					r0 = token;
					r0 = r0 + 1;
					token = r0;
					r4 = code;
					echo_string(r4, '-');
				}
				
				//outputNumber(i, NUM_INTEGER);
				r0 = i;
				r4 = code;
				outputNumber(r0, NUM_INTEGER, r4);
				
				//fprintf(code, "\n");
				r4 = code;
				echo_string(r4, '\n');
				//token--; // Adjust for token++ below.
				r0 = token;
				r0 = r0 - 1;
				token = r0;
			//} else {
			} else {
				//TokenIsLabelType(TYPE_REG); // Otherwise only accept 64bit registers
				TokenIsLabelType(TYPE_REG); // Otherwise only accept 64bit registers
				//fprintf(code, "\tmov [r6+0%xh], %s\n", local_offset, hash_table[token_stack[token]-HASH_OFFSET].token);
				r4 = code;
				r2 = local_offset;
				r3 = r3 - HASH_OFFSET;
				r3 = &hash_table[r3].token;
				echo_string(r4, '\tmov [r6+');
				echo_hex(r4, r2);
				echo_string(r4, '], ');
				echo_string(r4, r3);
				echo_string(r4, '\n');
			}
		}
		//token++;
		r0 = token;
		r0 = r0 + 1;
		token = r0;
		//#ifndef i386
		//local_offset += 8; // Move the offset forward 8.
		//#else
		//local_offset += 4; // Move the offset forward 4.
		//#endif
		r0 = local_offset;
		#ifndef i386;
		r0 = r0 + 8;
		#else;
		r0 = r0 + 4;
		#endif;
		local_offset = r0;
		
		//if(token_stack[token] == TOKEN_COMMA)
		//	token++;
		r3 = token;
		r2 = &token_stack;
		r3 = [r2+r3*8];
		r2 = TOKEN_COMMA;
		if (r3 == r2){
			r0 = token;
			r0 = r0 + 1;
			token = r0;
		}
		
		r0 = i;
		r1 = token;
		if(r1 >= r0){
			abort_b0('Unexpected end of procedure call');
		}
		
		// refill the condition registers.
		r3 = token;
		r2 = &token_stack;
		r3 = [r2+r3*8];
		r2 = TOKEN_PARA_END;
	}
	r0 = i;
	r1 = token;
	if(r1 >= r0){
		abort_b0('Unexpected end of procedure call');
	}
	//TokenIs(TOKEN_PARA_END); // Final token should be the )
	TokenIs(TOKEN_PARA_END); // Final token should be the )
	//token++;
	r0 = token;
	r0 = r0 + 1;
	token = r0;
	//atStackEnd(i);
	r0 = i;
	atStackEnd(r0);
	// Lets call our procedure
	//if (hash_table[who].token_type == TYPE_EPROC){
	//	if (SOURCE_TYPE != SOURCE_PE){
	//		fprintf(code, "\tcall %s\n", hash_table[who].token);
	//	} else {
	//		fprintf(code, "\tcall [%s]\n", hash_table[who].token);
	//	}
	//} else {
	//	fprintf(code, "\tcall _B0_%s\n", hash_table[who].token);		
	//}
	r1 = who;
	r0 = hash_table[r1].token_type;
	r3 = TYPE_EPROC;
	r2 = &hash_table[r1].token;
	r4 = code;
	if (r0 == r3){
		r3 = SOURCE_PE;
		r1 = SOURCE_TYPE;
		if (r1 != r3){
			echo_string(r4, '\tcall ');
			echo_string(r4, r2);
			echo_string(r4, '\n');
		} else {
			echo_string(r4, '\tcall [');
			echo_string(r4, r2);
			echo_string(r4, ']\n');
		}
	} else {
		echo_string(r4, '\tcall _B0_');
		echo_string(r4, r2);
		echo_string(r4, '\n');
	}
	
	// Reset esi to point to our local variables.
	//fprintf(code, "\tpop r6\n");	// Restore our frame pointer
	r0 = STACK_FRAME;
	if(r0){
		echo_string(r4, '\tpop r6\n');
	}
	
	//if (return_reg != HASH_r0){
	//	fprintf(code, "\tmov %s, r0\n", hash_table[return_reg].token); // Copy our result to the target reg
	//	fprintf(code, "\tpop r0\n"); // And restore r0, back to our default.
	//}
	r1 = return_reg;
	r0 = HASH_r0;
	if (r1 != r0){
		r2 = &hash_table[r1].token;
		echo_string(r4, '\tmov ');
		echo_string(r4, r2);
		echo_string(r4, ', r0\n\tpop r0\n');
	}
	pop r4, r3, r2, r1;
	return(1);
}

proc outputDynamicString(i){
	//token++;
	push r1, r2, r3, r4;
	r0 = token;
	r0 = r0 + 1;
	token = r0;
	//Point to the first char.
	// dynamic_string_count = string number.
	
	//if (UTF8_STRINGS == 0){
	r0 = UTF8_STRINGS;
	if(r0){
		//fprintf(data, "UTF16_STRING B0_DynStr%d , ", dynamic_string_count);
		r4 = data;
		r3 = dynamic_string_count;
		echo_string(r4, 'UTF8_STRING B0_DynStr');
		echo_integer(r4, r3);
		echo_string(r4, ' , ');
		//outputString(i);
		r0 = i;
		outputString(r0);
	} else {
		//fprintf(data, "UTF8_STRING B0_DynStr%d , ", dynamic_string_count);
		r4 = data;
		r3 = dynamic_string_count;
		echo_string(r4, 'UTF16_STRING B0_DynStr');
		echo_integer(r4, r3);
		echo_string(r4, ' , ');
		//outputStringUTF8(i);
		r0 = i;
		outputStringUTF8(r0);
	}
	//fprintf(code, "\tmov %s, B0_DynStr%d\n", hash_table[target].token, dynamic_string_count);
	r4 = code;
	r3 = target;
	r3 = &hash_table[r3].token;
	r2 = dynamic_string_count;
	echo_string(r4, '\tmov ');
	echo_string(r4, r3);
	echo_string(r4, ', B0_DynStr');
	echo_integer(r4, r2);
	echo_string(r4, '\n');
	//dynamic_string_count++; // Inc the number of dynamic strings we have
	r2 = r2 + 1;
	dynamic_string_count = r2;
	//token++;
	r0 = token;
	r0 = r0 + 1;
	token = r0;
	pop r4, r3, r2, r1;
	return(1);
}

proc setDefine(def_hash, i){
	// i = end of stack;
	// token = current stack pointer;
	// def_hash = the hash value of the label we are setting;
	//int isNeg = 0;
	//int isFP = 0;  		// 0 = int, 1 = fp (decimal), 2 = hex (aka int)
	//long value;			// Our value
	//double fp_value;		// Our value in fp
	//double fp_value2;		//
	
	m64 isNeg;
	m64 isFP;
	m64 value;
	f64 fp_value;
	f64 fp_value2;
	
	//if ((token_stack[token] == TOKEN_MINUS)||(token_stack[token] == '-')){
	//	isNeg = 1;
	//	token++;
	//	if(token == i)
	//		abort_b0("Expected value?");
	//}

	push r1, r2, r3, r4, r5;
	
	r2 = token;
	r3 = &token_stack;
	r3 = [r3+r2*8];
	r2 = 0;
	isNeg = r2;
	isFP = r2;
	r1 = TOKEN_MINUS;
	if (r3 == r1){
		r2 = 1;
	}
	r1 = CHAR_MINUS; // '-'
	if (r3 == r1){
		r2 = 1;
	};
	if(r2){
		isNeg = r2;
		r0 = token;
		r0 = r0 + 1;
		token = r0;
		r1 = i;
		if (r0 >= r1){
			abort_b0('Expected value?');
		}
	}
	
	//Move the value in a separate NULL terminated string;
	//toki = 0;
	r0 = 0;
	toki = r0;
	
	//Initialise the buffer
	r4 = &token_buffer;
	r1 = 0fdh;
	[r4] = r1;
	r0 = r0 + 2; //Skip the size markers.
	
	//while ((token_stack[token] < TOKEN_OFFSET) && (token != i)) {
	//	token_buffer[toki] = (unsigned char)token_stack[token];
	//	token_buffer[toki+1] = '\0';
	//	toki++;
	//	token++;
	//	if (toki >= TOKEN_MAX_SIZE) abort_b0("INTERNAL: Token Preprocessor Buffer Overflow! - Increase TOKEN_STACK_SIZE");	
	//}
	r5 = 0;
	r2 = token;
	r4 = i;
	r3 = &token_stack;
	r3 = [r3+r2*8];
	r1 = TOKEN_OFFSET;
	if (r3 < r1){
		if (r2 != r4){
			r5 = 1;
		}
	}
	while(r5){
		r5 = 0;
		r3 = &token_stack;
		r4 = &token_buffer;
		r8 = [r3+r2*8];
		[r4+r0] = r8b;
		[r4+r0+1] = r5b;
		r0 = r0 + 1;		//toki++
		r2 = r2 + 1;		//token++
		token = r2;
		r1 = TOKEN_MAX_SIZE;
		if (r0 >= r1){
			abort_b0('INTERNAL: Token Preprocessor Buffer Overflow! - Increase TOKEN_MAX_SIZE');
		}
		
		// End test condition
		//r5 = 0;
		//r2 = token;
		r4 = i;
		//r3 = &token_stack;
		r3 = [r3+r2*8];
		r1 = TOKEN_OFFSET;
		if (r3 < r1){
			if (r2 != r4){
				r5 = 1;
			}
		}
	}
	
	//if(DEBUG)
	//	printf("token_buffer = %s\n", token_buffer);
	r1 = DEBUG;
	if (r1){
		echo_string(STDOUT, 'token_buffer = ');
		r1 = &token_buffer;
		echo_string(STDOUT, r1);
		echo_string(STDOUT, '\n');
	}
	
	// token_buffer now holds our value in string form.
	//toki = 0;
	r0 = 0;
	toki = r0;
	
	r4 = &token_buffer;
	r4 = r4 + 2;	//Skip size offset
	
	r2 = r0;
	r2b = [r4];
	
	r0 = isFP;
	
	//while (token_buffer[toki] != '\0'){
	while(r2){
		//if (token_buffer[toki] == '.'){
			// Looks like a decimal
		//	if (isFP == 2)
		//		abort_b0("Invalid construct");
		//	isFP = 1;
		//}
		r1 = CHAR_STOP;
		if (r1 == r2){
			// Looks like a decimal
			r3 = 2;
			if (r0 == r3){
				abort_b0('Invalid construct');
			}
			r0 = 1;		// Set isFP = 1
		}
		//if ( ((token_buffer[toki] >= 'a') && (token_buffer[toki] <= 'f')) || (token_buffer[toki]  == 'h') ){
		//	if (isFP == 1)
		//		abort_b0("Invalid construct");
		//	isFP = 2;
		//}
		r1 = CHAR_a; // 'a'
		if (r2 >= r1){
			r3 = 1;
			if (r0 == r3){
				r1 = CHAR_e;
				if(r2 != r1){
					abort_b0('Invalid Construct');
				}
			} else{
				r0 = 2;
			}
		}
		
		//toki++;
		r4 = r4 + 1;
		r2 = 0;
		r2b = [r4];
	}
	
	r3 = 1;
	
	//if (isFP == 1) {
	if(r0 == r3){
		// Convert our string to a floating point value
		//fp_value = atof(( char *) token_buffer);
		r4 = &token_buffer;
		atof(r4);
		//if (isNeg == 1)
		//	fp_value = 0 - fp_value; // Simple negate operation
		r2 = isNeg;
		if (r2){
			-fp0;
		}
		//if(DEBUG)
		//	printf("atof = %f\n", fp_value);
		r2 = DEBUG;
		if (r2){
			echo_string(STDOUT, 'atof = ');
			echo_float(STDOUT);
			echo_string(STDOUT, '\n');
		}
		//hash_table[def_hash].token_type = TYPE_DEFINE + TYPE_F64;
		r0 = def_hash;
		r2 = TYPE_DEFINE + TYPE_F64;
		hash_table[r0].token_type = r2;
		//hash_table[def_hash].define_fp = fp_value;
		hash_table[r0].define_fp = fp0;
		fp_value = fp0;
		
		//if(DEBUG){
		//	fp_value2 = hash_table[def_hash].define_fp;
		//	printf("fp_val2 = %f\n", fp_value2);
		//}
		r2 = DEBUG;
		if (r2){
			fp0 = hash_table[r0].define_fp;
			echo_string(STDOUT, 'fp_val2 = ');
			echo_float(STDOUT);
			echo_string(STDOUT, '\n');
		}
		
	} else {
		// Convert our string to an integer
		//value = dhtoi(token_buffer);
		r4 = &token_buffer;
		r2 = dhtoi(r4);
		//echo_hex(STDOUT, r2);
		//echo_string(STDOUT, '\n');
		r1 = isNeg;
		//if (isNeg == 1)
		//	value = 0 - value; // Simple negate operation
		if (r1){
			-r2;
		}
		
		//#ifndef i386
		//hash_table[def_hash].token_type = TYPE_DEFINE + TYPE_M64;
		//#else
		//hash_table[def_hash].token_type = TYPE_DEFINE + TYPE_M32;
		//#endif
		//hash_table[def_hash].define_int = value;
		r0 = def_hash;
		#ifndef i386;
		r1 = TYPE_DEFINE + TYPE_M64;
		#else;
		r1 = TYPE_DEFINE + TYPE_m32;
		#endif;
		hash_table[r0].token_type = r1;
		hash_table[r0].define_int = r2;
	}
	
	//if(DEBUG)
	//	printf("define %s; type 0%xh; value 0%lxh or %f\n", hash_table[def_hash].token, hash_table[def_hash].token_type, hash_table[def_hash].define_int, hash_table[def_hash].define_fp);
	r0 = DEBUG;
	r1 = def_hash;
	if (r0){
		echo_string(STDOUT, 'define ');
		r0 = &hash_table[r1].token;
		echo_string(STDOUT, r0);
		echo_string(STDOUT, '; type ');
		r0 = hash_table[r1].token_type;
		echo_hex(STDOUT, r0);
		echo_string(STDOUT, '; value ');
		r0 = hash_table[r1].define_int;
		echo_hex(STDOUT, r0);
		echo_string(STDOUT, ' or ');
		fp0 = hash_table[r1].define_fp;
		echo_float(STDOUT);
		fp_value = fp0;	// get it off the stack;
		echo_string(STDOUT, '\n');
	}
	
	pop r5, r4, r3, r2, r1;
	return(1);
}

proc checkDefine(def_hash, comparison, i){
	// def_hash = the has we are testing
	// comparision = the test
	// i = end of token_stack.
	// token = current start of string of the number to test against.
	//int isNeg = 0;
	//int isFP = 0;  		// 0 = int, 1 = fp (decimal), 2 = hex (aka int)
	//long value;			// Our value
	//double fp_value;		// Our value in fp
	//double fp_value2;	//
	
	m64 isNeg;
	m64 isFP;
	m64 value;
	f64 fp_value;
	f64 fp_value2;
	
	//if ((token_stack[token] == TOKEN_MINUS)||(token_stack[token] == '-')){
	//	isNeg = 1;
	//	token++;
	//	if(token == i)
	//		abort_b0("Expected value?");
	//}

	push r1, r2, r3, r4, r5;
	r0 = DEBUG;
	if(r0){
		echo_string(STDOUT, 'CheckDefine();\n');
	}
	r2 = token;
	r3 = &token_stack;
	r3 = [r3+r2*8];
	r2 = 0;
	isNeg = r2;
	isFP = r2;
	r1 = TOKEN_MINUS;
	if (r3 == r1){
		r2 = 1;
	}
	r1 = CHAR_MINUS; // '-'
	if (r3 == r1){
		r2 = 1;
	};
	if(r2){
		isNeg = r2;
		r0 = token;
		r0 = r0 + 1;
		token = r0;
		r1 = i;
		if (r0 >= r1){
			abort_b0('Expected value?');
		}
	}
	
	//Move the value in a separate NULL terminated string;
	//toki = 0;
	//while ((token_stack[token] < TOKEN_OFFSET) && (token != i)) {
		//token_buffer[toki] = (unsigned char)token_stack[token];
		//token_buffer[toki+1] = '\0';
		//toki++;
		//token++;
		//if (toki >= TOKEN_MAX_SIZE) abort_b0("INTERNAL: Token Preprocessor Buffer Overflow! - Increase TOKEN_MAX_SIZE");
	//}
	r5 = 0;
	r2 = token;
	r4 = i;
	r3 = &token_stack;
	r3 = [r3+r2*8];
	r1 = TOKEN_OFFSET;
	if (r3 < r1){
		if (r2 != r4){
			r5 = 1;
		}
	}
	r0 = 0;
	while(r5){
		r5 = 0;
		r3 = &token_stack;
		r4 = &token_buffer;
		r4 = r4 + 2;
		r8 = [r3+r2*8];
		[r4+r0] = r8b;
		[r4+r0+1] = r5b;
		r0 = r0 + 1;		//toki++
		r2 = r2 + 1;		//token++
		token = r2;
		r1 = TOKEN_MAX_SIZE;
		if (r0 >= r1){
			abort_b0('INTERNAL: Token Preprocessor Buffer Overflow! - Increase TOKEN_MAX_SIZE');
		}
		
		// End test condition
		//r5 = 0;
		//r2 = token;
		r4 = i;
		//r3 = &token_stack;
		r3 = [r3+r2*8];
		r1 = TOKEN_OFFSET;
		if (r3 < r1){
			if (r2 != r4){
				r5 = 1;
			}
		}
	}
	
	r0 = 0;
	toki = r0;
	
	r4 = &token_buffer;
	r4 = r4 + 2;	//Skip size offset
	
	r2 = r0;
	r2b = [r4];
	
	r0 = isFP;
	
	//while (token_buffer[toki] != '\0'){
	while(r2){
		//if (token_buffer[toki] == '.'){
			// Looks like a decimal
		//	if (isFP == 2)
		//		abort_b0("Invalid construct");
		//	isFP = 1;
		//}
		r1 = CHAR_STOP;
		if (r1 == r2){
			// Looks like a decimal
			r3 = 2;
			if (r0 == r3){
				abort_b0('Invalid construct');
			}
			r0 = 1;		// Set isFP = 1
			isFP = r0;
		}
		//if ( ((token_buffer[toki] >= 'a') && (token_buffer[toki] <= 'f')) || (token_buffer[toki]  == 'h') ){
		//	if (isFP == 1)
		//		abort_b0("Invalid construct");
		//	isFP = 2;
		//}
		r1 = CHAR_a; // 'a'
		if (r2 >= r1){
			r3 = 1;
			if (r0 == r3){
				r1 = CHAR_e;
				if(r2 != r1){
					abort_b0('Invalid Construct');
				}
			} else {
				r0 = 2;
				isFP = r0;
			}
		}
		
		//toki++;
		r4 = r4 + 1;
		r2 = 0;
		r2b = [r4];
	}	
	
	r3 = 1;
	
	//if (isFP == 1) {
	if(r0 == r3){
		// Convert our string to a floating point value
		//fp_value = atof(( char *) token_buffer);
		r4 = &token_buffer;
		atof(r4);
		//if (isNeg == 1)
		//	fp_value = 0 - fp_value; // Simple negate operation
		r2 = isNeg;
		if (r2){
			-fp0;
		}
		//if(DEBUG)
		//	printf("atof = %f\n", fp_value);
		r2 = DEBUG;
		if (r2){
			echo_string(STDOUT, 'atof = ');
			echo_float(STDOUT);
			echo_string(STDOUT, '\n');
		}
	} else {
		// Convert our string to an integer
		//value = dhtoi(token_buffer);
		r4 = &token_buffer;
		r2 = dhtoi(r4);
		
		r1 = isNeg;
		//if (isNeg == 1)
		//	value = 0 - value; // Simple negate operation
		if (r1){
			-r2;
		}
		//fp_value = value; // Convert long to double?
		value = r2;
		fp0 = value;
	}	
	
	
	// Our test values have been converted
	// Check to see if our hash is a DEFINE or exists?
	//if ((hash_table[def_hash].token_type & TYPE_DEFINE) != TYPE_DEFINE)
		//return(0); // Isn't a define or doesn't exist, then exit
	r1 = def_hash;
	r0 = TYPE_DEFINE;
	r2 = hash_table[r1].token_type;
	r2 = r2 && r0;
	if (r2 != r0){
		value = fp0;
		pop r5, r4, r3, r2, r1;
		return(0);
	}
		
	//if ((hash_table[def_hash].token_type & TYPE_F64) == TYPE_F64){
	r1 = def_hash;
	r0 = TYPE_F64;
	r2 = hash_table[r1].token_type;
	r2 = r2 && r0;
	if (r2 != r0){
		//fp_value2 = hash_table[def_hash].define_fp;
		fp0 = hash_table[r1].define_fp;
	//} else {
	} else {
		//fp_value2 = hash_table[def_hash].define_int;
		fp0 = hash_table[r1].define_int;
		r1 = DEBUG;
		//if(DEBUG)
			//printf("loading fp_value2 with int\n");
		if(r1){
			echo_string(STDOUT, 'loading fp_value2 with int\n');
		}
	//};
	}
	//if(DEBUG)
		//printf("define_val = %f\ncheck_val = %f\n", fp_value2, fp_value);
	// fp_value = our test against value
	// fp_value2 = value of define.

	r1 = DEBUG;
	if(r1){
		echo_string(STDOUT, 'define_val = ');
		echo_float(STDOUT);
		echo_string(STDOUT, '\ncheck_val = ');
		fp1 = fp0;	// swap the values
		echo_float(STDOUT);
		fp1 = fp0;	// swap back.
		echo_string(STDOUT, '\n');
	}
	//fp0 = fp_value2;
	//fp1 = fp_value;
	
	
	//switch(comparison){
		//case TOKEN_EQUALS: if(fp_value2 == fp_value) return(1); break;
		//case TOKEN_NOTEQUALS: if(fp_value2 != fp_value) return(1); break;
		//case TOKEN_LESSTHAN: if(fp_value2 < fp_value) return(1); break;
		//case TOKEN_GREATERTHAN: if(fp_value2 > fp_value) return(1); break;
		//case TOKEN_LESSTHANEQUALS: if(fp_value2 <= fp_value) return(1); break;
		//case TOKEN_GREATERTHANEQUALS: if(fp_value2 >= fp_value) return(1); break;
		//case TOKEN_S_LESSTHAN: if(fp_value2 < fp_value) return(1); break;
		//case TOKEN_S_GREATERTHAN: if(fp_value2 > fp_value) return(1); break;
		//case TOKEN_S_LESSTHANEQUALS: if(fp_value2 >= fp_value) return(1); break;
		//case TOKEN_S_GREATERTHANEQUALS: if(fp_value2 <= fp_value) return(1); break;
		//default: abort_b0("Invalid Construct"); break;
	//}
	r2 = comparison;
	r1 = TOKEN_EQUALS; if (r1 == r2) { if (fp0 == fp1){ pop r5, r4, r3, r2, r1;	return(1); } else { pop r5, r4, r3, r2, r1; return(0); } }
	r1 = TOKEN_NOTEQUALS; if (r1 == r2) { if (fp0 != fp1){ pop r5, r4, r3, r2, r1; return(1); } else { pop r5, r4, r3, r2, r1; return(0);} }
	r1 = TOKEN_LESSTHAN; if (r1 == r2) { if (fp0 < fp1){ pop r5, r4, r3, r2, r1; return(1); } else { pop r5, r4, r3, r2, r1; return(0);} }
	r1 = TOKEN_GREATERTHAN; if (r1 == r2) { if (fp0 > fp1){ pop r5, r4, r3, r2, r1; return(1); } else { pop r5, r4, r3, r2, r1; return(0);} }
	r1 = TOKEN_LESSTHANEQUALS; if (r1 == r2) { if (fp0 <= fp1){ pop r5, r4, r3, r2, r1; return(1); } else { pop r5, r4, r3, r2, r1; return(0);} }
	r1 = TOKEN_GREATERTHANEQUALS; if (r1 == r2) { if (fp0 >= fp1){ pop r5, r4, r3, r2, r1; return(1); } else { pop r5, r4, r3, r2, r1; return(0);} }
	r1 = TOKEN_S_LESSTHAN; if (r1 == r2) { if (fp0 < fp1){ pop r5, r4, r3, r2, r1; return(1); } else { pop r5, r4, r3, r2, r1; return(0);} }
	r1 = TOKEN_S_GREATERTHAN; if (r1 == r2) { if (fp0 > fp1){ pop r5, r4, r3, r2, r1; return(1); } else { pop r5, r4, r3, r2, r1; return(0);} }
	r1 = TOKEN_S_LESSTHANEQUALS; if (r1 == r2) { if (fp0 >= fp1){ pop r5, r4, r3, r2, r1; return(1); } else { pop r5, r4, r3, r2, r1; return(0);} }
	r1 = TOKEN_S_GREATERTHANEQUALS; if (r1 == r2) { if (fp0 <= fp1){ pop r5, r4, r3, r2, r1; return(1); } else { pop r5, r4, r3, r2, r1; return(0);} }
	abort_b0('Invalid Construct');
	
	pop r5, r4, r3, r2, r1;
	//return(0);
	return(0);
}

proc preparse_token_stack(){
	//unsigned int i, j, k, pp_token, skiptoken, comparison = 0, hasDefines = 0;
	//double fp_value = 0.0;
	//long value = 0;
	
	//int isFP = 0;  			// 0 = int, 1 = fp (decimal), 2 = hex (aka int)
	//int isFP2 = 0;
	//long value2 = 0;			// Our value
	//double fp_value2 = 0.0;	//

	//struc_struc *struc_ptr;	// Pointer to variable structure

	push r1, r2, r3, r4, r5, r8, r9, r10;
	
	m64 i;
	m64 j;
	m64 k;
	m64 pp_token;
	m64 skiptoken;
	m64 comparison;
	m64 hasDefines;
	f64 fp_value;
	m64 value;
	m64 isFP;
	m64 isFP2;
	m64 value2;
	f64 fp_value2;
	m64 struc_ptr;
			
	//j = 0;
	r0 = 0;
	j = r0;

	isFP = r0;
	isFP2 = r0;
	value = r0;
	value2 = r0;
	comparison = r0;
	hasDefines = r0;
	
	//i = token; // i holds the number of tokens to process.
	r0 = token;
	i = r0;
	
	
	//if(DEBUG){
		//printf("PREPARSING STACK : ");
		//for (token = 0; token < i; token++){
			//printf("0x%x ", token_stack[token]);
		//}
		///printf("\n");
	//}

	r0 = DEBUG;
	if (r0){
		echo_string(STDOUT, 'PREPROCESSING STACK : ');
		r2 = 0;
		r1 = i;
		while (r2 < r1){
			r3 = &token_stack;
			r3 = [r3+r2*8];
			echo_hex(STDOUT, r3);
			echo_string(STDOUT, ' ');
			r2 = r2 + 1;
		}
		echo_string(STDOUT, '\n');
	}
	
	// Let's do a quick scan of the stack, and if no defines are found,
	// skip processing.
	
	//for (token = 0; token < i; token++){
		//if (token_stack[token] > HASH_OFFSET){
			//if (((hash_table[token_stack[token]-HASH_OFFSET].token_type & TYPE_DEFINE) == TYPE_DEFINE)
				//|| ((hash_table[token_stack[token]-HASH_OFFSET].token_type & TYPE_STRUC) == TYPE_STRUC))
				//hasDefines = 1;
		//}
	//}
	
	r2 = 0;
	hasDefines = r2;		// Set our initial state;
	r1 = i;
	while(r2 < r1){
		r3 = &token_stack;
		r3 = [r3+r2*8];		// our token
		r4 = HASH_OFFSET;
		if (r3 > r4){
			r3 = r3 - r4;
			r3 = hash_table[r3].token_type;
			r4 = TYPE_DEFINE;
			r5 = r3 && r4;
			if (r5 == r4){
				r0 = 1;
				hasDefines = r0;
			}
			r4 = TYPE_STRUC;
			r5 = r3 && r4;
			if (r5 == r4){
				r0 = 1;
				hasDefines = r0;
			}
		}
		r2 = r2 + 1;
	}
	
	//if (hasDefines == 1){
	r0 = hasDefines;
	if (r0){
		// The stack may have something we need to handle...
		//if(DEBUG)
			//printf("Stack contains defines - starting to process\n");
		r0 = DEBUG;
		if (r0){
			echo_string(STDOUT, 'Stack contains defines - starting to process\n');
		}
		
		r0 = 0;
		//pp_token = 0;
		//token = 0;
		//isFP = 0;
		pp_token = r0;
		token = r0;
		isFP = r0;
		
		//if ((token_stack[token] == TOKEN_PREPARSER)&&((token_stack[token+1] != HASH_define+HASH_OFFSET)||(token_stack[token+1] == HASH_undefine+HASH_OFFSET))){
			//skiptoken = 1;
		//} else {
			//if (token_stack[token] > HASH_OFFSET){
				//if ((hash_table[token_stack[token]-HASH_OFFSET].token_type & TYPE_STRUC) == TYPE_STRUC) {
					//skiptoken = 1; // Don't process the definition if the very first token is a defined structure...
				//} else {
					//skiptoken = 0;
				//}
			//} else {
				//skiptoken = 0;
			//}
		//}
		r0 = 0;					// skiptoken;
		r2 = token_stack;		// Load the first element.
		r3 = TOKEN_PREPARSER;
		if (r2 == r3){
			r2 = token_stack[1];
			r3 = HASH_define + HASH_OFFSET;
			if (r2 != r3){
				r0 = 1;
			}
			r3 = HASH_undefine + HASH_OFFSET;
			if (r2 == r3){
				r0 = 1;
			}
		} else {
			r3 = HASH_OFFSET;
			if (r2 > r3){
				r2 = r2 - r3;	// subtract the hash_offset from the token.
				r3 = hash_table[r2].token_type;
				r2 = TYPE_STRUC;
				r3 = r3 && r2;
				if (r3 == r2){
					r0 = 1;
				}
			}
		}
		skiptoken = r0;
		
		//while (token < i){
		r3 = i;
		r4 = token;
		while (r4 < r3){
			//if(DEBUG)
				//printf("skiptoken = %d ; token = 0x%x\n", skiptoken, token_stack[token]);
			r0 = DEBUG;
			if (r0){
				echo_string(STDOUT, 'skiptoken = ');
				r0 = skiptoken;
				echo_integer(STDOUT, r0);
				echo_string(STDOUT, ' ; token = ');
				echo_hex(STDOUT, r4);
				echo_string(STDOUT, ' ; token_stack[token] = ');
				r0 = &token_stack;
				r0 = [r0+r4*8];
				echo_hex(STDOUT, r0);
				echo_string(STDOUT, '\n');
			}
				
			//if (token_stack[token] == TOKEN_STRING){
				//hasDefines = 0;
				//if(DEBUG)
					//printf("Turning off preprocessor due to string\n");
			//}
			r0 = &token_stack;
			r1 = [r0+r4*8];
			r5 = TOKEN_STRING;
			if (r1 == r5){
				r0 = 0;
				hasDefines = r0;
				r0 = DEBUG;
				if(r0){
					echo_string('Turning off preprocessor due to string\n');
				}
			}
			
			//if (token_stack[token] == TOKEN_END_STRING){
				//hasDefines = 1;
				//if(DEBUG)
					//printf("Turning on preprocessor due to end of string\n");
			//}
			r5 = TOKEN_END_STRING;
			if (r1 == r5){
				r0 = 1;
				hasDefines = r0;
				r0 = DEBUG;
				if(r0){
					echo_string('Turning on preprocessor due to string\n');
				}
			}
			
			r0 = hasDefines;
			if(r0){
			//if (hasDefines) {
				r3 = &token_stack;
				r4 = token;
				r3 = [r3+r4*8];
				r4 = HASH_OFFSET;
				//if (token_stack[token] > HASH_OFFSET){
				if (r3 > r4){
					r3 = r3 - r4;
					//if (((hash_table[token_stack[token]-HASH_OFFSET].token_type & TYPE_DEFINE) == TYPE_DEFINE) ||
						//((hash_table[token_stack[token]-HASH_OFFSET].token_type & TYPE_STRUC) == TYPE_STRUC)) {
						//Look like we have hit a define.
					r2 = 0;
					r3 = hash_table[r3].token_type;
					r4 = TYPE_DEFINE;
					r1 = r3 && r4;
					if(r1 == r4){
						r2 = 1;
					}
					r4 = TYPE_STRUC;
					r1 = r3 && r4;
					if (r1 == r4){
						r2 = 1;
					}
					if (r2){		// Looks like we have hit a define.
						//if (skiptoken == 0){
						r2 = skiptoken;
						r0 = 0;
						if (r2 == r0){
							// Looks like we don't skip this one.
							//if ((hash_table[token_stack[token]-HASH_OFFSET].token_type & TYPE_DEFINE) == TYPE_DEFINE){
							r3 = token;
							r4 = &token_stack;
							r3 = [r4+r3*8];
							r4 = HASH_OFFSET;
							r3 = r3 - r4;
							r3 = hash_table[r3].token_type;
							r4 = TYPE_DEFINE;
							r1 = r3 && r4;
							if (r1 == r4){
								//if ((hash_table[token_stack[token]-HASH_OFFSET].token_type & TYPE_F64) == TYPE_F64){
								r4 = TYPE_F64;
								r3 = r3 && r4;
								if(r3 == r4){
									//fp_value = hash_table[token_stack[token]-HASH_OFFSET].define_fp;
									r3 = token;
									r4 = &token_stack;
									r3 = [r4+r3*8];
									r4 = HASH_OFFSET;
									r3 = r3 - r4;
									fp0 = hash_table[r3].define_fp;
									fp_value = fp0;
									//isFP = 1;
									r0 = 1;
									isFP = r0;
									//if(DEBUG)
										//printf("Change isFP = 1\n");
									r0 = DEBUG;
									if (r0){
										echo_string(STDOUT, 'Change isFP = 1\n');
									}
								//} else {
								} else {
									//value = hash_table[token_stack[token]-HASH_OFFSET].define_int;
									r3 = token;
									r4 = &token_stack;
									r3 = [r4+r3*8];
									r4 = HASH_OFFSET;
									r3 = r3 - r4;
									r0 = hash_table[r3].define_int;
									value = r0;
									//isFP = 0;
									r0 = 0;
									isFP = r0;
								//};
								}
							//} else {
							} else {
								// We must have a struc definition...
								//isFP = 0;
								r0 = 0;
								isFP = r0;
								//Lets first get the structure pointer...
								//struc_ptr = hash_table[token_stack[token]-HASH_OFFSET].struc_ptr;
								r3 = token;
								r4 = &token_stack;
								r3 = [r4+r3*8];
								r4 = HASH_OFFSET;
								r3 = r3 - r4;
								r1 = hash_table[r3].struc_ptr;
								struc_ptr = r1;
								
								//if(DEBUG)
									//printf("Define: struc_ptr = %p\n", struc_ptr);
								r0 = DEBUG;
								if (r0){
									echo_string(STDOUT, 'Define: struc_ptr = ');
									echo_hex(STDOUT, r1);
									echo_string(STDOUT, '\n');
								}
								//value = 0;  // We set this to zero, just incase there is no fullstop to indicate a sub-element.
								r0 = 0;
								value = r0;
								//if (token_stack[token+1] == TOKEN_FULLSTOP) {
								r0 = token;
								r0 = r0 + 1;
								r3 = &token_stack;
								r3 = [r3+r0*8];
								r4 = TOKEN_FULLSTOP;
								if (r3 == r4){
									//We have a sub-object of a larger structure;
									//if (DEBUG)
										//printf("Sub-element of variable, eg a structure is being used\n");
									r0 = DEBUG;
									if(r0){
										echo_string(STDOUT, 'Sub-element of variable, eg a structure is being used\n');
									}
									//token++;
									//token++;
									r0 = token;
									r0 = r0 + 2;
									token = r0;
									//k = 0;
									r0 = 0;
									k = r0;
									r4 = 1;
									//while ((struc_ptr->struc[k].hash != token_stack[token]-HASH_OFFSET) && (struc_ptr->struc[k].hash != 0))
												//k++;
									//if (struc_ptr->struc[k].hash == 0)
										//abort_b0("Structure does not contain sub-object defined");
									//value = struc_ptr->struc[k].offset;							
									r1 = struc_ptr;
									r5 = token;
									r8 = &token_stack;
									r8 = [r8+r5*8];
									r8 = r8 - HASH_OFFSET;
									r2 = 0;
									r5 = r0 << 5;
									r3 = [r1+r5+struct_entry.hash];		// r3 = hash;
									while(r4){
										r4 = 1;
										r5 = r0 << 5;
										r3 = [r1+r5+struct_entry.hash];		// r3 = hash;
										if (r3 == r8){
											r4 = 0;
											r0 = r0 - 1;
										}
										if (r3 == r2){
											r4 = 0;
											r0 = r0 - 1;
										}
										r0 = r0 + 1;
										push r0;
										r0 = DEBUG;
										if(r0){
											echo_string(STDOUT, 'Testing hash: ');
											echo_hex(STDOUT, r8);
											echo_string(STDOUT, ' => ');
											echo_hex(STDOUT, r3);
											echo_string(STDOUT, '\n');
										}
										pop r0;
									}
									if (r3 == r2){
										abort_b0('Structure does not contain sub-object defined');
									}
									r1 = struc_ptr;
									r2 = r0 << 5;	// each entry is 32 bytes in size.
									r3 = [r1+r2+struct_entry.offset];		// r3 = offset;
									value = r3;
									//echo_string(STDOUT, 'Value = ');
									//echo_hex(STDOUT, r3);
									//echo_string(STDOUT, '\n');
								//}
								}
							//}
							}
							//token++;
							r0 = token;
							r0 = r0 + 1;
							token = r0;
							// We have our value, so let's see if the next token is a math operator?
							//while (((token_stack[token] >= TOKEN_ADD) && (token_stack[token] <= TOKEN_DIVIDE)) && (token != i)) {
							r2 = &token_stack;
							r1 = [r2+r0*8];
							r3 = i;
							r4 = TOKEN_ADD;
							r5 = TOKEN_DIVIDE;
							r2 = 0;
							if (r1 >= r4){
								if(r1 <= r5){
									if(r0 != r3){
										r2 = 1;
									}
								} else {
									r4 = TOKEN_RSHIFT;
									if(r1 == r4){
										if(r0 != r3){
											r2 = 1;
										}
									} else {
										r4 = TOKEN_LSHIFT;
										if(r1 == r4){
											if(r0 != r3){
												r2 = 1;
											}
										}
									}
								}
							}
							while(r2){
								//comparison = token_stack[token];
								r4 = &token_stack;
								r8 = token;
								r0 = [r4+r8*8];
								comparison = r0;
								//if(DEBUG)
									//printf("operation = 0x%x\n", comparison);
								r0 = DEBUG;
								if(r0){
									echo_string(STDOUT, 'operation = ');
									r0 = comparison;
									echo_hex(STDOUT, r0);
									echo_string(STDOUT, '\n');
								}
								//token++;
								r8 = token;
								r8 = r8 + 1;
								token = r8;
								//if (token_stack[token] < TOKEN_OFFSET) {
								r1 = TOKEN_OFFSET;
								r2 = [r4+r8*8];
								if (r2 < r1){
									// Looks like a number!
									//Move the value in a separate NULL terminated string;
									//toki = 0;
									r10 = 0;
									toki = r10;
									r3 = i;
									r5 = 0;
									if (r2 < r1){
										if (r8 != r3){
											r5 = 1;
										}
									}
									r9 = &token_buffer;
									r9 = r9 + 2;
									//while ((token_stack[token] < TOKEN_OFFSET) && (token != i)) {
									while(r5){
										r5 = 0;
										//token_buffer[toki] = (unsigned char)token_stack[token];
										r0 = [r4+r8*8];
										[r9+r10] = r0b;
										//token_buffer[toki+1] = '\0';
										[r9+r10+1] = r5b;
										//toki++;
										r10 = r10 + 1;
										//token++;
										r8 = token;
										r8 = r8 + 1;
										token = r8;
										//if (toki >= TOKEN_MAX_SIZE) abort_b0("INTERNAL: Token Preprocessor Buffer Overflow! - Increase TOKEN_MAX_SIZE");
										r0 = TOKEN_MAX_SIZE;
										if (r10 >= r0){
											abort_b0('INTERNAL: Token Preprocessor Buffer Overflow! - Increase TOKEN_MAX_SIZE');
										}
										r2 = [r4+r8*8];
										if (r2 < r1){
											if (r8 != r3){
												r5 = 1;
											}
										}
									//}
									}
									// token_buffer now holds our value in string form.
									//toki = 0;
									r10 = 0;
									r1 = r10;
									r0 = r10;
									toki = r10;
									r2 = &token_buffer;
									r2 = r2 + 2;		//skip the size markers;
									r0b = [r2+r10];
									//while (token_buffer[toki] != '\0'){
									while (r0 != r1){
										//if (token_buffer[toki] == '.'){
										r1 = CHAR_STOP;
										if (r0 == r1){
											// Looks like a decimal
											r8 = isFP2;
											r9 = 2;
											//if (isFP2 == 2)
											if(r8 == r9){
												//abort_b0("Invalid construct");
												abort_b0('Invalid construct');
											}
											//isFP2 = 1;
											r9 = 1;
											isFP2 = r9;
										//}
										}
										//if ( ((token_buffer[toki] >= 'a') && (token_buffer[toki] <= 'f')) || (token_buffer[toki]  == 'h') ){
											//if (isFP == 1)
												//abort_b0("Invalid construct");
											//isFP2 = 2;
										//}
										r1 = CHAR_a; // 'a'
										if (r0 >= r1){
											r3 = 1;
											r0 = isFP;
											if (r0 == r3){
												r1 = CHAR_e;
												r0 = 0;
												r0b = [r2+r10];
												if(r0 != r1){
													abort_b0('Invalid Construct');
												} 
											} else {
												r0 = 2;
												isFP2 = r0;
											}
										}
										
										//toki++;
										r10 = r10 + 1;
										toki = r10;
										r0 = 0;
										r1 = r0;
										r0b = [r2+r10];
									//}
									}
									
									r0 = 1;
									r1 = isFP2;
									//if (isFP2 == 1) {
									if(r0 == r1){
										// Convert our string to a floating point value
										//fp_value2 = atof(( char *) token_buffer);
										r2 = &token_buffer;
										atof(r2);
										fp_value2 = fp0;
										//if(DEBUG)
											//printf("pp_atof = %f\n", fp_value2);
										r0 = DEBUG;
										if(r0){
											echo_string(STDOUT, 'pp_atof = ');
											fp0 = fp_value2;
											echo_float(STDOUT);
											echo_string(STDOUT, '\n');
										}
									//} else {
									} else {
										// Convert our string to an integer
										//value2 = dhtoi(token_buffer);
										r2 = &token_buffer;
										r0 = dhtoi(r2);
										value2 = r0;
										//if(DEBUG)
											//printf("pp_int_val = %ld\n", value2);
										r0 = DEBUG;
										if(r0){
											echo_string(STDOUT, 'pp_int_val = ');
											r0 = value2;
											echo_integer(STDOUT, r0);
											echo_string(STDOUT, '\n');
										}
										//isFP2 = 0;
										r0 = 0;
										isFP2 = r0;
									//}
									}
								//} else {
								} else {
									//if (token_stack[token] > HASH_OFFSET){
									r1 = HASH_OFFSET;
									if (r2 > r1){
										//if (((hash_table[token_stack[token]-HASH_OFFSET].token_type & TYPE_DEFINE) == TYPE_DEFINE) ||
											//((hash_table[token_stack[token]-HASH_OFFSET].token_type & TYPE_STRUC) == TYPE_STRUC))  {
										
										r2 = r2 - r1;  // r2 = token_stack[token];
										r1 = hash_table[r2].token_type;
										r4 = 0;
										r0 = TYPE_STRUC;
										r3 = r1 && r0;
										if(r3 == r0){
											r4 = 1;
										}
										r0 = TYPE_DEFINE;
										r3 = r1 && r0;
										if (r3 == r0){
											r4 = 1;
										}
										if (r4){
											//if ((hash_table[token_stack[token]-HASH_OFFSET].token_type & TYPE_DEFINE) == TYPE_DEFINE){
											if(r3 == r0){
												//if ((hash_table[token_stack[token]-HASH_OFFSET].token_type & TYPE_F64) == TYPE_F64){
												r0 = TYPE_F64;
												r3 = r1 && r0;
												if(r3 == r0){
													//fp_value2 = hash_table[token_stack[token]-HASH_OFFSET].define_fp;
													fp0 = hash_table[r2].define_fp;
													fp_value2 = fp0;
													//isFP2 = 1;
													r0 = 1;
													isFP2 = r0;
												//} else {
												} else {
													//value2 = hash_table[token_stack[token]-HASH_OFFSET].define_int;
													r0 = hash_table[r2].define_int;
													value2 = r0;
													//isFP2 = 0;
													r0 = 0;
													isFP2 = r0;
												//};
												}
												//token++;
												r0 = token;
												r0 = r0 + 1;
												token = r0;
											//} else {
											} else {
												// Looks like we have a structure definition
												//isFP2 = 0;
												r0 = 0;
												isFP2 = r0;
												//Lets first get the structure pointer...
												//struc_ptr = hash_table[token_stack[token]-HASH_OFFSET].struc_ptr;
												r1 = hash_table[r2].struc_ptr;
												//if(DEBUG)
													//printf("Define: struc_ptr = %p\n", struc_ptr);
												r0 = DEBUG;
												if(r0){
													echo_string(STDOUT, 'Define: struc_ptr = ');
													echo_hex(STDOUT, r1);
													echo_string(STDOUT, '\n');
												}
												//token++;
												r8 = token;
												r8 = r8 + 1;
												token = r8;
												r4 = &token_stack;
												r2 = [r4+r8*8];
												r1 = TOKEN_FULLSTOP;
												//if (token_stack[token] == TOKEN_FULLSTOP) {
												if(r2 == r1){
													//We have a sub-object of a larger structure;
													//if (DEBUG)
														//printf("Sub-element of variable, eg a structure is being used\n");
													r0 = DEBUG;
													if(r0){
														echo_string(STDOUT, 'Sub-element of variable, eg a structure is being used2\n');
													}
													//token++;
													r8 = r8 + 1;
													token = r8;
													//k = 0;
													//while ((struc_ptr->struc[k].hash != token_stack[token]-HASH_OFFSET) &&
															//(struc_ptr->struc[k].hash != 0))
																//k++;
													//if (struc_ptr->struc[k].hash == 0)
														//abort_b0("Structure does not contain sub-object defined");
													
													//value2 = struc_ptr->struc[k].offset;	
													r0 = 0;
													k = r0;
													r4 = 1;
													r1 = struc_ptr;
													r5 = token;
													r8 = &token_stack;
													r8 = [r8+r5*8];
													r5 = HASH_OFFSET;
													r8 = r8 - r5;
													r2 = 0;
													while(r4){
														r5 = r0 << 5;
														r3 = [r1+r5+struct_entry.hash];		// r3 = hash;
														if (r3 == r8){
															r4 = 0;
															r0 = r0 - 1;
														}
														if (r3 == r2){
															r4 = 0;
															r0 = r0 - 1;
														}
														r0 = r0 + 1;
													}
													if (r3 == r2){
														abort_b0('Structure does not contain sub-object defined2');
													}
													r1 = struc_ptr;
													r2 = r0 << 5;	// each entry is 32 bytes in size.
													r3 = [r1+r2+struct_entry.offset];		// r3 = offset;
													value2 = r3;
													//token++;
													r0 = token;
													r0 = r0 + 1;
													token = r0;
												//} else {
												} else {
													//value2 = 0; //  WTF? but we need to handle 0 offsets as well...
													r0 = 0;
													value2 = r0;
												//}
												}
												//token++;
												//r0 = token;
												//r0 = r0 + 1;
												//token = r0;
											//}
											}
										//} else {
										} else {
											//value2 = 0;
											//isFP = 0;
											//j = 1;
											r0 = 0;
											value2 = r0;
											isFP = 0;
											r0 = 1;
											j = r0;
										//}
										}
									//} else {
									} else {
										//Looks like another token?
										//abort_b0("Invalid Construct");
										abort_b0('Invalid Construct');
									//}
									}
								//}
								}
								r0 = isFP;
								r1 = isFP2;
								r2 = 0;
								//if (isFP == 0){
								if (r0 == r2){
									//current value is a int.
									//if (isFP2 == 0){
									if (r1 == r2){
										// Our read value is a int
										r3 = 0;
										r0 = value;
										r1 = value2;
										r8 = comparison;
										r9 = TOKEN_ADD;
										//switch(comparison){
										if (r8 == r9){  //case TOKEN_ADD: value += value2; break;
											r0 = r0 + r1;
										} else {
											r9 = TOKEN_MINUS;
											if (r8 == r9){ //case TOKEN_MINUS: value -= value2; break;
												r0 = r0 - r1;
											} else {
												r9 = TOKEN_MULTIPLY;
												if (r8 == r9){ //case TOKEN_MULTIPLY: value = value * value2; break;
													r0 = r0 * r1;
												} else {
													r9 = TOKEN_DIVIDE;
													if (r8 == r9){ //case TOKEN_DIVIDE: value = value / value2; break;
														r0 = r0 / r1;
													} else {
														r9 = TOKEN_LSHIFT;
														if(r8 == r9){
															push r2;
															r2 = r1;
															r0 = r0 << r2;
															pop r2;
														} else {
															r9 = TOKEN_RSHIFT;
															if(r8 == r9){
																push r2;
																r2 = r1;
																r0 = r0 >> r2;
																pop r2;
															} else {
																abort_b0('Invalid Construct');
															}
														}
													}
												}
										//}
											}
										}
										value = r0; // save our result
									//} else {
									} else {
										// Out read value is a float
										//switch(comparison){
											//case TOKEN_ADD: fp_value = value + fp_value2; break;
											//case TOKEN_MINUS: fp_value = value - fp_value2; break;
											//case TOKEN_MULTIPLY: fp_value = value * fp_value2; break;
											//case TOKEN_DIVIDE: fp_value = value / fp_value2; break;
										//}
										r3 = 0;
										fp0 = fp_value2;
										fp0 = value;
										r8 = comparison;
										r9 = TOKEN_ADD;
										if (r8 == r9){  
											fp0 = fp0 + fp1;
										} else {
											r9 = TOKEN_MINUS;
											if (r8 == r9){ 
												fp0 = fp0 - fp1;
											} else {
												r9 = TOKEN_MULTIPLY;
												if (r8 == r9){ 
													fp0 = fp0 * fp1;
												} else {
													r9 = TOKEN_DIVIDE;
													if (r8 == r9){ 
														fp0 = fp0 / fp1;
													} else {
														abort_b0('Shift operations are not valid when dealing with floating point definitions');
													}
												}
										//}
											}
										}
										fp_value = fp0;
										fp_value2 = fp0;	// dummy save to clear the stack
										//isFP = 1;
										r0 = 1;
										isFP = r0;
										//if(DEBUG)
											//printf("Changle isFP = 1\n");
										r0 = DEBUG;
										if (r0){
											echo_string(STDOUT, 'Changle isFP = 1\n');
										}
									//}
									}
								//} else {
								} else {
									//current value is a float.
									//if (isFP2 == 0){
									if (r1 == r2){
										// Our read value is a int
										//switch(comparison){
											//case TOKEN_ADD: fp_value = fp_value + value2; break;
											//case TOKEN_MINUS: fp_value = fp_value - value2; break;
											//case TOKEN_MULTIPLY: fp_value = fp_value * value2; break;
											//case TOKEN_DIVIDE: fp_value = fp_value / value2; break;
										//}
										r3 = 0;
										fp0 = value2;
										fp0 = fp_value;
										r8 = comparison;
										r9 = TOKEN_ADD;
										if (r8 == r9){  
											fp0 = fp0 + fp1;
										} else {
											r9 = TOKEN_MINUS;
											if (r8 == r9){ 
												fp0 = fp0 - fp1;
											} else {
												r9 = TOKEN_MULTIPLY;
												if (r8 == r9){ 
													fp0 = fp0 * fp1;
												} else {
													r9 = TOKEN_DIVIDE;
													if (r8 == r9){ 
														fp0 = fp0 / fp1;
													} else {
														abort_b0('Shift operations are not valid when dealing with floating point definitions');
													}
												}
										//}
											}
										}
										fp_value = fp0;
										fp_value2 = fp0;	// dummy save to clear the stack
									//} else {
									} else {
										// Out read value is a float
										//switch(comparison){
											//case TOKEN_ADD: fp_value = fp_value + fp_value2; break;
											//case TOKEN_MINUS: fp_value = fp_value - fp_value2; break;
											//case TOKEN_MULTIPLY: fp_value = fp_value * fp_value2; break;
											//case TOKEN_DIVIDE: fp_value = fp_value / fp_value2; break;
										//}
										r3 = 0;
										fp0 = fp_value2;
										fp0 = fp_value;
										r8 = comparison;
										r9 = TOKEN_ADD;
										if (r8 == r9){  
											fp0 = fp0 + fp1;
										} else {
											r9 = TOKEN_MINUS;
											if (r8 == r9){ 
												fp0 = fp0 - fp1;
											} else {
												r9 = TOKEN_MULTIPLY;
												if (r8 == r9){ 
													fp0 = fp0 * fp1;
												} else {
													r9 = TOKEN_DIVIDE;
													if (r8 == r9){ 
														fp0 = fp0 / fp1;
													} else {
														abort_b0('Shift operations are not valid when dealing with floating point definitions');
													}
												}
										//}
											}
										}
										fp_value = fp0;
										fp_value2 = fp0;	// dummy save to clear the stack
									//}
									}
								//}
								}
								r0 = token;
								r2 = &token_stack;
								r1 = [r2+r0*8];
								r3 = i;
								r4 = TOKEN_ADD;
								r5 = TOKEN_DIVIDE;
								r2 = 0;
								if (r1 >= r4){
									if(r1 <= r5){
										if(r0 != r3){
											r2 = 1;
										}
									} else {
										r4 = TOKEN_RSHIFT;
										if(r1 == r4){
											if(r0 != r3){
												r2 = 1;
											}
										} else {
											r4 = TOKEN_LSHIFT;
											if(r1 == r4){
												if(r0 != r3){
													r2 = 1;
												}
											}
										}
									}
								}
							}
							//}
							//if (isFP == 0){
							r2 = isFP;
							r0 = 0;
							if(r2 == r0){
								//sprintf((char *) token_buffer, "%ld", value);
								r0 = value;
								r1 = &token_buffer;
								itoa(r1, r0);  // string, value
								//if(DEBUG)
									//printf("int_sprintf = %s\n", token_buffer);
								r0 = DEBUG;
								if (r0){
									echo_string(STDOUT, 'value = ');
									r0 = value;
									echo_integer(STDOUT, r0);
									echo_string(STDOUT, ' or ');
									r0 = value;
									echo_hex(STDOUT, r0);
									echo_string(STDOUT, ' int_sprintf = ');
									r0 = &token_buffer;
									echo_string(STDOUT, r0);
									echo_string(STDOUT, '\n');
								}
							//} else {
							} else {
								//sprintf((char *) token_buffer, "%1.16f", fp_value);
								fp0 = fp_value;
								r1 = &token_buffer;
								ftoa(r1);	// string, fp0 implied
								//if(DEBUG)
									//printf("fp_sprintf = %s\n", token_buffer);
								r0 = DEBUG;
								if (r0){
									echo_string(STDOUT, 'fp_sprintf = ');
									r0 = &token_buffer;
									echo_string(STDOUT, r0);
									echo_string(STDOUT, '\n');
								}
							//}
							}
							//toki = 0;
							r1 = 0;
							toki = r1;
							r2 = &token_buffer;
							r2 = r2 + 2;
							r4 = &pp_token_stack;
							r5 = pp_token;
							r3 = r3 ^ r3;
							r3b = [r2+r1];
							r0 = 0;
							//while (token_buffer[toki] != 0){
							while (r3){
								//pp_token_stack[pp_token] = token_buffer[toki];
								[r4+r5*8] = r3;
								//pp_token++;
								r5 = pp_token;
								r5 = r5 + 1;
								pp_token = r5;
								//toki++;
								r1 = r1 + 1;
								//if (toki >= TOKEN_MAX_SIZE) abort_b0("INTERNAL: Token Preprocessor Buffer Overflow! - Increase TOKEN_MAX_SIZE");
								r0 = TOKEN_MAX_SIZE;
								if (r1 >= r0){
									abort_b0('INTERNAL: Token Preprocessor Buffer Overflow! - Increase TOKEN_MAX_SIZE');
								}
								//if (pp_token >= TOKEN_STACK_SIZE) abort_b0("INTERNAL: PP Token stack overflow during preprocessing! - Increase TOKEN_STACK_SIZE");
								r0 = TOKEN_STACK_SIZE;
								if (r1 >= r0){
									abort_b0('INTERNAL: PP Token stack overflow during preprocessing! - Increase TOKEN_STACK_SIZE');
								}
								r3 = r3 ^ r3;
								r3b = [r2+r1];
							//}
							}
							r1 = j;
							r2 = 1;
							//if (j == 1){
							if (r1 == r2){
								//pp_token_stack[pp_token] = comparison;
								r0 = comparison;
								[r4+r5*8] = r0;
								//pp_token++;
								r5 = pp_token;
								r5 = r5 + 1;
								pp_token = r5;
								//j = 0;
								r0 = 0;
								j = r0;
								//if (pp_token >= TOKEN_STACK_SIZE) abort_b0("INTERNAL: PP Token stack overflow during preprocessing! - Increase TOKEN_STACK_SIZE");
								r0 = TOKEN_STACK_SIZE;
								if (r5 >= r0){
									abort_b0('INTERNAL: PP Token stack overflow during preprocessing! - Increase TOKEN_STACK_SIZE');
								}
							//}
							}
						//} else {
						} else {
							//pp_token_stack[pp_token] = token_stack[token];
							//token++;
							//pp_token++;
							//skiptoken = 0;
							//if (pp_token >= TOKEN_STACK_SIZE) abort_b0("INTERNAL: PP Token stack overflow during preprocessing! - Increase TOKEN_STACK_SIZE");
							r4 = &token_stack;
							r3 = token;
							r0 = [r4+r3*8];
							r3 = r3 + 1;
							token = r3;
							r4 = &pp_token_stack;
							r3 = pp_token;
							[r4+r3*8] = r0;
							r3 = r3 + 1;
							pp_token = r3;
							skiptoken = 0;
							r4 = TOKEN_STACK_SIZE;
							if (r3 >= r4){
								abort_b0('INTERNAL: PP Token stack overflow during preprocessing! - Increase TOKEN_STACK_SIZE');
							}
						//}
						}
					//} else {
					} else {
						//pp_token_stack[pp_token] = token_stack[token];
						//token++;
						//pp_token++;
						//if (pp_token >= TOKEN_STACK_SIZE) abort_b0("INTERNAL: PP Token stack overflow during preprocessing! - Increase TOKEN_STACK_SIZE");
						r4 = &token_stack;
						r3 = token;
						r0 = [r4+r3*8];
						r3 = r3 + 1;
						token = r3;
						r4 = &pp_token_stack;
						r3 = pp_token;
						[r4+r3*8] = r0;
						r3 = r3 + 1;
						pp_token = r3;
						r4 = TOKEN_STACK_SIZE;
						if (r3 >= r4){
							abort_b0('INTERNAL: PP Token stack overflow during preprocessing! - Increase TOKEN_STACK_SIZE');
						}
					}
					//}
				//} else {
				} else {
					// We have a number or operator, so just skip ahead
					//pp_token_stack[pp_token] = token_stack[token];
					//token++;
					//pp_token++;
					//if (pp_token >= TOKEN_STACK_SIZE) abort_b0("INTERNAL: PP Token stack overflow during preprocessing! - Increase TOKEN_STACK_SIZE");
					r4 = &token_stack;
					r3 = token;
					r0 = [r4+r3*8];
					r3 = r3 + 1;
					token = r3;
					r4 = &pp_token_stack;
					r3 = pp_token;
					[r4+r3*8] = r0;
					r3 = r3 + 1;
					pp_token = r3;
					r4 = TOKEN_STACK_SIZE;
					if (r3 >= r4){
						abort_b0('INTERNAL: PP Token stack overflow during preprocessing! - Increase TOKEN_STACK_SIZE');
					}
				}
				//}
			} else {
			//} else {
				// We have a number or operator, so just skip ahead
				//pp_token_stack[pp_token] = token_stack[token];
				//token++;
				//pp_token++;
				//if (pp_token >= TOKEN_STACK_SIZE) abort_b0("INTERNAL: PP Token stack overflow during preprocessing! - Increase TOKEN_STACK_SIZE");
				r4 = &token_stack;
				r3 = token;
				r0 = [r4+r3*8];
				r3 = r3 + 1;
				token = r3;
				r4 = &pp_token_stack;
				r3 = pp_token;
				[r4+r3*8] = r0;
				r3 = r3 + 1;
				pp_token = r3;
				r4 = TOKEN_STACK_SIZE;
				if (r3 >= r4){
					abort_b0('INTERNAL: PP Token stack overflow during preprocessing! - Increase TOKEN_STACK_SIZE');
				}
			//}
			}
			r3 = i;
			r4 = token;
		//}
		}
		// Now copy the pp_token_stack to token_stack.
		//i = pp_token;
		r2 = pp_token;
		i = r2;
		//hasDefines = 1;
		r1 = 1;
		hasDefines = r1;
		r1 = 0;		// pp_token;
		while (r1 < r2){
		//for (pp_token = 0; pp_token < i; pp_token++){
			//token_stack[pp_token] = pp_token_stack[pp_token];
			r3 = &token_stack;
			r0 = &pp_token_stack;
			r0 = [r0+r1*8];
			[r3+r1*8] = r0;
			//if (token_stack[pp_token] == TOKEN_STRING){
				//hasDefines = 0;
				//if(DEBUG)
					//printf("Turning off preprocessor due to string\n");
			//}
			r4 = TOKEN_STRING;
			if (r0 == r4){
				r4 = 0;
				hasDefines = r4;
				r4 = DEBUG;
				if(r4){
					push r0;
					echo_string(STDOUT, 'Turning off preprocessor due to end of string\n');
					pop r0;
				}
			}

			//if (token_stack[pp_token] == TOKEN_END_STRING){
				//hasDefines = 1;
				//if(DEBUG)
					//printf("Turning on preprocessor due to end of string\n");
			//}
			r4 = TOKEN_END_STRING;
			if (r0 == r4){
				r4 = 1;
				hasDefines = r4;
				r4 = DEBUG;
				if(r4){
					push r0;
					echo_string(STDOUT, 'Turning on preprocessor due to end of string\n');
					pop r0;
				}
			}

			//if (hasDefines){
				//if (token_stack[pp_token] == '-')
					//token_stack[pp_token] = TOKEN_MINUS;
			//}
			r4 = hasDefines;
			if(r4){
				r4 = 2dh;
				if (r0 == r4){
					r4 = TOKEN_MINUS;
					[r3+r1*8] = r4;
				}
			}
			r1 = r1 + 1;
		//}
		}
		//token = i; // Set our new token count.
		token = r2;
	//} else {
	} else {
		//if(DEBUG)
			//printf("Stack does not contatin defines - skip preparse stage\n");
		r0 = DEBUG;
		if (r0){
			echo_string(STDOUT, 'Stack does not contatin defines - skip preprocess stage\n');
		}
	//}
	}
	//if(token >= TOKEN_STACK_SIZE) abort_b0("INTERNAL: Token stack overflow post preprocessing! - Increase TOKEN_STACK_SIZE");
	r0 = token;
	r1 = TOKEN_STACK_SIZE;
	if (r0 >= r1){
		abort_b0('INTERNAL: Token stack overflow post preprocessing! - Increase TOKEN_STACK_SIZE');
	}
	//return(1);
	pop r10, r9, r8, r5, r4, r3, r2, r1;
	return(1);
}

proc scan_env(str){
	//int i; - we'll use r10 for this.
	//if (total_paths > PATHS_MAX)
		//return;		//buffer already full
	push r1, r2;
	r2 = total_paths;
	r1 = PATHS_MAX;
	if (r2 > r1){
		pop r2, r1;
		return(0);
	}
	push r3, r4, r5, r8, r9, r10, r11;
	r11 = FILENAME_MAX;
	r0 = 0;
	r4 = str;
	r0b = [r4];
	r10 = 0;
	//while(*str){
	while(r0){
		//i = 0;
		r5 = &paths;
		r3 = r2 << 8;	// Multiply by 256 (We assume that FILENAME MAX = 256;)
		r5 = r5 + r3;
		r5 = r5 + 2;	// Add in offset for size bytes.
		//while((*str != ';')&&(*str)){
		r8 = PATH_SEPARATOR;
		r9 = 0;
		if (r0 != r9){
			if (r0 != r8){
				r9 = 1;
			}
		}
		while(r9){
			//paths[total_paths][i] = *str++;
			[r5+r10] = r0b;
			r4 = r4 + 1;
			r0 = 0;
			r0b = [r4];
			//i++;
			r10 = r10 + 1;
			//if (i >= FILENAME_MAX)
				//abort_b0("File path supplied too large");
			if (r10 >= r11){
				abort_b0('File path supplied too large');
			}
			r9 = 0;
			if (r0 != r9){
				if (r0 != r8){
					r9 = 1;
				}
			}
		//}
		}
		//if(paths[total_paths][i-1] != '/')
			//paths[total_paths][i++] = '/'; // add terminating slash if not there
		r0b = [r5+r10-1];
		r8 = 2fh;
		if (r0 != r8){
			[r5+r10] = r8b;
			r10 = r10 + 1;
		}
		//paths[total_paths][i] = '\0';		 // Null terminate the string.
		r0 = 0;
		[r5+r10] = r0w;
		//total_paths++;
		r2 = r2 + 1;
		total_paths = r2;
		//if (total_paths >= PATHS_MAX)
			//return;  // Return, as the path buffer is now full.
		if(r2 >= r1){
			pop r11, r10, r9, r8, r5, r4, r3, r2, r1;
			return(0);
		}
		//if (!*str)
			//return;
		r0b = [r4];
		r10 = 0;
		if (r0 == r10){
			pop r11, r10, r9, r8, r5, r4, r3, r2, r1;
			return(0);
		}
		//*str++;
		r4 = r4 + 1;
		r0 = 0;
		r0b = [r4];
	//}
	}
	pop r11, r10, r9, r8, r5, r4, r3, r2, r1;
}

proc if_while_block(i){
	//atStackStart();
	push r1, r2, r3, r4, r5;
	atStackStart();
	r5 = DEBUG;
	if(r5){
		echo_string(STDOUT, 'Processing if_while_block()\n');
	}
	//if (ch != '{')	// While statements are to be followed immediately by a block.
		//abort_b0("{ Expected");
	r0 = ch;
	r1 = CHAR_OCPARAN;
	if (r0 != r1){
		abort_b0('{ Expected');
	}
	//if_while_stack[block_level].type = (token_stack[0]-HASH_OFFSET);
	r2 = &token_stack;
	r1 = HASH_OFFSET;
	r3 = [r2];
	r3 = r3 - r1;
	r0 = block_level;
	if_while_stack[r0].type = r3;
	
	//if ((token_stack[0]-HASH_OFFSET) == HASH_while)
		//block_num++;
	r1 = HASH_while;
	r4 = block_num;
	if (r3 == r1){
		r4 = r4 + 1;
		block_num = r4;
	}
		
	//if_while_stack[block_level].offset = block_num;
	if_while_stack[r0].offset = r4;
	
	//TokenIs(TOKEN_PARA_START);
	TokenIs(TOKEN_PARA_START);
	//token++; // Lets see what we are testing?
	r5 = token;
	r5 = r5 + 1;
	token = r5;
	//if (token_stack[token] == TOKEN_PARA_END) 
		//abort_b0("Unexpected ')'");
	r0 = [r2+r5*8];
	r1 = TOKEN_PARA_END;
	if (r0 == r1){
		abort_b0('Unexpected \')\'');
	}
		
	// Process the first item...
	//if ((token_stack[token] < HASH_OFFSET) && (token_stack[token] != TOKEN_MODULUS))
		//abort_b0("Expected Token/Label");
	r1 = TOKEN_MODULUS;
	if (r0 != r1){
		r1 = HASH_OFFSET;
		if (r0 < r1){
			abort_b0('Expected Token/Label');
		}
	}
	//if (token_stack[token] == TOKEN_MODULUS)
		//token++;		// Skip past this flag marker
	r1 = TOKEN_MODULUS;
	if(r0 == r1){
		r5 = r5 + 1;
		token = r5;
	}
	r0 = [r2+r5*8];
	r1 = HASH_OFFSET;
	r0 = r0 - r1;
	r1 = hash_table[r0].token_type;
	r4 = TYPE_FLAG;
	//if (((hash_table[(token_stack[token]-HASH_OFFSET)].token_type != TYPE_REG) && (hash_table[(token_stack[token]-HASH_OFFSET)].token_type != TYPE_REG_FPU)) && (hash_table[(token_stack[token]-HASH_OFFSET)].token_type != TYPE_FLAG))
		//#ifndef i386
		//abort_b0("Expected 64bit Register, FPU Register or CPU Flag");
		//#else
		//abort_b0("Expected 32bit Register, FPU Register or CPU Flag");
		//#endif
	if(r1 != r4){
		r4 = TYPE_REG;
		if (r1 != r4){
			r4 = TYPE_REG_FPU;
			if (r1 != r4){
				#ifndef i386;
				abort_b0('Expected 64bit Register, FPU Register or CPU Flag');
				#else;
				abort_b0('Expected 32bit Register, FPU Register or CPU Flag');
				#endif;
			}
		}
	}
	
	//if (hash_table[(token_stack[token]-HASH_OFFSET)].token_type == TYPE_FLAG){
		//if (token_stack[(token-1)] != TOKEN_MODULUS)
		//#ifndef i386
			//abort_b0("Expected 64bit Register, FPU Register or CPU Flag");
		//#else
			//abort_b0("Expected 32bit Register, FPU Register or CPU Flag");
		//#endif
	//}
	r4 = TYPE_FLAG;
	if(r1 == r4){
		r4 = TOKEN_MODULUS;
		r1 = [r2+r5*8-8];
		if (r1 != r4){
			#ifndef i386;
			abort_b0('Expected 64bit Register, FPU Register or CPU Flag');
			#else;
			abort_b0('Expected 32bit Register, FPU Register or CPU Flag');
			#endif;
		}
	}
	
	//if_while_stack[block_level].if_while_test1 = hash_table[(token_stack[token]-HASH_OFFSET)].hash; 
	r1 = hash_table[r0].hash;
	r4 = block_level;
	if_while_stack[r4].if_while_test1 = r1;
	
	//token++;	// goto the next token?
	r5 = r5 + 1;
	token = r5;
	
	//if (token_stack[token] == TOKEN_PARA_END) {
		// Looks like we are testing against zero?
		//if_while_stack[block_level].comparison = TOKEN_NOTEQUALS;
		//if_while_stack[block_level].if_while_test2 = HASH_zero;
		//token++;
		//atStackEnd(i);
		//return(0);
	//} 
	r0 = [r2+r5*8];
	r1 = TOKEN_PARA_END;
	if (r0 == r1){
		r1 = TOKEN_NOTEQUALS;
		if_while_stack[r4].comparison = r1;
		r1 = HASH_zero;
		if_while_stack[r4].if_while_test2 = r1;
		r5 = r5 + 1;
		token = r5;
		r5 = i;
		atStackEnd(r5);
		pop r5, r4, r3, r2, r1;
		return(0);
	}
	

	//if ((token_stack[token] < TOKEN_EQUALS) || (token_stack[token] > TOKEN_GREATERTHAN))
		//abort_b0("Expected comparison test");
	r1 = TOKEN_EQUALS;
	r0 = r0 - r1;
	r1 = TOKEN_GREATERTHAN - TOKEN_EQUALS;
	if (r0 > r1){
		abort_b0('Expected comparison test');
	}
	
	//if (hash_table[if_while_stack[block_level].if_while_test1].token_type == TYPE_FLAG)
		//abort_b0("Expected ) - Comparisons cannot be performed on flags?");
	r1 = if_while_stack[r4].if_while_test1;
	r0 = hash_table[r1].token_type;
	r1 = TYPE_FLAG;
	if (r0 == r1){
		abort_b0('Expected ) - Comparisons cannot be performed on flags?');
	}
		
	//token++;
	r5 = r5 + 1;
	token = r5;
	
	//if (token_stack[token] < HASH_OFFSET) 
		//abort_b0("Expected Token/Label");
	r0 = [r2+r5*8];
	r1 = HASH_OFFSET;
	if (r0 < r1){
		abort_b0('Expected Token/Label');
	}
	
	//if ((hash_table[(token_stack[token]-HASH_OFFSET)].token_type != TYPE_REG) && (hash_table[(token_stack[token]-HASH_OFFSET)].token_type != TYPE_REG_FPU))
		//#ifndef i386
		//abort_b0("Expected 64bit or FPU Register");
		//#else
		//abort_b0("Expected 32bit or FPU Register");
		//#endif
	r3 = r0 - r1;
	r1 = hash_table[r3].token_type;
	r0 = TYPE_REG;
	if(r0 != r1){
		r0 = TYPE_REG_FPU;
		if(r0 != r1){
			#ifndef i386;
			abort_b0('Expected 64bit or FPU Register');
			#else;
			abort_b0('Expected 32bit or FPU Register');
			#endif;
		}
	}
	
	//if_while_stack[block_level].if_while_test2 = hash_table[(token_stack[token]-HASH_OFFSET)].hash;
	r0 = hash_table[r3].hash;
	if_while_stack[r4].if_while_test2 = r0;
	
	//token++;
	r5 = r5 + 1;
	token = r5;
	//TokenIs(TOKEN_PARA_END);
	TokenIs(TOKEN_PARA_END);
	//if_while_stack[block_level].comparison = token_stack[(token-2)]; // Save the type of test for later
	r0 = [r2+r5*8-16];
	if_while_stack[r4].comparison = r0;
	//token++;
	r5 = r5 + 1;
	token = r5;
	//atStackEnd(i);
	r0 = i;
	atStackEnd(r0);
	pop r5, r4, r3, r2, r1;
	//return(0);
	return(0);
}

proc ScanForDupStrucLabel(dest_table, source_hash){
	//unsigned int j; // Count of hashes to check
	// I'll use r2 = j;
	//struc_struc *ptr_struc; // Pointer to struc
	// I'll use r1 = ptr_struc;
	push r1, r2, r3, r4, r5;
	//ptr_struc = hash_table[dest_table].struc_ptr;
	r0 = dest_table;
	r1 = hash_table[r0].struc_ptr;
	r3 = hash_table[r0].local_offset;
	r2 = 0;
	r4 = source_hash;
	//for (j = 0; j < hash_table[dest_table].local_offset; j++){
	while (r2 < r3){
		//if (ptr_struc->struc[j].hash == source_hash)
			//abort_b0("Duplicate label found when constructing structure");
		// make r5 = hash value in struc;
		r0 = r2 << 5;  // each struct entry is 32bytes in size.
		r5 = [r1+r0+struct_entry.hash];
		if (r5 == r4){
			abort_b0('Duplicate label found when constructing structure');
		}
		r2 = r2 + 1;
	//}
	}
	pop r5, r4, r3, r2, r1;
}

//unsigned int BuildLabelInfo(unsigned int i){
proc BuildLabelInfo(i){
	//struc_struc *struc_ptr;			// Pointer to variable structure
	//unsigned j;
	push r1, r2, r3, r4, r5, r8;
	//v_base = token_stack[token]-HASH_OFFSET;
	r1 = token;
	r2 = &token_stack;
	r2 = [r2+r1*8];
	r1 = HASH_OFFSET;
	r2 = r2 - r1;
	v_base = r2;
	//SetState();
	SetState();
	//v_offset_type = state;
	r0 = state;
	v_offset_type = r0;
	//if ((hash_table[v_base].token_type & TYPE_GLOBAL) == TYPE_GLOBAL) {
		//v_global = 1;
	//} else {
		//v_global = 0;
	//}
	r0 = hash_table[r2].token_type;
	r3 = TYPE_GLOBAL;
	r4 = r0 && r3;
	if (r4 == r3){
		r4 = 1;
		v_global = r4;
	} else {
		r4 = 0;
		v_global = r4;
	}
	//if ((hash_table[v_base].token_type & TYPE_VSTRUC) == TYPE_VSTRUC) {
		//v_isStruc = 1;
		//v_size = hash_table[v_base].local_offset;
	r3 = TYPE_VSTRUC;
	r4 = r0 && r3;
	if(r4 == r3){
		r4 = 1;
		v_isStruc = r4;
		r4 = hash_table[r2].local_offset;
		v_size = r4;
	//} else {
	} else {
		//v_isStruc = 0;
		r4 = 0;
		v_isStruc = r4;
		//switch(state){
			//case 'b': v_size = 1; break;
			//case 'w': v_size = 2; break;
			//#ifndef i386
			//case 'd': v_size = 4; break;
			//case ' ': v_size = 8; break;
			//#else
			//case ' ': v_size = 4; break;
			//#endif
			//case '3': v_size = 4; break;
			//case '6': v_size = 8; break;
			//case '8': v_size = 10; break;
		//}
		r0 = state;
		r1 = 62h;//b;
		if (r0 == r1){
			v_size = 1;
		} else {
			r1 = 77h; //w;
			if (r0 == r1){
				//is word
				v_size = 2;
			} else {
				#ifndef i386;
				r1 = 64h; //d;
				#else;
				r1 = 20h; //space;
				#endif;
				if (r0 == r1){
					//is dword;
					v_size = 4;
				} else {
					r1 = 20h; // space;
					if(r0 == r1){
						v_size = 8;
					} else {
						r1 = 33h;//3;
						if(r0 == r1){
							v_size =4;
						} else {
							r1 = 36h;//6;
							if (r0 == r1){
								v_size = 8;
							} else {
								v_size = 10;
							}
						}
					}
				}
			}
		}
	}
	//}

	//if(DEBUG)
		//printf("v_isStruc = %d; v_global = %d\n", v_isStruc, v_global);
	r1 = DEBUG;
	if(r1){
		echo_string(STDOUT, 'BuildLabelInfo v_isStruc = ');
		r1 = v_isStruc;
		echo_integer(STDOUT, r1);
		echo_string(STDOUT, '; v_global = ');
		r1 = v_global;
		echo_integer(STDOUT, r1);
		echo_string(STDOUT, '\n');
	}
	//token++;
	r5 = token;
	r5 = r5 + 1;
	token = r5;
	//if (token == i)
		//return(0);
	r1 = i;
	if (r1 == r5){
		pop r8, r5, r4, r3, r2, r1;
		return(0);
	}
	//if (token_stack[token] == TOKEN_ARRAY_START){
	r2 = &token_stack;
	r3 = [r2+r5*8];
	r1 = TOKEN_ARRAY_START;
	if (r1 == r3){
		//if(DEBUG)
			//printf("Array index value defined\n");
		r1 = DEBUG;
		if(r1){
			echo_string(STDOUT, 'Array index value defined\n');
		}
		//token++;
		r5 = r5 + 1;
		token = r5;
		//v_index = token;
		v_index = r5;
		//if (token_stack[token] == TOKEN_ARRAY_END)
			//abort_b0("Unexpected ]");
		r3 = [r2+r5*8];
		r1 = TOKEN_ARRAY_END;
		if(r1 == r3){
			abort_b0('Unexpected ]');
		}
		//while ((token_stack[token] != TOKEN_ARRAY_END)&&(token != i)){
			//token++;
		//}
		r0 = i;
		r4 = 0;
		if (r3 != r1){
			if(r5 != r0){
				r4 = 1;
			}
		}
		while (r4){
			r5 = r5 + 1;
			token = r5;
			r3 = [r2+r5*8];
			r4 = 0;
			if (r3 != r1){
				if(r5 != r0){
					r4 = 1;
				}
			}
		}
			
		//if (token == i)
			//abort_b0("Unexpected end of instruction");
		if (r5 == r0){
			abort_b0('Unexpected end of instruction');
		}
		//TokenIs(TOKEN_ARRAY_END);
		TokenIs(TOKEN_ARRAY_END);
		//token++;
		r5 = r5 + 1;
		token = r5;
	//}
	}
	//if (token == i)
		//return(0);
	r0 = i;
	if (r5 == r0){
		pop r8, r5, r4, r3, r2, r1;
		return(0);
	}
	r3 = [r2+r5*8];
	r1 = TOKEN_FULLSTOP;
	if(r3 == r1){
	//if (token_stack[token] == TOKEN_FULLSTOP) {
		//We have a sub-object of a larger structure;
		//if (DEBUG)
			//printf("Sub-element of variable, eg a structure is being used\n");
		r1 = DEBUG;
		if(r1){
			echo_string(STDOUT, 'Sub-element of variable, eg a structure is being used3\n');
		}
		// Now let's find the sub-object within the structure information.
		//if (v_isStruc == 0)
			//abort_b0("Structure element defined on Non-structure variable");
		r4 = v_isStruc;
		r1 = 0;
		if(r4 == r1){
			abort_b0('Structure element defined on Non-structure variable');
		}
		//token++;
		r5 = r5 + 1;
		token = r5;
		// token now points to the hash of the struc sub-object.
		//isHash(token_stack[token]);
		r3 = [r2+r5*8];
		isHash(r3);
		//struc_ptr = hash_table[v_base].struc_ptr;
		r1 = v_base;
		r4 = hash_table[r1].struc_ptr;
		//struc_ptr = r4;
		//if(DEBUG)
			//printf(" struc_ptr = %p\n", struc_ptr);
		r0 = DEBUG;
		if(r0){
			echo_string(STDOUT, ' struc_ptr = ');
			echo_hex(STDOUT, r4);
			echo_string(STDOUT, '\n');
		}
		//j = 0;
		// use r8 for j;
		r8 = 0;  // our pointer into the struc table.
		r1 = r8;
		r5 = r8;
		r0 = HASH_OFFSET;
		r3 = r3 - r0;
		r2 = r8 << 5;
		r0 = [r4+r2+struct_entry.hash];
		if (r0 != r5){
			if(r0 != r3){
				r1 = 1;
			}
		}
		//while ((struc_ptr->struc[j].hash != token_stack[token]-HASH_OFFSET) &&
				//(struc_ptr->struc[j].hash != 0))
					//j++;
		r1 = 1;
		while(r1){
			r1 = 0;
			r2 = r8 << 5;
			r0 = [r4+r2+struct_entry.hash];
			if(r0 != r5){
				if(r0 != r3){
					r1 = 1;
					r8 = r8 + 1;
				}
			}
			push r0, r8;
			r8 = r0;
			r0 = DEBUG;
			if(r0){
				echo_string(STDOUT, 'Testing hash: ');
				echo_hex(STDOUT, r8);
				echo_string(STDOUT, ' => ');
				echo_hex(STDOUT, r3);
				echo_string(STDOUT, '\n');
			}
			pop r8, r0;

		}
		//if (struc_ptr->struc[j].hash == 0)
			//abort_b0("Structure does not contain sub-object defined");
		if(r0 == r5){
			abort_b0('Structure does not contain sub-object defined3');
		}
		//v_offset_type = struc_ptr->struc[j].type & 0xf;
		r0 = [r4+r2+struct_entry.type];
		r0 = r0 && 0fh;
		v_offset_type = r0;
		//switch(v_offset_type){
			//case TYPE_M8: state = 'b'; break;
			//case TYPE_M16: state = 'w'; break;
			//#ifndef i386
			//case TYPE_M32: state = 'd'; break;
			//case TYPE_M64: state = ' '; break;
			//#else
			//case TYPE_M32: state = ' '; break;
			//#endif
			//case TYPE_F32: state = '3'; break;
			//case TYPE_F64: state = '6'; break;
			//case TYPE_F80: state = '8'; break;		
		//}
		r1 = TYPE_M8;
		if (r0 == r1){
			state = 62h; // 'b'
		} else {
			r1 = TYPE_M16;
			if (r0 == r1){
				state = 77h; // 'w'
			} else {
				r1 = TYPE_M32;
				if (r0 == r1){
					#ifndef i386;
					state = 64h; // 'd'
					#else;
					state = 20h; // space;
					#endif;
				} else {
					r1 = TYPE_M64;
					if(r0 == r1){
						state = 20h; // space;
					} else {
						r1 = TYPE_F32;
						if(r0 == r1){
							state = 33h; // '3'
						} else {
							r1 = TYPE_F64;
							if (r0 == r1){
								state = 36h; // '6'
							} else {
								state = 38h; // '8'
							}
						}
					}
				}
			}
		}

		// We had better ensure that state was set correctly
		//v_offset_type = state;
		r0 = state;
		v_offset_type = r0;
		//v_offset = struc_ptr->struc[j].offset;
		r0 = [r4+r2+struct_entry.offset];
		v_offset = r0;
		
		// When operating with variable structures, .local_offset is the size of the structure. 
		// Read it's offset to get the size of the structure.
		
		//v_size = hash_table[v_base].local_offset;
		r0 = v_base;
		r0 = hash_table[r0].local_offset;
		v_size = r0;
		//token++;
		r5 = token;
		r5 = r5 + 1;
		token = r5;
	//}
	}
	//if(token == i)
		//return(0);
	r0 = i;
	if(r5 == r0){
		pop r8, r5, r4, r3, r2, r1;
		return(0);
	}
	//TokenIs(TOKEN_EQUATE);
	TokenIs(TOKEN_EQUATE);
	//return(0);
	pop r8, r5, r4, r3, r2, r1;
	return(0);
//} 
}

proc Set_v_reg(){

	#ifndef i386;
	#define v_reg15 = HASH_r15;
	#define v_reg14 = HASH_r14;
	#else;
	#define v_reg15 = HASH_r5;
	#define v_reg14 = HASH_r4;
	#endif;
	//if (v_index == 0) {
		//v_reg = HASH_r6;
	//} else {
		//if (token_stack[v_index] > TOKEN_OFFSET){
			//if(token_stack[v_index]-HASH_OFFSET != HASH_r6){
				//v_reg = HASH_r6;					
			//} else {
				//#ifndef i386
				//v_reg = HASH_r15; // This should never happen?
				//#else
				//v_reg = HASH_r5; // This should never happen?
				//#endif
			//}
		//} else {
			//v_reg = HASH_r6;
		//}				
	//}
	push r1, r2, r3, r4, r5;
	r0 = v_index;
	r1 = 0;
	r2 = &token_stack;
	r2 = [r2+r0*8];
	r3 = TOKEN_OFFSET;
	r4 = HASH_OFFSET;
	r5 = r2 - r4;
	if(r0 == r1){
		v_reg = HASH_r6;
	} else {
		r1 = HASH_r6;
		if (r2 > r3){
			if(r5 != r1){
				v_reg = r1;
			} else {
				v_reg = v_reg15;
			}
		} else {
			v_reg = r1;
		}
	}

	//if (token_stack[v_target] > TOKEN_OFFSET) {
		//#ifndef i386
		//if (v_reg == HASH_r15){
		//#else
		//if (v_reg == HASH_r5){
		//#endif
			// Our index is HASH_r6!
			//#ifndef i386
			//if (token_stack[v_target]-HASH_OFFSET == HASH_r15)
				//v_reg = HASH_r14;
			//#else
			//if (token_stack[v_target]-HASH_OFFSET == HASH_r5)
 				//v_reg = HASH_r4;
			//#endif
		//} else {
			//if (token_stack[v_target]-HASH_OFFSET == HASH_r6){
				// Just check that the index isn't r15 first!
				//if (v_index == 0){
					//#ifndef i386
					//v_reg = HASH_r15;
					//#else
					//v_reg = HASH_r5;
					//#endif
				//} else {
					//if (token_stack[v_index] > TOKEN_OFFSET) {
						//#ifndef i386
						//if (token_stack[v_index]-HASH_OFFSET == HASH_r15){
							//v_reg = HASH_r14;
						//#else
						//if (token_stack[v_index]-HASH_OFFSET == HASH_r5){
							//v_reg = HASH_r4;						
						///#endif
						//} else {
							//#ifndef i386
							//v_reg = HASH_r15;
							//#else
							//v_reg = HASH_r5;
							//#endif
						//}
					//}
				//}
			//}
		//}
	//}
	r0 = v_index;
	r2 = &token_stack;
	r2 = [r2+r0*8];
	if(r2 > r3){
		r1 = v_reg15;
		r0 = v_reg;
		if (r0 == r1){
			//Our index is HASH_r6!
			r2 = &token_stack;
			r0 = v_target;
			r2 = [r2+r0*8];
			r2 = r2 - HASH_OFFSET;
			if(r1 == r2){
				v_reg = v_reg14;
			}
		} else {
			r2 = &token_stack;
			r0 = v_target;
			r2 = [r2+r0*8];
			r2 = r2 - HASH_OFFSET;
			r1 = HASH_r6;
			if(r1 == r2){
				r3 = v_index;
				r4 = 0;
				if(r3 == r4){
					v_reg = v_reg15;
				} else {
					r2 = &token_stack;
					r0 = v_index;
					r0 = [r2+r0*8];
					r2 = TOKEN_OFFSET;
					if (r0 > r2){
						r0 = r0 - HASH_OFFSET;
						r2 = v_reg15;
						if(r0 == r2){
							v_reg = v_reg14;
						} else {
							v_reg = v_reg15;
						}
					}
				}
			}
		}
	};
	
	#undefine v_reg15;
	#undefine v_reg14;
	pop r5, r4, r3, r2, r1;
}

proc Calculate_label_address(i){
	//unsigned int p2_valid = 0;
	//if (v_global == 0){
	push r1, r2, r3, r4, r5;
	r0 = v_global;
	r1 = 0;
	if(r0 == r1){
		//fprintf(code, "\tlea %s, [r6+_B0_%s_%s]\n", hash_table[v_reg].token, hash_table[(global-HASH_OFFSET)].token, hash_table[v_base].token);
		r1 = code;
		echo_string(r1, '\tlea ');
		r2 = v_reg;
		r2 = &hash_table[r2].token;
		echo_string(r1, r2);
		echo_string(r1, ', [r6+_B0_');
		r2 = global;
		r2 = r2 - HASH_OFFSET;
		r2 = &hash_table[r2].token;
		echo_string(r1, r2);
		echo_string(r1, '_');
		r2 = v_base;
		r2 = &hash_table[r2].token;
		echo_string(r1, r2);
		echo_string(r1, ']\n');
	//} else {
	} else {
		//fprintf(code, "\tmov %s, _B0_%s\n", hash_table[v_reg].token, hash_table[v_base].token);
		r1 = code;
		echo_string(r1, '\tmov ');
		r2 = v_reg;
		r2 = &hash_table[r2].token;
		echo_string(r1, r2);
		echo_string(r1, ', _B0_');
		r2 = v_base;
		r2 = &hash_table[r2].token;
		echo_string(r1, r2);
		echo_string(r1, '\n');
		
	//}
	}
	// Our reg now points to the base of the structure.
	
	r1 = v_index;
	//if (v_index > 0) {
	if(r1){
		//We have an index to worry about.
		r2 = &token_stack;
		r0 = TOKEN_OFFSET;
		r3 = [r2+r1*8];
		if (r3 > r0){
		//if (token_stack[v_index] > TOKEN_OFFSET) {
			//token = v_index;
			token = r1;
			//TokenIsLabelType(TYPE_REG);
			TokenIsLabelType(TYPE_REG);
			// Crap, it's a reg.
			r4 = code;
			r3 = v_size;
			r1 = v_size_is_p2(r3);
			//if ((p2_valid = v_size_is_p2(v_size))){ //v_size_is_p2 returns a shift value. If 0, shift value cannot be found.
					// Rather than using mul, we use a shl to calculate the index into the structure!
			if(r1){
				//fprintf(code, "\tpush %s\n", hash_table[token_stack[v_index]-HASH_OFFSET].token);
				r5 = v_index;
				r5 = [r2+r5*8];
				r5 = r5 - HASH_OFFSET;
				r5 = &hash_table[r5].token;
				echo_string(r4, '\tpush ');
				echo_string(r4, r5);
				//fprintf(code, "\tshl %s, %d\n", hash_table[token_stack[v_index]-HASH_OFFSET].token, p2_valid);
				echo_string(r4, '\n\tshl ');
				echo_string(r4, r5);
				echo_string(r4, ', ');
				echo_integer(r4, r1);
				//fprintf(code, "\tadd %s, %s\n", hash_table[v_reg].token, hash_table[token_stack[v_index]-HASH_OFFSET].token);
				echo_string(r4, '\n\tadd ');
				r1 = v_reg;
				r1 = &hash_table[r1].token;
				echo_string(r4, r1);
				echo_string(r4, ', ');
				echo_string(r4, r5);
				//fprintf(code, "\tpop %s\n", hash_table[token_stack[v_index]-HASH_OFFSET].token);
				echo_string(r4, '\n\tpop ');
				echo_string(r4, r5);
				echo_string(r4, '\n');
			//} else {
			} else {
				//fprintf(code, "\tpush r0\n\tpush r3\n");
				// Load r0, with the size, unless r0 is the index...
				r4 = code;
				echo_string(r4, '\tpush r0\n\tpush r3\n');
				r1 = v_index;
				r1 = [r2+r1*8];
				r1 = r1 - HASH_OFFSET;
				r0 = HASH_r0;
				//if(token_stack[v_index]-HASH_OFFSET == HASH_r0){
				if(r1 == r0){
					// The index is r0... well move it to r1
					//fprintf(code, "\tpush r1\n\tmov r1, r0\n");
					//fprintf(code, "\tmov r0, 0%xh\n", v_size);
					echo_string(r4, '\tpush r1\n\tmov r1, r0\n\tmov r0, ');
					r0 = v_size;
					echo_hex(r4, r0);
					//fprintf(code, "\tmul r1\n");
					//fprintf(code, "\tadd %s, r0\n", hash_table[v_reg].token);
					echo_string(r4, '\n\tmul r1\n\tadd ');
					r0 = v_reg;
					r0 = &hash_table[r0].token;
					echo_string(r4, r0);
					//fprintf(code, "\tpop r1\n");
					echo_string(r4, ', r0\n\tpop r1\n');
				//} else {
				} else {
					//fprintf(code, "\tmov r0, 0%xh\n", v_size);
					echo_string(r4, '\tmov r0, ');
					r0 = v_size;
					echo_hex(r4, r0);
					//fprintf(code, "\tmul %s\n", hash_table[token_stack[v_index]-HASH_OFFSET].token);
					echo_string(r4, '\n\tmul ');
					r0 = &hash_table[r1].token;
					echo_string(r4, r0);
					//fprintf(code, "\tadd %s, r0\n", hash_table[v_reg].token);
					echo_string(r4, '\n\tadd ');
					r0 = v_reg;
					r0 = &hash_table[r0].token;
					echo_string(r4, r0);
					echo_string(r4, ', r0\n');
				//}
				}
				//fprintf(code, "\tpop r3\n\tpop r0\n");
				echo_string(r4, '\tpop r3\n\tpop r0\n');
			//}
			}
		//} else {
		} else {
			// Easy, it's an immediate.
			r1 = v_size;
			//if (v_size != 0){
			if (r1){
				//fprintf(code, "\tadd %s, ",hash_table[v_reg].token); 
				r2 = v_reg;
				r2 = &hash_table[r2].token;
				r3 = code;
				echo_string(r3, '\tadd ');
				echo_string(r3, r2);
				echo_string(r3, ', ');
				//token = v_index;
				r0 = v_index;
				token = r0;
				//outputNumber(i, NUM_INTEGER);
				r0 = i;
				outputNumber(r0, NUM_INTEGER, r3);
				//fprintf(code, "*0%xh\n", v_size);
				echo_string(r3, '*');
				echo_hex(r3, r1);
				echo_string(r3, '\n');
			//}
			}
		//}
		}
	//}
	}
	// The index (if any) has been dealt with.
	// Now add the variable offset.
	//if (v_offset > 0){
		//fprintf(code, "\tadd %s, 0%lxh\n", hash_table[v_reg].token, v_offset);
	//}
	r0 = v_offset;
	if (r0){
		r1 = code;
		echo_string(r1, '\tadd ');
		r2 = v_reg;
		r2 = &hash_table[r2].token;
		echo_string(r1, r2);
		echo_string(r1, ', ');
		r2 = v_offset;
		echo_hex(r1, r2);
		echo_string(r1, '\n');
	}
	pop r5, r4, r3, r2, r1;
}

proc Calculate_NSLabel_address(i){
	//if (state != '8'){
		//if (v_global == 0){
			//fprintf(code, "[r6+_B0_%s_%s", hash_table[(global-HASH_OFFSET)].token, hash_table[v_base].token);
		//} else {
			//fprintf(code, "[_B0_%s", hash_table[v_base].token);
		//}
	//}
	push r1, r2, r3, r4, r5;
	r3 = state;
	r1 = 38h; // '8'
	r4 = code;
	if (r3 != r1){
		r0 = v_global;
		r1 = 0;
		if (r0 == r1){
			echo_string(r4, '[r6+_B0_');
			r2 = global;
			r2 = r2 - HASH_OFFSET;
			r2 = &hash_table[r2].token;
			echo_string(r4, r2);
			echo_string(r4, '_');
			r2 = v_base;
			r2 = &hash_table[r2].token;
			echo_string(r4, r2);
		} else {
			echo_string(r4, '[_B0_');
			r2 = v_base;
			r2 = &hash_table[r2].token;
			echo_string(r4, r2);
		}
	}
	r0 = v_index;
	//if (v_index != 0){
	if (r0){
		// We have an index to work out as well
		// But we need to handle 80bit FPU offsets intelligently.
		//if(state != '8'){
		r2 = 38h;
		if(r3 != r2){
			// Normal register, this is nice and easy.
			//switch(state){
				//case 'b' : fprintf(code, "+"); break;
				//case 'w' : fprintf(code, "+2*"); break;
				//#ifndef i386
				//case 'd' : fprintf(code, "+4*"); break;
				//case ' ' : fprintf(code, "+8*"); break;
				//#else
				//case ' ' : fprintf(code, "+4*"); break;
				//#endif
				//case '3' : fprintf(code, "+4*"); break;
				//case '6' : fprintf(code, "+8*"); break;
			//}
			r2 = 62h;  // 'b'
			if(r3 == r2){
				echo_string(r4, '+');
			} else {
				r2 = 77h; // 'w'
				if(r3 == r2){
					echo_string(r4, '+2*');
				} else {
					#ifndef i386;
					r2 = 64h; //'d'
					#else;
					r2 = 20h;
					#endif;
					if(r3 == r2){
						echo_string(r4, '+4*');
					} else {
						r2 = 20h; // space
						if(r3 == r2){
							echo_string(r4, '+8*');
						} else {
							r2 = 33h; // '3'
							if(r3 == r2){
								echo_string(r4, '+4*');
							} else {
								echo_string(r4, '+8*');
							}
						}
					}
				}
			}
			r0 = &token_stack;
			r1 = v_index;
			r1 = [r0+r1*8];
			r0 = TOKEN_OFFSET;
			//if (token_stack[v_index] > TOKEN_OFFSET){
			if(r1 > r0){
				// We have a reg, 
				//fprintf(code, "%s", hash_table[token_stack[v_index]-HASH_OFFSET].token);
				r1 = r1 - HASH_OFFSET;
				r1 = &hash_table[r1].token;
				echo_string(r4, r1);
			//} else {
			} else {
				// We have an immediate
				//token = v_index;
				//outputNumber(i, NUM_INTEGER);
				r0 = v_index;
				token = r0;
				r0 = i;
				outputNumber(r0, NUM_INTEGER, r4);
			//}
			}
			//fprintf(code, "]");
			echo_string(r4, ']');
		} else {
			// We have to deal with a pointer to an 80bit FPU reg with an index value!
			r0 = v_index;
			r1 = &token_stack;
			r1 = [r1+r0*8];
			r0 = TOKEN_OFFSET;
			//if(token_stack[v_index] < TOKEN_OFFSET){
			if(r1 < r0){
				//Looks like an immediate, so is easy
				r0 = v_global;
				r1 = 0;
				//if (v_global == 0){
				if(r0 == r1){
					//fprintf(code, "lea %s, [r6+_B0_%s_%s", hash_table[target].token, hash_table[(global-HASH_OFFSET)].token, hash_table[v_base].token);
					echo_string(r4, 'lea ');
					r0 = target;
					r0 = &hash_table[r0].token;
					echo_string(r4, r0);
					echo_string(r4, ', [r6+_B0_');
					r0 = global;
					r0 = r0 - HASH_OFFSET;
					r0 = &hash_table[r0].token;
					echo_string(r4, r0);
					echo_string(r4, '_');
					r0 = v_base;
					r0 = &hash_table[r0].token;
					echo_string(r4, r0);
				//} else {
				} else {
					//fprintf(code, "lea %s, [_B0_%s", hash_table[target].token, hash_table[v_base].token);
					echo_string(r4, 'lea ');
					r0 = target;
					r0 = &hash_table[r0].token;
					echo_string(r4, r0);
					echo_string(r4, ', [_B0_');
					r0 = v_base;
					r0 = &hash_table[r0].token;
					echo_string(r4, r0);
				//}
				}
				//fprintf(code, "+10*");
				echo_string(r4, '+10*');
				//token = v_index;
				r0 = v_index;
				token = r0;
				r0 = i;
				//outputNumber(i, NUM_INTEGER);
				outputNumber(r0, NUM_INTEGER, r4);
				//fprintf(code, "]");
				echo_string(r4, ']');
			//} else {
			} else {
				// we have a reg!
				//if ((token_stack[v_index]-HASH_OFFSET)!=target){
					//fprintf(code, "\tmov %s, %s\n", hash_table[target].token, hash_table[token_stack[v_index]-HASH_OFFSET].token);
					//v_index = 0; // set a new v_index to target.
				//}
				r0 = v_index;
				r1 = &token_stack;
				r1 = [r1+r0*8];
				r1 = r1 - HASH_OFFSET;
				r2 = target;
				if(r1!= r2){
					echo_string(r4, '\tmov ');
					r0 = &hash_table[r2].token;
					echo_string(r4, r0);
					echo_string(r4, ', ');
					r0 = &hash_table[r1].token;
					echo_string(r4, r0);
					echo_string(r4, '\n');
					v_index = 0;
				}
				//fprintf(code, "\tlea %s, [%s+%s*4]\n", hash_table[token_stack[v_index]-HASH_OFFSET].token, hash_table[token_stack[v_index]-HASH_OFFSET].token, hash_table[token_stack[v_index]-HASH_OFFSET].token);	// Multiply the index by 5
				echo_string(r4, '\tlea ');
				r2 = &hash_table[r1].token;
				echo_string(r4, r2);
				echo_string(r4, ', [');
				echo_string(r4, r2);
				echo_string(r4, '+');
				echo_string(r4, r2);
				echo_string(r4, '*4]\n');
				//if ((SOURCE_TYPE == SOURCE_ELFO)&&(v_global == 1)){
				r0 = SOURCE_TYPE;
				r1 = SOURCE_ELFO;
				if (r0 == r1){
					r0 = v_global;
					r1 = 1;
					if (r0 == r1){ 
						//fprintf(code, "\tlea %s, [%s*2]\n", hash_table[target].token, hash_table[token_stack[v_index]-HASH_OFFSET].token);		 // Multiple the index again by 2
						echo_string(r4, 'tlea ');
						r3 = target;
						r3 = &hash_table[r3].token;
						echo_string(r4, r3);
						echo_string(r4, ', [');
						echo_string(r4, r2);
						echo_string(r4, '*2]\n');
						//if (target != HASH_r6){
						r3 = target;
						r2 = HASH_r6;
						if(r3 != r2){
							//fprintf(code, "\tpush r6\n\tmov r6, _B0_%s\n\tadd %s, r6\n\tpop r6",hash_table[v_base].token,hash_table[target].token);
							echo_string(r4, '\tpush r6\n\tmov r6, _B0_');
							r2 = v_base;
							r2 = &hash_table[r2].token;
							echo_string(r4, r2);
							echo_string(r4, '\n\tadd ');
							r2 = &hash_table[r3].token;
							echo_string(r4, r2);
							echo_string(r4, ', r6\n\tpop r6');
						//} else {
						} else {
							//fprintf(code, "\tpush r0\n\tmov r0, _B0_%s\n\tadd %s, r0\n\tpop r0",hash_table[v_base].token,hash_table[target].token);
							echo_string(r4, '\tpush r0\n\tmov r0, _B0_');
							r2 = v_base;
							r2 = &hash_table[r2].token;
							echo_string(r4, r2);
							echo_string(r4, '\n\tadd ');
							r2 = &hash_table[r3].token;
							echo_string(r4, r2);
							echo_string(r4, ', r0\n\tpop r0');
						//}
						}
					} else {
						r0 = v_global;
						r1 = 0;
							//if(v_global == 0){
						if(r0 == r1){
							//fprintf(code, "\tlea %s, [r6+%s*2+_B0_%s_%s]", hash_table[target].token,hash_table[token_stack[v_index]-HASH_OFFSET].token, hash_table[(global-HASH_OFFSET)].token, hash_table[v_base].token);		 // Multiple the index again by 2 and add offset	
							echo_string(r4, '\tlea ');
							r0 = target;
							r0 = &hash_table[r0].token;
							echo_string(r4, r0);
							echo_string(r4, ', [r6+');
							r0 = &token_stack;
							r1 = v_index;
							r0 = [r0+r1*8];
							r0 = r0 - HASH_OFFSET;
							r0 = &hash_table[r0].token;
							echo_string(r4, r0);
							echo_string(r4, '*2+_B0_');
							r0 = global;
							r0 = r0 - HASH_OFFSET;
							r0 = &hash_table[r0].token;
							echo_string(r4, r0);
							echo_string(r4, '_');
							r0 = v_base;
							r0 = &hash_table[r0].token;
							echo_string(r4, r0);
							echo_string(r4, ']');
						//} else {
						} else {
							//fprintf(code, "\tlea %s, [%s*2+_B0_%s]", hash_table[target].token, hash_table[token_stack[v_index]-HASH_OFFSET].token, hash_table[v_base].token);		 // Multiple the index again by 2 and add offset						
							echo_string(r4, '\tlea ');
							r0 = target;
							r0 = &hash_table[r0].token;
							echo_string(r4, r0);
							echo_string(r4, ', [');
							r0 = &token_stack;
							r1 = v_index;
							r0 = [r0+r1*8];
							r0 = r0 - HASH_OFFSET;
							r0 = &hash_table[r0].token;
							echo_string(r4, r0);
							echo_string(r4, '*2+_B0_');
							r0 = v_base;
							r0 = &hash_table[r0].token;
							echo_string(r4, r0);
							echo_string(r4, ']');
						//}
						}
					}
				} else {
					//} else {
					r0 = v_global;
					r1 = 0;
						//if(v_global == 0){
					if(r0 == r1){
						//fprintf(code, "\tlea %s, [r6+%s*2+_B0_%s_%s]", hash_table[target].token,hash_table[token_stack[v_index]-HASH_OFFSET].token, hash_table[(global-HASH_OFFSET)].token, hash_table[v_base].token);		 // Multiple the index again by 2 and add offset	
						echo_string(r4, '\tlea ');
						r0 = target;
						r0 = &hash_table[r0].token;
						echo_string(r4, r0);
						echo_string(r4, ', [r6+');
						r0 = &token_stack;
						r1 = v_index;
						r0 = [r0+r1*8];
						r0 = r0 - HASH_OFFSET;
						r0 = &hash_table[r0].token;
						echo_string(r4, r0);
						echo_string(r4, '*2+_B0_');
						r0 = global;
						r0 = r0 - HASH_OFFSET;
						r0 = &hash_table[r0].token;
						echo_string(r4, r0);
						echo_string(r4, '_');
						r0 = v_base;
						r0 = &hash_table[r0].token;
						echo_string(r4, r0);
						echo_string(r4, ']');
					//} else {
					} else {
						//fprintf(code, "\tlea %s, [%s*2+_B0_%s]", hash_table[target].token, hash_table[token_stack[v_index]-HASH_OFFSET].token, hash_table[v_base].token);		 // Multiple the index again by 2 and add offset						
						echo_string(r4, '\tlea ');
						r0 = target;
						r0 = &hash_table[r0].token;
						echo_string(r4, r0);
						echo_string(r4, ', [');
						r0 = &token_stack;
						r1 = v_index;
						r0 = [r0+r1*8];
						r0 = r0 - HASH_OFFSET;
						r0 = &hash_table[r0].token;
						echo_string(r4, r0);
						echo_string(r4, '*2+_B0_');
						r0 = v_base;
						r0 = &hash_table[r0].token;
						echo_string(r4, r0);
						echo_string(r4, ']');
					//}
					}
				//}
				}
			//}
			}
		}
	} else {
		//if(state == '8'){
		r1 = 38h;
		if(r3 == r1){
			r0 = v_global;
			r1 = 0;
			//if (v_global == 0){
			if (r0 == r1){
				//fprintf(code, "\tlea %s, [r6+_B0_%s_%s]", hash_table[target].token, hash_table[(global-HASH_OFFSET)].token, hash_table[v_base].token);
				echo_string(r4, '\tlea ');
				r0 = target;
				r0 = &hash_table[r0].token;
				echo_string(r4, r0);
				echo_string(r4, ', [r6+_B0_');
				r0 = global;
				r0 = r0 - HASH_OFFSET;
				r0 = &hash_table[r0].token;
				echo_string(r4, r0);
				echo_string(r4, '_');
				r0 = v_base;
				r0 = &hash_table[r0].token;
				echo_string(r4, r0);
				echo_string(r4, ']');
			//} else {
			} else {
				//fprintf(code, "\tmov %s, _B0_%s", hash_table[target].token, hash_table[v_base].token);
				echo_string(r4, '\tmov ');
				r0 = target;
				r0 = &hash_table[r0].token;
				echo_string(r4, r0);
				echo_string(r4, ', _B0_');
				r0 = v_base;
				r0 = &hash_table[r0].token;
				echo_string(r4, r0);
			//}
			}
		//} else {
		} else {
			//fprintf(code, "]");
			echo_string(r4, ']');
		//}
		}
	}
	pop r5, r4, r3, r2, r1;
}

proc Global_Pointer(i){
//unsigned int Global_Pointer(unsigned int i){
	//if (token_stack[token] == TOKEN_ARRAY_END)
		//abort_b0("Unexpected end of memory reference");
	push r1, r2, r3, r4, r5;
	r0 = token;
	r1 = &token_stack;
	r2 = [r1+r0*8];
	r3 = TOKEN_ARRAY_END;
	if (r2 == r3){
		abort_b0('Unexpected end of memory reference');
	}
	
	r3 = TOKEN_OFFSET;
	r4 = 0;
	if(r2 < r3){
		r4 = 1;
	}
	r3 = TOKEN_MINUS;
	if(r2 == r3){
		r4 = 1;
	}
	if(r4){
	//if ((token_stack[token] < TOKEN_OFFSET)||(token_stack[token] == TOKEN_MINUS)) {
		//we have direct numerical reference
		//if (token_stack[token] == TOKEN_MINUS){
			//fprintf(code, "-");
			//token++;
		//}
		if(r2 == r3){
			r4 = code;
			echo_string(r4, '-');
			r0 = token;
			r0 = r0 + 1;
			token = r0;
		}
		//outputNumber(i, NUM_INTEGER);
		r0 = i;
		r4 = code;
		outputNumber(r0, NUM_INTEGER, r4);
	} else {
	//} else {
		//we should be dealing with a register
		//TokenIsLabelType(TYPE_REG);
		TokenIsLabelType(TYPE_REG);
		//fprintf(code, "%s", hash_table[token_stack[token]-HASH_OFFSET].token);
		r2 = r2 - HASH_OFFSET;
		r2 = &hash_table[r2].token;
		r4 = code;
		echo_string(r4, r2);
		//token++;
		r0 = token;
		r0 = r0 + 1;
		token = r0;
		r2 = [r1+r0*8];
		r3 = TOKEN_ADD;
		//if (token_stack[token] == TOKEN_ADD){
		if(r2 == r3){
			// Looks like a complex memory pointer operation.
			//fprintf(code, "+");
			echo_string(r4, '+');
			//token++;
			r0 = token;
			r0 = r0 + 1;
			token = r0;
			r2 = [r1+r0*8];
			r3 = TOKEN_OFFSET;
			//if (token_stack[token] > TOKEN_OFFSET) {
			if(r2 > r3){
				// Should be a reg?
				//TokenIsLabelType(TYPE_REG);
				TokenIsLabelType(TYPE_REG);
				//fprintf(code, "%s", hash_table[token_stack[token]-HASH_OFFSET].token); // Output the reg
				r2 = r2 - HASH_OFFSET;
				r2 = &hash_table[r2].token;
				r4 = code;
				echo_string(r4, r2);
				//token++;
				r0 = token;
				r0 = r0 + 1;
				token = r0;
				// Here we should have either a + or a *
				//if ((token_stack[token] != TOKEN_ADD) &&
					//(token_stack[token] != TOKEN_MINUS) &&
					//(token_stack[token] != TOKEN_MULTIPLY) &&
					//(token_stack[token] != TOKEN_ARRAY_END))
					//abort_b0("+, * or ] Expected");
				r2 = [r1+r0*8];
				r3 = TOKEN_ADD;
				if(r2 != r3){
					r3 = TOKEN_MINUS;
					if(r2!=r3){
						r3 = TOKEN_MULTIPLY;
						if(r2!=r3){
							r3 = TOKEN_ARRAY_END;
							if(r2!=r3){
								abort_b0('+, * or ] Expected');
							}
						}
					}
				}
				r4 = 0;
				r3 = TOKEN_MINUS;
				if(r2 == r3){ r4 = 1; }
				r3 = TOKEN_ADD;
				if(r2 == r3){ r4 = 1; }
				//if ((token_stack[token] == TOKEN_ADD)||(token_stack[token] == TOKEN_MINUS)) {
				if(r4){
					// We should have an immediate
					//if(token_stack[token] == TOKEN_ADD) {
						//fprintf(code, "+");
					//} else {
						//fprintf(code, "-");
					//}
					if(r2 == r3){
						r4 = code;
						echo_string(r4, '+');
					} else {
						r4 = code;
						echo_string(r4, '-');
					}
					//token++;
					r0 = token;
					r0 = r0 + 1;
					token = r0;
					//if (token_stack[token] > TOKEN_OFFSET)
						//abort_b0("Immediate Expected");
					r2 = [r1+r0*8];
					r3 = TOKEN_OFFSET;
					if(r2>r3){
						abort_b0('Immediate Expected');
					}
					//outputNumber(i, NUM_INTEGER);
					r0 = i;
					r4 = code;
					outputNumber(r0, NUM_INTEGER, r4);
				//} else {
				} else {
					//if (token_stack[token] == TOKEN_MULTIPLY) {
					r3 = TOKEN_MULTIPLY;
					if(r2 == r3){
						// Handle our multiply, else fall through (it should be an ARRAY_END).
						//fprintf(code, "*");
						r4 = code;
						echo_string(r4, '*');
						//token++;
						r0 = token;
						r0 = r0 + 1;
						token = r0;
						// This part gets tricky, as we should only have 1,2,4 or 8 here!
						//if (token_stack[token] > TOKEN_OFFSET)
							//abort_b0("Immediate Expected");
						r2 = [r1+r0*8];
						r3 = TOKEN_OFFSET;
						if(r2 > r3){
							abort_b0('Immediate Expected');
						}
						//if ((token_stack[token] != '1') &&
							//(token_stack[token] != '2') &&
							//(token_stack[token] != '4') &&
							//(token_stack[token] != '8'))
							//abort_b0("Illformed pointer expression, please revise");
						r3 = 31h;
						if(r2!=r3){
							r3 = 32h;
							if(r2!=r3){
								r3 = 34h;
								if(r2!=r3){
									r3 = 38h;
									if(r2!=r3){
										abort_b0('Illformed pointer expression, please revise');
									}
								}
							}
						}
						//fprintf(code, "%c", token_stack[token]);
						r4 = code;
						echo_character(r4, r3);
						//token++; // Output the number
						r0 = token;
						r0 = r0 + 1;
						token = r0;
						//if (token_stack[token] < TOKEN_OFFSET){
							//if (token_stack[token] != 'h') {
								//abort_b0("Unexpected Immediate");
							//}
							//token++; // Advance past the 'h'
						//}
						r2 = [r1+r0*8];
						r3 = TOKEN_OFFSET;
						if(r2<r3){
							r3 = 68h;
							if(r2!=r3){
								abort_b0('Unexpected Immediate');
							}
							r0 = r0 + 1;
							token = r0;
						}
						r2 = [r1+r0*8];
						r2 = r2 - TOKEN_ADD;
						r3 = 1;
						if(r2<=r3){
						//if ((token_stack[token] == TOKEN_ADD)||(token_stack[token] == TOKEN_MINUS)){
							//if(token_stack[token] == TOKEN_ADD) {
								//fprintf(code, "+");
							//} else {
								//fprintf(code, "-");
							//}
							r4 = code;
							r2 = [r1+r0*8];
							r3 = TOKEN_ADD;
							if(r2 == r3){
								echo_string(r4, '+');
							} else {
								echo_string(r4, '-');
							}
							//token++;
							r0 = token;
							r0 = r0 + 1;
							token = r0;
							r2 = [r1+r0*8];
							r3 = TOKEN_OFFSET;
							if(r2 < r3){
							//if (token_stack[token] < TOKEN_OFFSET) {
								//outputNumber(i, NUM_INTEGER);
								r0 = i;
								r4 = code;
								outputNumber(r0, NUM_INTEGER, r4);
							//} else {
							} else {
								///abort_b0("Expected Immediate");
								abort_b0('Expected Immediate');
							//}
							}
						//}
						}
					//}
					}
				//}
				}
			//} else {
			} else {
				// Else output the displacement.
				//outputNumber(i, NUM_INTEGER);
				r0 = i;
				outputNumber(r0, NUM_INTEGER, r4);
			//}
			}
		//}  else {
		} else {
			r3 = TOKEN_MULTIPLY;
			//if (token_stack[token] == TOKEN_MULTIPLY) {
			if(r2 == r3){
				// Handle our multiply, else fall through (it should be an ARRAY_END).
				//fprintf(code, "*");
				r4 = code;
				echo_string(r4, '*');
				//token++;
				r0 = token;
				r0 = r0 + 1;
				token = r0;
				// This part gets tricky, as we should only have 1,2,4 or 8 here!
				//if (token_stack[token] > TOKEN_OFFSET)
					//abort_b0("Immediate Expected");
				r2 = [r1+r0*8];
				r3 = TOKEN_OFFSET;
				if(r2 > r3){
					abort_b0('Immediate Expected');
				}
				//if ((token_stack[token] != '1') &&
					//(token_stack[token] != '2') &&
					//(token_stack[token] != '4') &&
					//(token_stack[token] != '8'))
					//abort_b0("Illformed pointer expression, please revise");
				r3 = 31h;
				if(r2!=r3){
					r3 = 32h;
					if(r2!=r3){
						r3 = 34h;
						if(r2!=r3){
							r3 = 38h;
							if(r2!=r3){
								abort_b0('Illformed pointer expression, please revise');
							}
						}
					}
				}
				//fprintf(code, "%c", token_stack[token]);
				echo_character(r4, r2);
				//token++; // Output the number
				r0 = token;
				r0 = r0 + 1;
				token = r0;
				//if (token_stack[token] < TOKEN_OFFSET){
					//if (token_stack[token] != 'h') {
						//abort_b0("Unexpected Immediate");
					//}
					//token++; // Advance past the 'h'
				//}
				r2 = [r1+r0*8];
				r3 = TOKEN_OFFSET;
				if(r2<r3){
					r3 = 68h;
					if(r2!=r3){
						abort_b0('Unexpected Immediate');
					}
					r0 = r0 + 1;
					token = r0;
				}
				r2 = [r1+r0*8];
				r2 = r2 - TOKEN_ADD;
				r3 = 1;
				if(r2<=r3){
				//if ((token_stack[token] == TOKEN_ADD)||(token_stack[token] == TOKEN_MINUS)){
					//if(token_stack[token] == TOKEN_ADD) {
						//fprintf(code, "+");
					//} else {
						//fprintf(code, "-");
					//}
					r4 = code;
					r2 = [r1+r0*8];
					r3 = TOKEN_ADD;
					if(r2 == r3){
						echo_string(r4, '+');
					} else {
						echo_string(r4, '-');
					}
					//token++;
					r0 = token;
					r0 = r0 + 1;
					token = r0;
					r2 = [r1+r0*8];
					r3 = TOKEN_OFFSET;
					if(r2 < r3){
					//if (token_stack[token] < TOKEN_OFFSET) {
						//outputNumber(i, NUM_INTEGER);
						r0 = i;
						outputNumber(r0, NUM_INTEGER, r4);
					//} else {
					} else {
						///abort_b0("Expected Immediate");
						abort_b0('Expected Immediate');
					//}
					}
				//}
				}
			//}
			} else {
				r3 = TOKEN_MINUS;
				if(r2 == r3){
					//fprintf(code, "-");
					r4 = code;
					echo_string(r4, '-');
					//token++;
					r0 = token;
					r0 = r0 + 1;
					token = r0;
					r2 = [r1+r0*8];
					r3 = TOKEN_OFFSET;
					if(r2 < r3){
					//if (token_stack[token] < TOKEN_OFFSET) {
						//outputNumber(i, NUM_INTEGER);
						r0 = i;
						outputNumber(r0, NUM_INTEGER, r4);
					//} else {
					} else {
						//abort_b0("Expected Immediate");
						abort_b0('Expected Immediate');
					//}
					}
				}
			}
		//}
		}
	//}
	}
	//return(0);
	pop r5, r4, r3, r2, r1;
}

proc process_struc_def(i){
	//unsigned int target_hash;
	//int variable_size, struc_size;
	//struc_struc *ptr_struc;
	m64 target_hash;
	m64 variable_size;
	m64 struc_size;
	m64 ptr_struc;
	
	push r1, r2, r3, r4, r5, r8, r9, r10, r15;
	r15 = DEBUG;
	//if(DEBUG)
		//printf("Defining a Variable based on a Structure\n");
	if (r15){
		echo_string(STDOUT, 'Defining a Variable based on a Structure\n');
	}
	//atStackStart();
	atStackStart();
	
	//Lets see if we have an array of struc's
	r5 = &token_stack;
	r4 = token;
	r0 = [r5+r4*8];
	r1 = TOKEN_ARRAY_START;
	r10 = 0;
	//if(token_stack[token] == TOKEN_ARRAY_START){
	if(r0 == r1){
		// Looks like we do, so lets grab our size.
		//toki = 0;
		r0 = 0;
		//token++;
		r4 = r4 + 1;
		token = r4;
		r1 = [r5+r4*8];
		r3 = TOKEN_ARRAY_END;
		r8 = TOKEN_OFFSET;
		r9 = TOKEN_MAX_SIZE-2;
		r2 = &token_buffer;
		[r2] = r0w;	  // Clear the offset markers (dhtoi ignores these values and is strictly ASCIIZ).
		r2 = r2 + 2;  // Skip string offset markers
		//while (token_stack[token] != TOKEN_ARRAY_END) {
		while(r1 != r3){
			//token_buffer[toki] = (unsigned char)token_stack[token];
			if (r1 >= r8) { abort_b0('Expected immediate integer'); }
			[r2+r0] = r1b;
			r0 = r0 + 1;
			//token_buffer[toki+1] = '\0';
			[r2+r0] = r10b;
			//toki++;
			//token++;
			r4 = r4 + 1;
			token = r4;
			r1 = [r5+r4*8];
			//if (toki >= TOKEN_MAX_SIZE) abort_b0("INTERNAL: Token Preprocessor Buffer Overflow! - Increase TOKEN_MAX_SIZE");
			if(r0 >= r9){ abort_b0('INTERNAL: Token Preprocessor Buffer Overflow! - Increase TOKEN_MAX_SIZE'); }
		//}
		}
		//TokenIs(TOKEN_ARRAY_END);
		TokenIs(TOKEN_ARRAY_END);
		//token++; // Skip end of array size indicator.
		r4 = token;
		r4 = r4 + 1;
		token = r4;
		//variable_size = dhtoi(token_buffer);  // Get our array size!
		r2 = &token_buffer;
		r0 = dhtoi(r2);
		variable_size = r0;
	//} else {
	} else {
		//variable_size = 1;
		variable_size = 1;
	//}
	}
	//if(DEBUG)
		//printf("Struc Variable Size = %d\n", variable_size);
	if(r15){
		r1 = variable_size;
		echo_string(STDOUT, 'Struc Variable Size = ');
		echo_integer(STDOUT, r1);
		echo_string(STDOUT, '\n');
	}
	//isHash(token_stack[token]);
	r4 = token;
	r1 = [r5+r4*8];
	isHash(r1);
	//target_hash = token_stack[token]-HASH_OFFSET;
	r1 = r1 - HASH_OFFSET;
	target_hash = r1;
	//IsLabelAllocated();
	IsLabelAllocated();
	//Set our variable type;
	
	//if(global == 0){
		//hash_table[target_hash].token_type = TYPE_GLOBAL+TYPE_VSTRUC+(hash_table[token_stack[0]-HASH_OFFSET].token_type & 0xf);
	//} else {
		//hash_table[target_hash].token_type = TYPE_LOCAL+TYPE_VSTRUC +(hash_table[token_stack[0]-HASH_OFFSET].token_type & 0xf);
	//}
	r0 = [r5];
	r3 = r0 - HASH_OFFSET;
	r0 = hash_table[r3].token_type;
	r0 = r0 && 0fh;
	r2 = global;
	if(r2 == r10){
		r0 = r0 + TYPE_GLOBAL+TYPE_VSTRUC;
	} else {
		r0 = r0 + TYPE_LOCAL+TYPE_VSTRUC;
	}
	hash_table[r1].token_type = r0;
	//Now comes the hard bit... Now to allocate the space within the final executable.
	//struc_size = hash_table[token_stack[0]-HASH_OFFSET].local_offset;  //Local offset holds the number of elements within the struc
	r4 = hash_table[r3].local_offset;
	struc_size = r4;
	//ptr_struc = hash_table[token_stack[0]-HASH_OFFSET].struc_ptr;
	r0 = hash_table[r3].struc_ptr;
	ptr_struc = r0;
	//hash_table[target_hash].struc_ptr = ptr_struc;
	hash_table[r1].struc_ptr = r0;
	//struc_size = ptr_struc->struc[struc_size].offset; // Struc Size == size of structure in bytes!
	r4 = r4 << 5;
	r8 = [r0+r4+struct_entry.offset];
	//hash_table[target_hash].local_offset = struc_size;
	hash_table[r1].local_offset = r8;
	//if(DEBUG)
		//printf("Structure Size = %d\nVariable Size = %d\n", struc_size, struc_size*variable_size);
	r3 = variable_size;
	r0 = r8;
	r9 = r0 * r3;  // variable_size * struc_size
	if(r15){
		echo_string(STDOUT, 'Structure Size = ');
		echo_integer(STDOUT, r8);
		echo_string(STDOUT, '\nVariable Size = ');
		echo_integer(STDOUT, r9);
		echo_string(STDOUT, '\n');
	}
	// Now that we have our size, let's output the required stuff...
	//if(global == 0){
	if(r2 == r10){
		//fprintf(bss, "_B0_%s rb %d\n", hash_table[target_hash].token, struc_size*variable_size);	
		r10 = bss;
		echo_string(r10, '_B0_');
		r0 = target_hash;
		r0 = &hash_table[r0].token;
		echo_string(r10, r0);
		echo_string(r10, ' rb ');
		echo_integer(r10, r9);
		echo_string(r10, '\n');
	//} else {
	} else {
		//fprintf(data, "_B0_%s_%s equ %d\n", hash_table[global-HASH_OFFSET].token, hash_table[target_hash].token, local_var_offset);
		r10 = data;
		echo_string(r10, '_B0_');
		r0 = global;
		r0 = r0 - HASH_OFFSET;
		r0 = &hash_table[r0].token;
		echo_string(r10, r0);
		echo_string(r10, '_');
		r0 = &hash_table[r1].token;
		echo_string(r10, r0);
		echo_string(r10, ' equ ');
		r1 = local_var_offset;
		echo_integer(r10, r1);
		echo_string(r10, '\n');
		//local_var_offset = local_var_offset + (struc_size*variable_size);
		r1 = r1 + r9;
		local_var_offset = r1;
		//hash_table[global-HASH_OFFSET].local_offset = local_var_offset;
		r0 = global;
		r0 = r0 - HASH_OFFSET;
		hash_table[r0].local_offset = r1;
	//}
	}
	//token++;
	r4 = token;
	r4 = r4 + 1;
	token = r4;
	r10 = i;
	//if(DEBUG)
		//printf("token = 0x%x, i = 0x%x\n", token, i);
	if(r15){
		echo_string(STDOUT, 'token = ');
		echo_hex(STDOUT, r4);
		echo_string(STDOUT, ', i = ');
		echo_hex(STDOUT, r10);
		echo_string(STDOUT, '\n');
	}
		
	//atStackEnd(i);
	atStackEnd(r10);
	//if(DEBUG)
		//printf("Finished defining a variable based on a structure\n");
	if(r15){
		echo_string(STDOUT, 'Finished defining a variable based on a structure\n');
	}
	pop r15, r10, r9, r8, r5, r4, r3, r2, r1;
	//return(0);
}

proc TS_is_int(i){
	// All this function does is scan the token_stack, and
	// if we have a FPU reg in there somewhere, return 0
	// else return 1, indicating that no tokens relate
	// to fpu operations.
	// i = number of tokens.
	// token = current token., we assume token = 0;
	//for (token = 0; token < i; token++){
		//switch(token_stack[token]) {
			//case HASH_fp0+HASH_OFFSET:
			//case HASH_fp1+HASH_OFFSET:
			//case HASH_fp2+HASH_OFFSET:
			//case HASH_fp3+HASH_OFFSET:
			//case HASH_fp4+HASH_OFFSET:
			//case HASH_fp5+HASH_OFFSET:
			//case HASH_fp6+HASH_OFFSET:
			//case HASH_fp7+HASH_OFFSET: isInt = 0;
			//break;
		//}
	//}
	push r1, r2, r3, r4;
	r0 = 0;
	r1 = i;
	r2 = &token_stack;
	r4 = HASH_fp7 - HASH_fp0;
	while (r0 < r1){
		r3 = [r2+r0*8];
		r3 = r3 - HASH_fp0+HASH_OFFSET;
		if(r3 < r4){
			token = 0;
			pop r4, r3, r2, r1;
			return(0);
		}
		r0 = r0 + 1;
	}
	
	//token = 0; // Reset the token value
	//return(isInt);
	token = 0;
	pop r4, r3, r2, r1;
	return(1);
}

proc process_struc(){
	//unsigned int i, j, k, offset, s_offset;
	//int variable_size;
	//struc_struc *ptr_struc;
	//struc_struc *ptr_struc_embedded;	// Pointer to another structure which we want
									// to embed into this structure!
	// struc_def = hash of the structure we are operating on.
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12, r13, r14, r15;
	
	m64 i;
	m64 j;
	m64 k;
	m64 offset;
	m64 s_offset;
	m64 variable_size;
	m64 ptr_struc;
	m64 ptr_struc_embedded;
	
	r12 = DEBUG;
	r15 = &token_stack;
	r14 = token;
	//i = token;
	r13 = r14;
	//token = 0;
	r14 = 0;
	//if(DEBUG){
		//printf("PROCESSING STRUC STACK : ");
		//for (token = 0; token < i; token++){
			//printf("0x%x ", token_stack[token]);
		//}
		//printf("\n");
	//}
	if(r12){
		echo_string(STDOUT, 'PROCESSING STRUC STACK : ');
		while(r14 < r13){
			r1 = [r15+r14*8];
			echo_hex(STDOUT, r1);
			echo_string(STDOUT, ' ');
			r14 = r14 + 1;
		}
		echo_string(STDOUT, '\n');
	}
	//token = 0;
	r14 = 0;
	token = r14;
	//while (token < i){
	while(r14 < r13){
		//if(DEBUG)
			//printf("Structure - Processing Stack\n");
		if(r12){
			echo_string(STDOUT, 'Structure - Processing Stack\n');
		}
		//switch (token_stack[token]) {
		r1 = [r15+r14*8];
		r0 = 0;
		r2 = HASH_m8+HASH_OFFSET;  if (r1 == r2) { r0 = 1; };
		r2 = HASH_m16+HASH_OFFSET; if (r1 == r2) { r0 = 1; };
		r2 = HASH_m32+HASH_OFFSET; if (r1 == r2) { r0 = 1; };
		#ifndef i386;
		r2 = HASH_m64+HASH_OFFSET; if (r1 == r2) { r0 = 1; };
		#endif;
		r2 = HASH_f32+HASH_OFFSET; if (r1 == r2) { r0 = 1; };
		r2 = HASH_f64+HASH_OFFSET; if (r1 == r2) { r0 = 1; };
		r2 = HASH_f80+HASH_OFFSET; if (r1 == r2) { r0 = 1; };
		
			//case HASH_m8+HASH_OFFSET :
			//case HASH_m16+HASH_OFFSET :
			//case HASH_m32+HASH_OFFSET :
			//#ifndef i386
			//case HASH_m64+HASH_OFFSET :
			//#endif
			//case HASH_f32+HASH_OFFSET :
			//case HASH_f64+HASH_OFFSET :
			//case HASH_f80+HASH_OFFSET :
		if (r0){
				//if(DEBUG)
					//printf("Structure - Processing Variable Def\n");
				if(r12) {
					echo_string(STDOUT, 'Structure - Processing Variable Def\n');
				}
				//atStackStart();
				atStackStart();
				r14 = token;
				r1 = [r15+r14*8];
				r2 = TOKEN_ARRAY_START;
				//if (token_stack[token] == TOKEN_ARRAY_START) {
				if(r1 == r2){
					// This gets a little complicated?
					r5 = &token_buffer;
					//toki = 0;
					r2 = 0;
					r4 = 0;
					[r5] = r2w;
					r5 = r5 + 2;
					//token++;
					r14 = token;
					r14 = r14 + 1;
					token = r14;
					r1 = [r15+r14*8];
					r3 = TOKEN_ARRAY_END;
					r8 = TOKEN_OFFSET;
					r9 = TOKEN_MAX_SIZE;
					//while (token_stack[token] != TOKEN_ARRAY_END) {
					while(r1 != r3){
						if(r1 > r8) { abort_b0('Expected immediate integer'); }
						//token_buffer[toki] = (unsigned char)token_stack[token];
						[r5+r2] = r1b;
						//token_buffer[toki+1] = '\0';
						[r5+r2+1] = r4b;
						//toki++;
						r2 = r2 + 1;
						//token++;
						r14 = r14 + 1;
						token = r14;
						r1 = [r15+r14*8];
						//if (toki >= TOKEN_MAX_SIZE) abort_b0("INTERNAL: Token Preprocessor Buffer Overflow! - Increase TOKEN_MAX_SIZE");
						if(r2 >= r9) { abort_b0('INTERNAL: Token Preprocessor Buffer Overflow! - Increase TOKEN_MAX_SIZE'); }
					//}
					}
					//token++; // Skip end of array size indicator.
					r14 = r14 + 1;
					token = r14;
					//variable_size = dhtoi(token_buffer);  // Get our array size!
					r5 = &token_buffer;
					r3 = dhtoi(r5);
					variable_size = r3;
				//} else {
				} else {
					//variable_size = 1;
					r3 = 1;
					variable_size = r3;
				}
				//}
				r14 = token;
				r1 = [r15+r14*8];
				//isHash(token_stack[token]);
				isHash(r1);
				//switch (token_stack[0]) {
					//case HASH_m8+HASH_OFFSET : break;
					//case HASH_m16+HASH_OFFSET : variable_size *= 2; break;
					//case HASH_m32+HASH_OFFSET : variable_size *= 4; break;
					//#ifndef i386
					//case HASH_m64+HASH_OFFSET : variable_size *= 8; break;
					//#endif
					//case HASH_f32+HASH_OFFSET : variable_size *= 4; break;
					//case HASH_f64+HASH_OFFSET : variable_size *= 8; break;
					//case HASH_f80+HASH_OFFSET : variable_size *= 10; break;
				//}
				r0 = [r15];
				r1 = HASH_m16+HASH_OFFSET; if(r0 == r1){ r3 = r3 << 1; }
				r1 = HASH_m32+HASH_OFFSET; if(r0 == r1){ r3 = r3 << 2; }
				#ifndef i386;
				r1 = HASH_m64+HASH_OFFSET; if(r0 == r1){ r3 = r3 << 3; }
				#endif;
				r1 = HASH_f32+HASH_OFFSET; if(r0 == r1){ r3 = r3 << 2; }
				r1 = HASH_f64+HASH_OFFSET; if(r0 == r1){ r3 = r3 << 3; }
				r1 = HASH_f80+HASH_OFFSET; if(r0 == r1){ asm {
	lea r3, [r3+r3*4]
} r3 = r3 << 1; }
				variable_size = r3;
				//token++;
				r14 = r14 + 1;
				token = r14;
				//atStackEnd(i);
				atStackEnd(r13);
				r0 = [r15+r14*8-8];
				r0 = r0 - HASH_OFFSET;
				r1 = struc_def;
				//ScanForDupStrucLabel(struc_def, token_stack[token-1]-HASH_OFFSET);
				ScanForDupStrucLabel(r1, r0);
				//offset = hash_table[struc_def].local_offset;
				r2 = hash_table[r1].local_offset;
				offset = r2;
				//ptr_struc = hash_table[struc_def].struc_ptr;
				r10 = hash_table[r1].struc_ptr;
				ptr_struc = r10;
				//if(DEBUG)
					//printf("Variable Size = %d, Offset = 0x%x\n", variable_size, offset);
				if(r12){
					echo_string(STDOUT, 'Variable Size = ');
					echo_integer(STDOUT, r3);
					echo_string(STDOUT, ', Offset = ');
					echo_hex(STDOUT, r2);
					echo_string(STDOUT, '\n');
				}
				//token--;	// Better point to our hash value!
				r14 = r14 - 1;
				token = r14;
				r0 = hash_table[r1].token_type;
				r5 = TYPE_STRUC;
				//if (hash_table[struc_def].token_type == TYPE_STRUC) {
				if(r0 == r5){
					// We better set the it the first variable type;
					//switch (token_stack[0]) {
						//case HASH_m8+HASH_OFFSET : hash_table[struc_def].token_type = TYPE_STRUC+TYPE_M8; break;
						//case HASH_m16+HASH_OFFSET : hash_table[struc_def].token_type = TYPE_STRUC+TYPE_M16; break;
						//case HASH_m32+HASH_OFFSET : hash_table[struc_def].token_type = TYPE_STRUC+TYPE_M32; break;
						//#ifndef i386
						//case HASH_m64+HASH_OFFSET : hash_table[struc_def].token_type = TYPE_STRUC+TYPE_M64; break;
						//#endif
						//case HASH_f32+HASH_OFFSET : hash_table[struc_def].token_type = TYPE_STRUC+TYPE_F32; break;
						//case HASH_f64+HASH_OFFSET : hash_table[struc_def].token_type = TYPE_STRUC+TYPE_F64; break;
						//case HASH_f80+HASH_OFFSET : hash_table[struc_def].token_type = TYPE_STRUC+TYPE_F80; break;
					//}
					r0 = [r15];
					r3 = HASH_m8+HASH_OFFSET; if(r0 == r3){ hash_table[r1].token_type = TYPE_STRUC+TYPE_M8; } else {
					r3 = HASH_m16+HASH_OFFSET; if(r0 == r3){ hash_table[r1].token_type = TYPE_STRUC+TYPE_M16; } else {
					r3 = HASH_m32+HASH_OFFSET; if(r0 == r3){ hash_table[r1].token_type = TYPE_STRUC+TYPE_M32; } else {
					#ifndef i386; 
					r3 = HASH_m64+HASH_OFFSET;
					#else;
					r3 = HASH_m32+HASH_OFFSET;
					#endif;
					if(r0 == r3){ 
						#ifndef i386;
						hash_table[r1].token_type = TYPE_STRUC+TYPE_M64;
						#else;
						hash_table[r1].token_type = TYPE_STRUC+TYPE_M32;
						#endif;
					} else {
					r3 = HASH_f32+HASH_OFFSET; if(r0 == r3){ hash_table[r1].token_type = TYPE_STRUC+TYPE_F32; } else {
					r3 = HASH_f64+HASH_OFFSET; if(r0 == r3){ hash_table[r1].token_type = TYPE_STRUC+TYPE_F64; } else {
					r3 = HASH_f80+HASH_OFFSET; if(r0 == r3){ hash_table[r1].token_type = TYPE_STRUC+TYPE_F80; }}}}}}};
				//}
				}
				// Get our next offset.
				//s_offset = ptr_struc->struc[offset].offset;
				r2 = r2 << 5;
				r3 = [r10+r2+struct_entry.offset];
				s_offset = r3;
				//switch (token_stack[0]) {
					//case HASH_m8+HASH_OFFSET : ptr_struc->struc[offset].type = TYPE_M8; break;
					//case HASH_m16+HASH_OFFSET : ptr_struc->struc[offset].type = TYPE_M16;  break;
					//case HASH_m32+HASH_OFFSET : ptr_struc->struc[offset].type = TYPE_M32;  break;
					//#ifndef i386
					//case HASH_m64+HASH_OFFSET : ptr_struc->struc[offset].type = TYPE_M64;  break;
					//#endif
					//case HASH_f32+HASH_OFFSET : ptr_struc->struc[offset].type = TYPE_F32;  break;
					//case HASH_f64+HASH_OFFSET : ptr_struc->struc[offset].type = TYPE_F64;  break;
					//case HASH_f80+HASH_OFFSET : ptr_struc->struc[offset].type = TYPE_F80;  break;
				//}
				r0 = [r15];
				r3 = HASH_m8+HASH_OFFSET; if(r0 == r3) { r3 = TYPE_M8; [r10+r2+struct_entry.type] = r3; } else {
				r3 = HASH_m16+HASH_OFFSET; if(r0 == r3) { r3 = TYPE_M16; [r10+r2+struct_entry.type] = r3; } else {
				r3 = HASH_m32+HASH_OFFSET; if(r0 == r3) { r3 = TYPE_M32; [r10+r2+struct_entry.type] = r3; } else {
				#ifndef i386; 
				r3 = HASH_m64+HASH_OFFSET;
				#else;
				r3 = HASH_m32+HASH_OFFSET;
				#endif;
				if(r0 == r3) { 
				#ifndef i386;
				r3 = TYPE_M64;
				#else;
				r3 = TYPE_M32;
				#endif; 
				[r10+r2+struct_entry.type] = r3; } else {
				r3 = HASH_f32+HASH_OFFSET; if(r0 == r3) { r3 = TYPE_F32; [r10+r2+struct_entry.type] = r3; } else {
				r3 = HASH_f64+HASH_OFFSET; if(r0 == r3) { r3 = TYPE_F64; [r10+r2+struct_entry.type] = r3; } else {
				r3 = HASH_f80+HASH_OFFSET; if(r0 == r3) { r3 = TYPE_F80; [r10+r2+struct_entry.type] = r3; }}}}}}};
				//ptr_struc->struc[offset].hash = token_stack[token]-HASH_OFFSET;
				r0 = [r15+r14*8];
				r0 = r0 - HASH_OFFSET;
				[r10+r2+struct_entry.hash] = r0;
				//ptr_struc->struc[offset].size = variable_size;
				r0 = variable_size;
				[r10+r2+struct_entry.size] = r0;
				//ptr_struc->struc[offset+1].offset = s_offset+variable_size;
				r1 = s_offset;
				r0 = r0 + r1;
				[r10+r2+struct_entry.offset+32] = r0;
				//ptr_struc->struc[offset+1].hash = 0;
				r0 = 0;
				[r10+r2+struct_entry.hash+32] = r0;
				//if(DEBUG)
					//printf("Variable %s, Type = 0x%x, Size = 0x%x, Offset = 0x%x\n", hash_table[ptr_struc->struc[offset].hash].token, ptr_struc->struc[offset].type, ptr_struc->struc[offset].size, ptr_struc->struc[offset].offset);
				if(r12){
					echo_string(STDOUT, 'Variable ');
					echo_hex(STDOUT, r2);
					echo_string(STDOUT, ' ');
					r0 = [r10+r2+struct_entry.hash];
					r0 = &hash_table[r0].token;
					echo_string(STDOUT, r0);
					echo_string(STDOUT, ', Type = ');
					r0 = [r10+r2+struct_entry.type];
					echo_hex(STDOUT, r0);
					echo_string(STDOUT, ', Size = ');
					r0 = [r10+r2+struct_entry.size];
					echo_hex(STDOUT, r0);
					echo_string(STDOUT, ', Offset = ');
					r0 = [r10+r2+struct_entry.offset];
					echo_hex(STDOUT, r0);
					echo_string(STDOUT, '\n');
				}
				//hash_table[struc_def].local_offset++;	// Increment the pointer into the structure table
				r1 = struc_def;
				r0 = hash_table[r1].local_offset;
				r0 = r0 + 1;
				hash_table[r1].local_offset = r0;
				//if (offset+1 >= STRUC_SIZE)
					//abort_b0("INTERNAL: Structure Definition Table Overflow! - Increase STRUC_SIZE");
				r0 = offset;
				r0 = r0 + 1;
				r1 = STRUC_SIZE;
				if(r0 >= r1){ abort_b0('INTERNAL: Structure Definition Table Overflow! - Increase STRUC_SIZE'); }
				//token = i;
				r14 = r13;
				token = r14;
				//break;
		} else {
			//case TOKEN_BLOCK_END : 
			r2 = TOKEN_BLOCK_END;
			if(r1 == r2){
				//if(DEBUG)
					//printf("Struc - Processing TOKEN_END_BLOCK\n");
				if(r12){
					echo_string(STDOUT, 'Struc - Processing TOKEN_END_BLOCK\n');
				}
				//atStackStart();
				atStackStart();
				r14 = token;
				//if(DEBUG)
					//printf("token = 0x%x, i = 0x%x\n", token, i);
				if(r12){
					echo_string(STDOUT, 'token = ');
					echo_hex(STDOUT, r14);
					echo_string(STDOUT, ', i = ');
					echo_hex(STDOUT, r13);
					echo_string(STDOUT, '\n');
				}
				//if (i > token){
				if(r13 > r14){
					//j = i - token; // make j our count!
					r5 = r13 - r14;
					//for (k = 0; k < j; k++){
						// Quick move the stack forward
						//token_stack[k] = token_stack[token];
						//token++;
						//if (DEBUG)
							//printf("stack[%d] = 0x%x\n",k,token_stack[k]);
					//}
					r1 = 0;
					while (r1 < r5){
						r2 = [r15+r14*8];
						[r15+r1*8] = r2;
						if(r12){
							echo_string(STDOUT, 'stack[');
							echo_integer(STDOUT, r1);
							echo_string(STDOUT, '] = ');
							echo_hex(STDOUT, r2);
							echo_string(STDOUT, '\n');
						}
						r14 = r14 + 1;
						token = r14;
						r1 = r1 + 1;
					}
					//token = 0;		// Set our stack pointer to 0
					r14 = 0;
					token = r14;
					//i = j;			// Set our new stack size to the count!
					r13 = r5;
					//if(DEBUG)
						//printf("process_struc > token = 0x%x, i = 0x%x\n", token, i);
					if(r12){
						echo_string(STDOUT, 'process_struc > token = ');
						echo_hex(STDOUT, r14);
						echo_string(STDOUT, ', i = ');
						echo_hex(STDOUT, r13);
						echo_string(STDOUT, '\n');
					}
						
					//struc_def = 0;
					struc_def = 0;
					//do_process = 0;
					do_process = 0;
					r0 = r13;
					pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
					//return(i);
					return(r0);
				//} else {
				} else {
					//atStackEnd(i);
					atStackEnd(r13);
					//getChar();
					getChar();
					//struc_def = 0;
					struc_def = 0;
					//return(1);
					pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
					return(1);
				//}
				}
				//break;
			} else {
			//default:
				r2 = r1 - HASH_OFFSET;
				r2 = hash_table[r2].token_type;
				r3 = TYPE_STRUC;
				r2 = r2 && r3;
				//if ((hash_table[(token_stack[token]-HASH_OFFSET)].token_type & TYPE_STRUC) != TYPE_STRUC)
					//abort_b0("Structures can only contain variable definitions");
				if(r2 != r3){ abort_b0('Structures can only contain variable definitions'); }
				//if(DEBUG)
					//printf("Structure - Processing embedded structure\n");
				if(r12){
					echo_string(STDOUT, 'Structure - Processing embedded structure\n');
				}
				//atStackStart();
				atStackStart();
				//atStackEnd(i);
				atStackEnd(r13);
				//token--;
				r14 = token;
				r14 = r14 - 1;
				token = r14;

				// The structure which we want to copy.
				//ptr_struc_embedded = hash_table[token_stack[token]-HASH_OFFSET].struc_ptr;
				//s_offset = hash_table[token_stack[token]-HASH_OFFSET].local_offset;
				r1 = [r15+r14*8];
				r1 = r1 - HASH_OFFSET;
				r11 = hash_table[r1].struc_ptr;
				r3 = hash_table[r1].local_offset;
				ptr_struc_embedded = r11;
				s_offset = r3;
				
				//if(DEBUG)
					//printf("Source ptr = %p\n", ptr_struc_embedded);
				if(r12){
					echo_string(STDOUT, 'Embedded Source ptr = ');
					echo_hex(STDOUT, r11);
					echo_string(STDOUT, '\n');
				}
				// The desintation
				r1 = struc_def;
				//offset = hash_table[struc_def].local_offset;
				//ptr_struc = hash_table[struc_def].struc_ptr;
				r4 = hash_table[r1].local_offset;
				r10 = hash_table[r1].struc_ptr;
				offset = r4;
				ptr_struc = r10;

				// Now copy the structures over
				//for (j = 0; j < s_offset; j++){
					//ScanForDupStrucLabel(struc_def, ptr_struc_embedded->struc[j].hash);
					//ptr_struc->struc[offset].type = ptr_struc_embedded->struc[j].type;
					//ptr_struc->struc[offset].size = ptr_struc_embedded->struc[j].size;
					//ptr_struc->struc[offset].hash = ptr_struc_embedded->struc[j].hash;
					//ptr_struc->struc[offset+1].offset = ptr_struc->struc[offset].offset + ptr_struc->struc[offset].size;
					//if(DEBUG)
						//printf("Variable %s, Type = 0x%x, Size = 0x%x, Offset = 0x%x\n", hash_table[ptr_struc->struc[offset].hash].token, ptr_struc->struc[offset].type, ptr_struc->struc[offset].size, ptr_struc->struc[offset].offset);
					//offset++;
				//}
				r2 = 0;
				while(r2 < r3){
					r8 = r2 << 5;
					r15 = r4 << 5;
					r9 = [r11+r8+struct_entry.hash];
					ScanForDupStrucLabel(r1, r9);
					if(r12){ echo_string(STDOUT, 'Variable '); r0 = &hash_table[r9].token; echo_string(STDOUT, r0); }
					[r10+r15+struct_entry.hash] = r9;
					r9 = [r11+r8+struct_entry.type];
					[r10+r15+struct_entry.type] = r9;
					if(r12){ echo_string(STDOUT, ', Type = '); echo_hex(STDOUT, r9); }
					r9 = [r11+r8+struct_entry.size];
					[r10+r15+struct_entry.size] = r9;
					if(r12){ echo_string(STDOUT, ', Size = '); echo_hex(STDOUT, r9); }
					r8 = [r10+r15+struct_entry.offset];
					if(r12){ echo_string(STDOUT, ', Offset = '); echo_hex(STDOUT, r8); echo_string(STDOUT, '\n'); }
					r9 = r9 + r8;
					r15 = r15 + 32;  // Each entry is 32bytes in size;
					[r10+r15+struct_entry.offset] = r9;
					r2 = r2 + 1;
					r4 = r4 + 1;
				}
				//hash_table[struc_def].local_offset = offset;
				hash_table[r1].local_offset = r4;
				//token = i;
				r14 = r13;
				token = r14;
				//break;
			}
		}
	//}
	}
	//token = 0;	// Clear the token stack
	token = 0;
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
	//return(0);
}

proc process_token_stack(){
	//unsigned int i, j, k, l, exit_struc;
	m64 i;
	m64 j;
	m64 k;
	m64 l;
	
	
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12, r13, r14, r15;
	
	//preparse_token_stack();
	preparse_token_stack();
	
	//i = token; // i holds the number of tokens to process.
	r15 = &token_stack;
	r14 = token;
	r13 = r14;
	i = r13;
	//if(DEBUG){
		//printf("PROCESSING STACK : ");
		//for (token = 0; token < i; token++){
			//printf("0x%x ", token_stack[token]);
		//}
		//printf("\n");
	//}
	r12 = DEBUG;
	if(r12){
		echo_string(STDOUT, 'PROCESSING STACK : ');
		r14 = 0;
		while (r14 < r13){
			r1 = [r15+r14*8];
			echo_hex(STDOUT, r1);
			echo_string(STDOUT, ' ');
			r14 = r14 + 1;
		}
		echo_string(STDOUT, '\n');
	}
		
	r11 = &pp_GenCode;
	r10 = pp_ptr;
	r0 = 0;
	r1 = TOKEN_PREPARSER;
	r2 = [r15];
	r3 = [r11+r10*8];
	r4 = 1;
	if(r2 == r1) { r0 = 1; }
	if(r3 == r4) { r0 = 1; }
	//if ((pp_GenCode[pp_ptr] == 1)||(token_stack[0] == TOKEN_PREPARSER)) {
		//token = 0;		// Set the token pointer to the start of the stack
	if (r0) {
		r14 = 0;
		token = r14;
	//} else {
	} else {
		//if (token_stack[0] == TOKEN_BLOCK_END){
		r1 = TOKEN_BLOCK_END;
		if(r2 == r1){
			// The next valid token could be a PREPARSER command which we definitely need to execute.
			//j = 0;
			r0 = 0;
			//while ((token_stack[j] == TOKEN_BLOCK_END) & (j < i)){
				// Scan the token stack for the last TOKEN_END_BLOCK
				//j++;
			//}
			r2 = [r15+r0*8];
			r3 = 0;
			if (r2 == r1) { 
				if (r0 < r13) { r3 = 1; }
			}
			while (r3){
				r3 = 0;
				r0 = r0 + 1;
				r2 = [r15+r0*8];
				if (r2 == r1) { 
					if (r0 < r13) { r3 = 1; }
				}
			}
				
			// If we're at the end, just exit
			//if (j == i) {
			if (r0 == r13){
				//token = i;
				token = r13;
				r14 = r13;
			//} else {
			} else {
				// Else see if the next one is a preparser command.
				r2 = [r15+r0*8];
				r1 = TOKEN_PREPARSER;
				//if (token_stack[j] != TOKEN_PREPARSER){
				if(r2 != r1){
					//token = i;
					r14 = r13;
					token = r14;
				//} else {
				} else {
					//token = 0;
					r14 = 0;
					token = r14;
				//}
				}
			}
			//}
		//} else {
		} else {
			//token = i;		// Set the token pointer to the end of the stack, which causes no code generation to occur!
			r14 = r13;
			token = r14;
		//}
		}
	//}
	}
	//while (token < i){
	while(r14 < r13){
		//if(DEBUG)
			//printf("Processing Stack\n");
		if(r12){
			echo_string(STDOUT, 'Processing Stack - token = ');
			echo_hex(STDOUT, r14);
			echo_string(STDOUT, ' i = ');
			echo_hex(STDOUT, r13);
			echo_string(STDOUT, '\n');
		}
		r1 = [r15+r14*8];
		r0 = HASH_lib+HASH_OFFSET; if (r0 == r1){ process_lib_directive(r13); } else {
		r0 = HASH_syscall+HASH_OFFSET; if(r0 == r1){ process_syscall_directive(r13); } else {
		r0 = HASH_sysret+HASH_OFFSET; if(r0 == r1){ process_syscall_directive(r13); } else {
		r0 = HASH_fdecstp+HASH_OFFSET; if(r0 == r1){ process_syscall_directive(r13); } else {
		r0 = HASH_fincstp+HASH_OFFSET; if(r0 == r1){ process_syscall_directive(r13); } else {
		r0 = HASH_ret+HASH_OFFSET; if(r0 == r1){ process_syscall_directive(r13); } else {
		r0 = HASH_extern+HASH_OFFSET; if(r0 == r1){ process_extern_directive(r13); } else {
		r0 = HASH_push+HASH_OFFSET; if(r0 == r1){ process_pushpop_directive(r13); } else {
		r0 = HASH_pop+HASH_OFFSET; if(r0 == r1) { process_pushpop_directive(r13); } else {
		r0 = HASH_in+HASH_OFFSET; if(r0 == r1){ process_inout_directive(r13); } else {
		r0 = HASH_out+HASH_OFFSET; if(r0 == r1) { process_inout_directive(r13); } else {
		r0 = HASH_call+HASH_OFFSET; if (r0 == r1){ process_calljmp_directive(r13); } else {
		r0 = HASH_jmp+HASH_OFFSET; if(r0 == r1){ process_calljmp_directive(r13); } else {
		r0 = HASH_asm+HASH_OFFSET; if(r0 == r1){ process_asm_directive(r13); } else {
		r0 = HASH_else+HASH_OFFSET; if (r0 == r1){ abort_b0('Unexpected ELSE'); } else {
		r0 = TOKEN_BLOCK_END; if(r0 == r1){ r13 = process_token_block_end(r13); i = r13; } else {
		r0 = HASH_if+HASH_OFFSET; if(r0 == r1){ process_ifwhile_directive(r13); } else {
		r0 = HASH_while+HASH_OFFSET; if(r0 == r1){ process_ifwhile_directive(r13); } else {
		r0 = HASH_proc+HASH_OFFSET; if (r0 == r1){ process_proc_directive(r13); } else {
		r0 = HASH_m8+HASH_OFFSET; if (r0 == r1){ process_data_directive(r13); } else {
		r0 = HASH_m16+HASH_OFFSET;if(r0 == r1){ process_data_directive(r13); } else {
		r0 = HASH_m32+HASH_OFFSET; if(r0 == r1){ process_data_directive(r13);} else {
		#ifndef i386;
		r0 = HASH_m64+HASH_OFFSET;
		#else;
		r0 = HASH_m32+HASH_OFFSET;
		#endif;
		if(r0 == r1){ process_data_directive(r13); } else {
		r0 = HASH_f32+HASH_OFFSET; if(r0 == r1){ process_data_directive(r13); } else {
		r0 = HASH_f64+HASH_OFFSET; if (r0 == r1){ process_data_directive(r13); } else {
		r0 = HASH_f80+HASH_OFFSET; if(r0 == r1){ process_data_directive(r13); } else {
		r0 = HASH_struc+HASH_OFFSET; if(r0 == r1){ process_struc_directive(r13); } else {
		r0 = TOKEN_NOT; if(r0 == r1){ process_notminus_directive(r13); } else {
		r0 = TOKEN_MINUS; if(r0 == r1){ process_notminus_directive(r13); } else {
		r0 = HASH_exit+HASH_OFFSET; if(r0 == r1){ process_exit_directive(r13); } else {
		r0 = HASH_return+HASH_OFFSET; if(r0 == r1){ process_exit_directive(r13); } else {
		r0 = TOKEN_PREPARSER; if(r0 == r1){ process_token_preparser(r13);} else {
			//default;
			//if(DEBUG)
				//printf("Processing Default: - token index = %d; i = %d\n", token, i);
			if(r12){
				echo_string(STDOUT, 'Processing Default: - token index = ');
				echo_integer(STDOUT, r14);
				echo_string(STDOUT, '; i = ');
				echo_integer(STDOUT, r13);
				echo_string(STDOUT, '\n');
			}
			
			r0 = HASH_OFFSET;
			//if(token_stack[token] > HASH_OFFSET){
			if(r1 > r0){
				//if (((hash_table[token_stack[token]-HASH_OFFSET].token_type & TYPE_STRUC)==TYPE_STRUC) &&
					//(hash_table[token_stack[token]-HASH_OFFSET].struc_ptr != NULL)){
					//process_struc_def(i);
					//token = i;
					//break;
				//}
				r2 = r1 - r0;
				r3 = hash_table[r2].token_type;
				r4 = TYPE_STRUC;
				r3 = r3 && r4;
				if(r3 == r4){
					r3 = hash_table[r2].struc_ptr;
					if(r3){
						process_struc_def(r13);
						token = r13;
						r14 = r13;
						token = 0;
						//return(1);
						pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
						return(1);
					}
				}
			//}
			}
			
			//if(global == 0)
				//abort_b0("Unexpected instructions");
			r2 = global;
			r3 = 0;
			if(r2 == r3){
				abort_b0('Unexpected instructions');
			}
			
			//if ( token_stack[token] < TOKEN_ARRAY_START)
				//abort_b0("Invalid construct");
			r1 = [r15+r14*8];
			r2 = TOKEN_ARRAY_START;
			if(r1 < r2){
				abort_b0('Invalid construct');
			}
			
			// Determine if operation is an int or FP operation?
			//if (TS_is_int(i)){
				//process_int_operation(i);
			//} else {
				//process_fpu_operation(i);
			//}
			r0 = TS_is_int(r13);
			if(r0){
				process_int_operation(r13);
			} else {
				process_fpu_operation(r13);
			}
			//token = i;
			r14 = r13;
			token = r14;

		}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
		r14 = token;
	}
	//token = 0;
	token = 0;
	//return(1);
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
	return(1);
}

proc nextToken(){
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	//int i;
	//unsigned int UTF32;
	//while (isSpace(ch)) {
		//skip whitespace
		//getChar();
	//}
	r1 = ch;
	r0 = isSpace(r1);
	while (r0){
		getChar();
		r1 = ch;
		r0 = isSpace(r1);
	}
	//if (ch == '/') { // Skip comments
	r2 = CHAR_FSLASH;
	if(r1 == r2){
		r3 = look_ahead_ch;
		//if (look_ahead_ch == '/'){
		if(r3 == r2){
			//while ((ch != CR)&&(ch != '\r')&&(ch != 0xffffffff)){
				//getChar();
			//}
			r0 = 0;
			r4 = CHAR_CR;
			r5 = CHAR_LF;
			r8 = -1;
			if(r1 != r4){ 
				if(r1 != r5){
					if(r1 != r8){
						r0 = 1;
					}
				}
			}
			while (r0){
				getChar();
				r1 = ch;
				r0 = 0;
				if(r1 != r4){ 
					if(r1 != r5){
						if(r1 != r8){
							r0 = 1;
						}
					}
				}
			}
			//return(0);
			pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
			return(0);
		//}
		}
	//}
	}
	r1 = ch;
	r2 = isDigit(r1);
	r3 = isAlpha(r1);
	r2 = r2 + r3;
	r0 = 0;
	if(r2 == r0){
	//if (!isDigit(ch) && !isAlpha(ch)) {
		//process operator
		//switch(ch) {
		r2 = CHAR_SQUOT;
		if(r1 == r2){
			//case '\'' :
				//insert_token_stack(TOKEN_STRING);
				insert_token_stack(TOKEN_STRING);
				r12 = DEBUG;
				//if(DEBUG)
					//printf("START STRING\n");
				if(r12){
					echo_string(STDOUT, 'START STRING\n');
				}
				//getChar();
				getChar();
				r1 = ch;
				r2 = CHAR_SQUOT;
				//while (ch != '\'') {
				while(r1 != r2){
					//if (ch == '\\') {
					r3 = CHAR_BSLASH;
					if(r1 == r3){
						r3 = look_ahead_ch;
						//switch (look_ahead_ch) {
						r4 = CHAR_n;
						if(r3 == r4){
							//case 'n' :
								//insert_token_stack(CR);
								insert_token_stack(CHAR_LF);
								//getChar();
								//getChar();
								getChar();
								getChar();
								//if(DEBUG)
									//printf("Output 0x%x , ch == %c\n", CH, ch);
								if(r12){
									echo_string(STDOUT, 'Output ');
									echo_hex(STDOUT, CHAR_LF);
									echo_string(STDOUT, ' , ch == ');
									echo_character(STDOUT, r1);
									echo_string(STDOUT, '\n');
								}
								//break;
								
						} else {
						r4 = CHAR_r;
						if(r3 == r4){
							//case 'r' :
								//insert_token_stack(LF);
								insert_token_stack(CHAR_CR);
								//getChar();
								//getChar();
								getChar();
								getChar();
								//if(DEBUG)
									//printf("Output 0x%x , ch == %c\n", LF, ch);
								if(r12){
									echo_string(STDOUT, 'Output ');
									echo_hex(STDOUT, CHAR_CR);
									echo_string(STDOUT, ' , ch == ');
									echo_character(STDOUT, r1);
									echo_string(STDOUT, '\n');
								}
								//break;
								
						} else {
						r4 = CHAR_t;
						if(r3 == r4){
							//case 't' :
								//insert_token_stack(TAB);
								insert_token_stack(CHAR_HT);
								//getChar();
								//getChar();
								getChar();
								getChar();
								//if(DEBUG)
									//printf("Output 0x%x , ch == %c\n", TAB, ch);
								if(r12){
									echo_string(STDOUT, 'Output ');
									echo_hex(STDOUT, CHAR_HT);
									echo_string(STDOUT, ' , ch == ');
									echo_character(STDOUT, r1);
									echo_string(STDOUT, '\n');
								}
								//break;
								
						} else {
						r4 = CHAR_BSLASH;
						if(r3 == r4){
							//case '\\' :
								//insert_token_stack('\\');
								insert_token_stack(CHAR_BSLASH);
								//getChar();
								//getChar();
								getChar();
								getChar();
								//if(DEBUG)
									//printf("Output \\, ch == %c\n", ch);
								if(r12){
									echo_string(STDOUT, 'Output \\ , ch == ');
									echo_character(STDOUT, r1);
									echo_string(STDOUT, '\n');
								}
								//break;
								
						} else {
						r4 = CHAR_SQUOT;
						if(r3 == r4){
							//case '\'' :
								//insert_token_stack('\'');
								insert_token_stack(CHAR_SQUOT);
								//getChar();
								//getChar();
								getChar();
								getChar();
								//if(DEBUG)
									//printf("Output \', ch == %c\n", ch);
								if(r12){
									echo_string(STDOUT, 'Output \' , ch == ');
									echo_character(STDOUT, r1);
									echo_string(STDOUT, '\n');
								}
								//break;
								
						} else {
						r4 = CHAR_0;
						if(r3 == r4){
							//case '\0' :
								//insert_token_stack('\0');
								insert_token_stack(0);
								//getChar();
								//getChar();
								getChar();
								getChar();
								//if(DEBUG)
									//printf("Output NULL, ch == NULL\n");
								if(r12){
									echo_string(STDOUT, 'Output NULL, ch == NULL\n');
								}
								//break;
						} else {
							//default :
								//insert_token_stack((unsigned int) ch);
								insert_token_stack(r1);
								//getChar();
								getChar();
								//break;
						//}
						}}}}}}
						r1 = ch;
					//} else {
					} else {
						//if (ch == 0xffffffff)
						r3 = -1;
						if(r1 == r3){
							//return(0);
							pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
							return(0);
						}
						// What we need to do is handle UTF-8 input correctly.
						r3 = 07fh;
						//if (ch < 0x7f) {
						if(r1 < r3){
							//insert_token_stack((unsigned int) ch);
							insert_token_stack(r1);
						//} else {
						} else {
							// We must have a UTF-8 character.
							r3 = 0dfh;
							///if (ch < 0xdf) {
							if(r1 < r3){
								// we have a 2 byte sequence
								//UTF32 = (unsigned int) ch & 0x1f;
								r4 = r1 && 01fh;
								//UTF32 = UTF32 << 6;
								r4 = r4 << 6;
								//getChar(); // Get our second character
								getChar();
								//if (ch < 0x7f)
									//abort_b0("Poor UTF-8 construct");
								r1 = ch;
								r3 = 07fh;
								if(r1 < r3){
									abort_b0('Poor UTF-8 construct');
								}
								//UTF32 = UTF32 + (ch & 0x3f);
								r1 = r1 && 03fh;
								r4 = r4 + r1;
								//insert_token_stack(UTF32);
								insert_token_stack(r4);
							//} else {
							} else {
								r3 = 0f0h;
								//if (ch < 0xf0) {
								if(r1 < r3){
									// We have a 3 byte sequence
									//UTF32 = (unsigned int) ch & 0x0f;
									r4 = r1 && 0fh;
									//UTF32 = UTF32 << 6;
									r4 = r4 << 6;
									//getChar(); // Get our second character
									getChar();
									//if ((unsigned int) ch < 0x7f)
										//abort_b0("Poor UTF-8 construct");
									r1 = ch;
									r3 = 07fh;
									if(r1 < r3){
										abort_b0('Poor UTF-8 construct');
									}
									//UTF32 = UTF32 + ((unsigned int)ch & 0x3f);
									r1 = r1 && 03fh;
									r4 = r4 + r1;
									//UTF32 = UTF32 << 6;
									r4 = r4 << 6;
									//getChar(); // Get our third character
									getChar();
									//if ((unsigned int) ch < 0x7f)
										//abort_b0("Poor UTF-8 construct");
									r1 = ch;
									r3 = 07fh;
									if(r1 < r3){
										abort_b0('Poor UTF-8 construct');
									}
									//UTF32 = UTF32 + ((unsigned int)ch & 0x3f);
									r1 = r1 && 03fh;
									r4 = r4 + r1;
									//insert_token_stack(UTF32);
									insert_token_stack(r4);
								//} else {
								} else {
									// We must have a 4 byte sequence
									//UTF32 = (unsigned int) ch & 0x0f;
									r4 = r1 && 0fh;
									//UTF32 = UTF32 << 6;
									r4 = r4 << 6;
									//getChar(); // Get our second character
									getChar();
									//if ((unsigned int) ch < 0x7f)
										//abort_b0("Poor UTF-8 construct");
									r1 = ch;
									r3 = 07fh;
									if(r1 < r3){
										abort_b0('Poor UTF-8 construct');
									}
									//UTF32 = UTF32 + ((unsigned int) ch & 0x3f);
									r1 = r1 && 03fh;
									r4 = r4 + r1;
									//UTF32 = UTF32 << 6;
									r4 = r4 << 6;
									//getChar(); // Get our second character
									getChar();
									//if ((unsigned int) ch < 0x7f)
										//abort_b0("Poor UTF-8 construct");
									r1 = ch;
									r3 = 07fh;
									if(r1 < r3){
										abort_b0('Poor UTF-8 construct');
									}
									//UTF32 = UTF32 + ((unsigned int) ch & 0x3f);
									r1 = r1 && 03fh;
									r4 = r4 + r1;
									//UTF32 = UTF32 << 6;
									r4 = r4 << 6;
									//getChar(); // Get our second character
									getChar();
									//if ((unsigned int) ch < 0x7f)
										//abort_b0("Poor UTF-8 construct");
									r1 = ch;
									r3 = 07fh;
									if(r1 < r3){
										abort_b0('Poor UTF-8 construct');
									}
									//UTF32 = UTF32 + ((unsigned int) ch & 0x3f);
									r1 = r1 && 03fh;
									r4 = r4 + r1;
									//insert_token_stack(UTF32);
									insert_token_stack(r4);
								//}
								}
							//}
							}
						//}
						}
						//getChar();
						getChar();
					//}
					}
					r1 = ch;
					r2 = CHAR_SQUOT;
				//}
				}
				//insert_token_stack(TOKEN_END_STRING);
				insert_token_stack(TOKEN_END_STRING);
				r12 = DEBUG;
				//if(DEBUG)
					//printf("END STRING\n");
				if(r12){
					echo_string(STDOUT, 'END STRING\n');
				}
				//break;
		} else {
			r2 = CHAR_OCPARAN;
			if(r1 == r2){
			//case '{' :
				//return(2);
				pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
				return(2);
				//break;
				
		} else {
			r2 = CHAR_CCPARAN;
			if(r1 == r2){
			//case '}' :
				//insert_token_stack(TOKEN_BLOCK_END);
				insert_token_stack(TOKEN_BLOCK_END);
				//break;
				
		} else {
			r2 = CHAR_SCOLON;
			if(r1 == r2){
			//case ';' :
				//getChar();
				//return(1);
				getChar();
				pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
				return(1);
				//break;
				
		} else {
			r2 = CHAR_EQU;
			if(r1 == r2){
			//case '=' :
				//if (look_ahead_ch == '=') {
					//getChar();
					//insert_token_stack(TOKEN_EQUALS);
				//} else {
					//insert_token_stack(TOKEN_EQUATE);
				//}
				r3 = look_ahead_ch;
				if(r3 == r2){
					getChar();
					insert_token_stack(TOKEN_EQUALS);
				} else {
					insert_token_stack(TOKEN_EQUATE);
				}
				//break;	
				
		} else {
			r2 = CHAR_AMP;
			if(r1 == r2){
			//case '&' :
				//if (look_ahead_ch == '&') {
					//getChar();
					//insert_token_stack(TOKEN_AND);
				//} else {
					//insert_token_stack(TOKEN_POINTER);
				//}
				r3 = look_ahead_ch;
				if(r3 == r2){
					getChar();
					insert_token_stack(TOKEN_AND);
				} else {
					insert_token_stack(TOKEN_POINTER);
				}
				
				//break;
				
		} else {
			r2 = CHAR_VL;
			if(r1 == r2){
			//case '|' :
				//insert_token_stack(TOKEN_OR);
				insert_token_stack(TOKEN_OR);
				//break;

		} else {
			r2 = CHAR_CARAT;
			if(r1 == r2){
			//case '^' :
				//insert_token_stack(TOKEN_XOR);
				insert_token_stack(TOKEN_XOR);
				//break;
				
		} else {
			r2 = CHAR_EXCL;
			if(r1 == r2){
			//case '!' :
				//if (look_ahead_ch == '=') {
					//getChar();
					//insert_token_stack(TOKEN_NOTEQUALS);
				//} else {
					//insert_token_stack(TOKEN_NOT);
				//}
				r3 = look_ahead_ch;
				r4 = CHAR_EQU;
				if(r3 == r4){
					getChar();
					insert_token_stack(TOKEN_NOTEQUALS);
				} else {
					insert_token_stack(TOKEN_NOT);
				}
				//break;
				
		} else {
			r2 = CHAR_ASTX;
			if(r1 == r2){
			//case '*' :
				//insert_token_stack(TOKEN_MULTIPLY);
				insert_token_stack(TOKEN_MULTIPLY);
				//break;
				
		} else {
			r2 = CHAR_PLUS;
			if(r1 == r2){
			//case '+' :
				//insert_token_stack(TOKEN_ADD);
				insert_token_stack(TOKEN_ADD);
				//break;
				
		} else {
			r2 = CHAR_MINUS;
			if(r1 == r2){
			//case '-' :
				//insert_token_stack(TOKEN_MINUS);
				insert_token_stack(TOKEN_MINUS);
				//break;
				
		} else {
			r2 = CHAR_FSLASH;
			if(r1 == r2){
			//case '/' :
				//insert_token_stack(TOKEN_DIVIDE);
				insert_token_stack(TOKEN_DIVIDE);
				//break;
				
		} else {
			r2 = CHAR_PERCENT;
			if(r1 == r2){
			//case '%' :
				//insert_token_stack(TOKEN_MODULUS);
				insert_token_stack(TOKEN_MODULUS);
				//break;
				
		} else {
			r2 = CHAR_OPARAN;
			if(r1 == r2){
			//case '(' :
				//insert_token_stack(TOKEN_PARA_START);
				insert_token_stack(TOKEN_PARA_START);
				//break;
				
		} else {
			r2 = CHAR_CPARAN;
			if(r1 == r2){
			//case ')' :
				//insert_token_stack(TOKEN_PARA_END);
				insert_token_stack(TOKEN_PARA_END);
				//break;
		} else {
			r2 = CHAR_SOPARAN;
			if(r1 == r2){
			//case '[' :
				//insert_token_stack(TOKEN_ARRAY_START);
				insert_token_stack(TOKEN_ARRAY_START);
				//break;
				
		} else {
			r2 = CHAR_SCPARAN;
			if(r1 == r2){
			//case ']' :
				//insert_token_stack(TOKEN_ARRAY_END);
				insert_token_stack(TOKEN_ARRAY_END);
				//break;
				
		} else {
			r2 = CHAR_LT;
			if(r1 == r2){
			//case '<' :
				r3 = look_ahead_ch;
				//if (look_ahead_ch == '<') {
				if(r3 == r2){
					//getChar();
					getChar();
					r3 = look_ahead_ch;
					//if (look_ahead_ch == '<') {
					if(r3 == r2){
						//getChar();
						getChar();
						//insert_token_stack(TOKEN_LROTATE);
						insert_token_stack(TOKEN_LROTATE);
					//} else {
					} else {
						//insert_token_stack(TOKEN_LSHIFT);
						insert_token_stack(TOKEN_LSHIFT);
					//}
					}
				//} else {
				} else {
					r2 = CHAR_EQU;
					//if (look_ahead_ch == '=') {
					if(r3 == r2){
						//getChar();
						getChar();
						//insert_token_stack(TOKEN_LESSTHANEQUALS);
						insert_token_stack(TOKEN_LESSTHANEQUALS);
					//} else {
					} else {
						//insert_token_stack(TOKEN_LESSTHAN);
						insert_token_stack(TOKEN_LESSTHAN);
					//}
					}
				//}
				}
				//break;
				
		} else {
			r2 = CHAR_GT;
			if(r1 == r2){
			//case '>' :
				r3 = look_ahead_ch;
				//if (look_ahead_ch == '>') {
				if(r3 == r2){
					//getChar();
					getChar();
					r3 = look_ahead_ch;
					//if (look_ahead_ch == '>') {
					if(r3 == r2){
						//getChar();
						getChar();
						//insert_token_stack(TOKEN_RROTATE);
						insert_token_stack(TOKEN_RROTATE);
					//} else {
					} else {
						//insert_token_stack(TOKEN_RSHIFT);
						insert_token_stack(TOKEN_RSHIFT);
					//}
					}
				//} else {
				} else {
					r2 = CHAR_EQU;
					//if (look_ahead_ch == '=') {
					if(r3 == r2){
						//getChar();
						getChar();
						//insert_token_stack(TOKEN_GREATERTHANEQUALS);
						insert_token_stack(TOKEN_GREATERTHANEQUALS);
					//} else {
					} else {
						//insert_token_stack(TOKEN_GREATERTHAN);
						insert_token_stack(TOKEN_GREATERTHAN);
					//}
					}
				//}
				}
				//break;

		} else {
			r2 = CHAR_COMMA;
			if(r1 == r2){
			//case ',' :
			    //insert_token_stack(TOKEN_COMMA);
				insert_token_stack(TOKEN_COMMA);
				//break;

		} else {
			r2 = CHAR_STOP;
			if(r1 == r2){
			//case '.' :
			    //insert_token_stack(TOKEN_FULLSTOP);
				insert_token_stack(TOKEN_FULLSTOP);
				//break;

		} else {
			r2 = CHAR_HASH;
			if(r1 == r2){
			//case '#' :
			    //insert_token_stack(TOKEN_PREPARSER);
				insert_token_stack(TOKEN_PREPARSER);
				//break;

		} else {
			r2 = CHAR_TILDE;
			if(r1 == r2){
			//case '~' :	//Signed operation
				//switch(look_ahead_ch){
				r3 = look_ahead_ch;
				r4 = CHAR_GT;
				if(r3 == r4){
					//case '>' : getChar();
								getChar();
								r3 = look_ahead_ch;
								r4 = CHAR_EQU;
								//if (look_ahead_ch == '=') {
								if(r3 == r4){
									//getChar();
									getChar();
									//insert_token_stack(TOKEN_S_GREATERTHANEQUALS);
									insert_token_stack(TOKEN_S_GREATERTHANEQUALS);
								//} else {
								} else {
									//insert_token_stack(TOKEN_S_GREATERTHAN);
									insert_token_stack(TOKEN_S_GREATERTHAN);
								//}
								}
								//break;
								
				} else {
					
					r4 = CHAR_LT;
					if(r3 == r4){
					//case '<' : getChar();
								getChar();
								r3 = look_ahead_ch;
								r4 = CHAR_EQU;
								//if (look_ahead_ch == '=') {
								if(r3 == r4){
									//getChar();
									getChar();
									//insert_token_stack(TOKEN_S_LESSTHANEQUALS);
									insert_token_stack(TOKEN_S_LESSTHANEQUALS);
								//} else {
								} else {
									//insert_token_stack(TOKEN_S_LESSTHAN);
									insert_token_stack(TOKEN_S_LESSTHAN);
								//}
								}
								//break;
				} else {
					
					r4 = CHAR_ASTX;
					if(r3 == r4){
								
					//case '*' : getChar(); 
								getChar();
								//insert_token_stack(TOKEN_S_MULTIPLY); 
								insert_token_stack(TOKEN_S_MULTIPLY);
								//break;
								
				} else {
					
					r4 = CHAR_FSLASH;
					if(r3 == r4){
					//case '/' : getChar(); 
								getChar();
								//insert_token_stack(TOKEN_S_DIVIDE); 
								insert_token_stack(TOKEN_S_DIVIDE);
								//break;
								
				} else {
					
					r4 = CHAR_PERCENT;
					if(r3 == r4){
					//case '%' : getChar(); 
								getChar();
								//insert_token_stack(TOKEN_S_MODULUS); 
								insert_token_stack(TOKEN_S_MODULUS);
								//break;
								
				} else {
					//default :
						//abort_b0("Unknown Signed operation");
						abort_b0('Unknown Signed operation');
						//break;
				//}
				}}}}}
				//break;

		} else {
				//default :
				//if (ch == 0xffffffff){
					//return(1);
				//}
				r1 = ch;
				r3 = look_ahead_ch;
				r2 = -1;
				if(r1 == r2){
					pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
					return(1);
				}
				r2 = 0efh;
				if(r1 == r2){
					r4 = 0bbh;
					if(r3 == r4){
				//if ((ch == 0xef) && (look_ahead_ch == 0xbb)) {
					// we may have a BOM
						//getChar(); // Get the next char
						getChar();
						//if (look_ahead_ch != 0xbf)
							//abort_b0("Unknown Symbol - BOM");
						r3 = look_ahead_ch;
						r4 = 0bfh;
						if(r3 != r4){
							abort_b0('Unknown Symbol - BOM');
						}
						//getChar(); // Move the BOM indicator 0xbf into ch.
						getChar();
					} else {
						abort_b0('Unknown Symbol - UNK');
					}
				//} else {
				} else {
					//printf("ch = 0x%x, lch = 0x%x\n", ch, look_ahead_ch);
					//abort_b0("Unknown Symbol - UNK");
					abort_b0('Unknown Symbol - UNK');
				//}
				}
				//break;
		//}
		}}}}}}}}}}}}}}}}}}}}}}}}
		//getChar();
		getChar();
	//} else {
	} else {
		r2 = isDigit(r1);
		//if (isDigit(ch)){
		if(r2){
			//process digit
			//insert_token_stack((unsigned int)ch);
			insert_token_stack(r1);
			//getChar();
			getChar();
			r1 = ch;
			r2 = isXDigit(r1);
			r0 = 0;
			if(r2){ r0 = 1; }
			r3 = CHAR_STOP;
			if(r1 == r3){ r0 = 1; }
			while (r0){
			//while ((isXDigit(ch)) || (ch == '.')) {
				//insert_token_stack((unsigned int)tolower(ch));
				r4 = tolower(r1);
				insert_token_stack(r4);
				//getChar();
				getChar();
				r1 = ch;
				r2 = isXDigit(r1);
				r0 = 0;
				if(r2){ r0 = 1; }
				r3 = CHAR_STOP;
				if(r1 == r3){ r0 = 1; }
			}
			//}
			//if ((ch == 'h')||(ch == 'H')){ // Include terminating 'h' if found?
				//insert_token_stack('h');
				//getChar();
			//}
			r0 = 0;
			r2 = CHAR_h;
			if(r1 == r2) { r0 = 1; }
			r2 = CHAR_H;
			if(r1 == r2) { r0 = 1; }
			if(r0){
				insert_token_stack(CHAR_h);
				getChar();
				r1 = ch;
			}
			//if (isAlpha(ch)){
				//abort_b0("Unexpected Alpha");
			//}
			r2 = isAlpha(r1);
			if(r2){
				abort_b0('Unexpected Alpha');
			}
		//} else {
		} else {
			//process token
			
			//Clear our token buffer
			//for (i = 0; i < TOKEN_MAX_SIZE; i++) {
				//token_buffer[i] = 0;
			//}
			
			r13 = &token_buffer;
			r0 = 0;
			r1 = 0;
			r11 = TOKEN_MAX_SIZE;
			while (r1 < r11){
				[r13+r1] = r0b;
				r1 = r1 + 1;
			}
			
			// copy our input into the buffer
			//toki = 0;
			r1 = 0; 
			r2 = ch;
			r3 = isAlpha(r2);
			r4 = isDigit(r2);
			r3 = r3 + r4;
			//while (isAlpha(ch) || isDigit(ch)) {
			while(r3){
				//token_buffer[toki] = (unsigned char) (ch & 0xff);
				//r2 = r2 && 0ffh;
				[r13+r1] = r2b;
				//toki++;
				r1 = r1 + 1;
				//if (toki >= TOKEN_MAX_SIZE) abort_b0("INTERNAL: Token Preprocessor Buffer Overflow! - Increase TOKEN_MAX_SIZE");
				if(r1 >= r11){
					abort_b0('INTERNAL: Token Preprocessor Buffer Overflow! - Increase TOKEN_MAX_SIZE');
				}
				//getChar();
				getChar();
				r2 = ch;
				r3 = isAlpha(r2);
				r4 = isDigit(r2);
				r3 = r3 + r4;
			//}
			}
			// get the hash
			//token_hash = (ElfHash(&token_buffer[0])) % HASH_TABLE_SIZE + 1; //Can't have tokens = 0
			r0 = ElfHash(r13);
			r3 = r0;
			//echo_string(STDOUT, 'ELFHash = ');
			//echo_hex(STDOUT, r3);
			//echo_string(STDOUT, '\n');
			r0 = r3;
			r2 = HASH_TABLE_SIZE;
			r3 = r3 ^ r3;
			r0 = r0 % r2;
			r0 = r0 + 1;
			//if (token_hash >= (HASH_TABLE_SIZE-1)) token_hash = 1;
			
			r2 = r2 - 1;
			if (r0 >= r2) { r0 = 1; }
			
			r1 = r0;		//r1 = token_hash
			//echo_string(STDOUT, 'Adjusted Hash = ');
			//echo_hex(STDOUT, r1);
			//echo_string(STDOUT, '\n');
			r0 = 0;
			r2 = hash_table[r1].hash;
			// Check for collision?
			//if (hash_table[token_hash].hash == 0){
			if(r2 == r0){
				// No entry, so we just enter the hash into the table
				//hash_table[token_hash].hash = token_hash;
				hash_table[r1].hash = r1;
				//strcpy((char *) hash_table[token_hash].token, ( char *) token_buffer);
				r3 = &hash_table[r1].token;
				r13 = r13 - 2;
				strcpy(r3, r13);
				r13 = r13 + 2;
				r12 = DEBUG;
				//if(DEBUG)
					//printf("TOKEN : %s = 0x%lx\n", hash_table[token_hash].token, hash_table[token_hash].hash);
				if(r12){
					echo_string(STDOUT, 'TOKEN : ');
					echo_string(STDOUT, r3);
					echo_string(STDOUT, ' = ');
					echo_hex(STDOUT, r1);
					echo_string(STDOUT, '\n');
				}
			} else {
			//} else {
				// Let's see if we have the same string
				r3 = &hash_table[r1].token;
				r13 = r13 - 2;
				r0 = strcmp(r13, r3);
				//if (strcmp((char *) token_buffer, ( char *) hash_table[token_hash].token)) {
				if(r0){
					// If the string are different, then we have a real problem!
					//if(DEBUG)
						//printf("Hash Collision Detected 0x%lx = %s = %s\n", token_hash, hash_table[token_hash].token, token_buffer);
					r12 = DEBUG;
					if(r12){
						echo_string(STDOUT, 'Hash Collision Detected ');
						echo_hex(STDOUT, r1);
						echo_string(STDOUT, ' = ');
						echo_string(STDOUT, r3);
						echo_string(STDOUT, ' = ');
						echo_string(STDOUT, r13);
						echo_string(STDOUT, '\n');
					}
					//i = 0;
					r5 = 0;
					r9 = 0;
					r0 = 0;
					if(r2 != r9) { 
						r10 = strcmp(r13, r3);
						if(r10) { 
							r0 = 1;
						}
					}
					r11 = HASH_TABLE_SIZE - 1;
					//while ((hash_table[token_hash].hash != 0) && strcmp((char *) token_buffer, ( char *) hash_table[token_hash].token)) {
					while(r0){
						//token_hash++; // Linear refactor the hash!
						r1 = r1 + 1;
						//echo_string(STDOUT, 'New HASH = ');
						//echo_hex(STDOUT, r1);
						//echo_string(STDOUT, '\n');
						//i++;
						r5 = r5 + 1;
						//if (i >= HASH_TABLE_SIZE-1) {
						if(r5 >= r11){
							//if(DEBUG){
							if(r12){
								r11 = r11 + 1;
								//printf("HASH TABLE----------\n");
								echo_string(STDOUT, 'HASH TABLE----------\n');
								r5 = 0;
								//for (i = 0; i < HASH_TABLE_SIZE; i++) {
									//if (hash_table[i].hash != 0)
										//printf("0x%x -> 0x%lx = %s\n", i, hash_table[i].hash, hash_table[i].token);
								//};
								while(r5 < r11){
									r1 = hash_table[r5].hash;
									if(r1){
										echo_hex(STDOUT, r5);
										echo_string(STDOUT, ' -> ');
										echo_hex(STDOUT, r1);
										echo_string(STDOUT, ' = ');
										r0 = &hash_table[r5].token;
										echo_string(STDOUT, r0);
										echo_string(STDOUT, '\n');
									}
									r5 = r5 + 1;
								}
							//}
							}
							//abort_b0("INTERNAL: Hash Table Overflow! - Increase HASH_TABLE_SIZE");
							abort_b0('INTERNAL: Hash Table Overflow! - Increase HASH_TABLE_SIZE');
						//}
						}
						//if (token_hash >= HASH_TABLE_SIZE-1) {
							//token_hash = 1; // Wrap around so we don't go off the table
						//}
						if(r1 >= r11){
							r1 = 1;
						}
						r3 = &hash_table[r1].token;
						r2 = hash_table[r1].hash;
						r0 = 0;
						if(r2 != r9) { 
							r10 = strcmp(r13, r3);  // r13 = &token_buffer, r3 = hash_table[token_hash].token;
							if(r10) { 
								r0 = 1;
							}
						}
					//}
					}
					//hash_table[token_hash].hash = token_hash;
					hash_table[r1].hash = r1;
					r3 = &hash_table[r1].token;
					//strcpy((char *) hash_table[token_hash].token, ( char *) token_buffer);
					
					strcpy(r3, r13);
					//if(DEBUG)
						//printf("TOKEN : %s = 0x%lx\n", hash_table[token_hash].token, hash_table[token_hash].hash);
					if(r12){
						echo_string(STDOUT, 'TOKEN : ');
						echo_string(STDOUT, r3);
						echo_string(STDOUT, ' = ');
						echo_hex(STDOUT, r1);
						echo_string(STDOUT, '\n');
					}
				//}
				}
			//}
			}
			//insert_token_stack(token_hash+HASH_OFFSET);
			r1 = r1 + HASH_OFFSET;
			insert_token_stack(r1);
		//}
		}
	//}
	}
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
	return(0);
};

proc end_block_else(){
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	//unsigned int old_block_num;
	//block_level--;
	r12 = DEBUG;
	r15 = block_level;
	r15 = r15 - 1;
	block_level = r15;
	//if (DEBUG)
		//printf("EBE_ current block level is %d\n", block_level);
	if(r12){
		echo_string(STDOUT, 'EBE_ Current Block Level is ');
		echo_integer(STDOUT, r15);
		echo_string(STDOUT, '\n');
	}
	r0 = 1;
	//if (block_level < 1)
		//abort_b0("Unexpected }");
	if(r15 < r0){
		abort_b0('Unexpected }');
	}
	//if (block_level == 1) {
	if(r15 == r0){
		//abort_b0("Unexpected ELSE");
		abort_b0('Unexpected ELSE');
	//} else {
	} else {
		r1 = if_while_stack[r15].type;
		r2 = HASH_if;
		//if (if_while_stack[block_level].type == HASH_if) {
		if(r1 == r2){
			// Lets terminate the if statement
			//old_block_num = if_while_stack[block_level].offset;
			r4 = if_while_stack[r15].offset;
			//if_while_stack[block_level].offset = block_num;
			r1 = block_num;
			if_while_stack[r15].offset = r1;
			r14 = code;
			//fprintf(code, "\tjmp .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset);
			echo_string(r14, '\tjmp .B0_END_BLOCK_0000');
			echo_integer(r14, r1);
			echo_string(r14, '\n');
			//fprintf(code, "\t.B0_END_BLOCK_0000%d:\n", old_block_num);
			echo_string(r14, '\t.B0_END_BLOCK_0000');
			echo_integer(r14, r4);
			echo_string(r14, ':\n');
		//} else {
		} else {
			r2 = HASH_while;
			//if (if_while_stack[block_level].type == HASH_while)
				//abort_b0("Unexpected ELSE");
			if(r1 == r2){
				abort_b0('Unexpected ELSE');
			}
		//}
		}
	//}
	}
	//return(0);
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
	return(0);
};

proc end_block(){
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	r15 = code;
	r14 = data;
	r13 = bss;
	r12 = DEBUG;
	r11 = block_level;
	//block_level--;
	r11 = r11 - 1;
	block_level = r11;
	//if(DEBUG)
		//printf("EB_ Current Block Level is %d\n", block_level);
	if(r12){
		echo_string(STDOUT, 'EB_ Current Block Level is ');
		echo_integer(STDOUT, r11);
		echo_string(STDOUT, '\n');
	}
	r0 = 1;
	//if (block_level < 1)
		//abort_b0("Unexpected }");
	if(r11 < r0){
		abort_b0('Unexpected }');
	}
	//if (block_level == 1) {
	if(r11 == r0){
		r1 = global;
		//if (global != 0){  // If global == 0 then we must be in a struc?
		if(r1){
			r1 = r1 - HASH_OFFSET;
			r2 = &hash_table[r1].token;
			//fprintf(code, "\tmov r0, 0\n\tret\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n");
			//fprintf(code, "; End %s Function Code;\n", hash_table[(global-HASH_OFFSET)].token);
			//fprintf(code, ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n");
			echo_string(r15, '\tmov r0, 0\n\tret\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n');
			echo_string(r15, '; End ');
			echo_string(r15, r2);
			echo_string(r15, ' Function Code;\n');
			echo_string(r15, ';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n');
			
			//fprintf(data, "\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n");
			//fprintf(data, "; End %s Function Variables ;\n", hash_table[(global-HASH_OFFSET)].token);
			//fprintf(data, ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n");				
			echo_string(r14, '\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n');
			echo_string(r14, '; End ');
			echo_string(r14, r2);
			echo_string(r14, ' Function Variables ;\n');
			echo_string(r14, ';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n');
			//fprintf(bss,  "\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n");
			//fprintf(bss,  "; End %s Function BSS Variables ;\n", hash_table[(global-HASH_OFFSET)].token);
			//fprintf(bss,  ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n");				
			echo_string(r13, '\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n');
			echo_string(r13, '; End ');
			echo_string(r13, r2);
			echo_string(r13, ' Function BSS Variables ;\n');
			echo_string(r13, ';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n');
			//hash_table[(global-HASH_OFFSET)].local_offset = local_var_offset;
			r3 = local_var_offset;
			hash_table[r1].local_offset = r3;
			//global = 0;
			global = 0;
		//}
		}
	//} else {
	} else {
		// We most likely have ended a if or a while. Let's ensure that we terminate the block 
		// correctly.
		r1 = if_while_stack[r11].type;
		r2 = HASH_if;
		//if (if_while_stack[block_level].type == HASH_if) {
		if(r1 == r2){
			// Lets terminate the if statement
			//fprintf(code, "\t.B0_END_BLOCK_0000%d:\n", if_while_stack[block_level].offset);
			r3 = if_while_stack[r11].offset;
			echo_string(r15, '\t.B0_END_BLOCK_0000');
			echo_integer(r15, r3);
			echo_string(r15, ':\n');
		//} else {
		} else {
			r2 = HASH_while;
			//if (if_while_stack[block_level].type == HASH_while) {
			if(r1 == r2){
				// Lets terminate the while block correctly
				r3 = if_while_stack[r11].if_while_test1;
				r4 = hash_table[r3].token_type;
				r5 = TYPE_FLAG;
				//if (hash_table[if_while_stack[block_level].if_while_test1].token_type == TYPE_FLAG) {
				if(r4 == r5){
					// We have a flag comparison, so this is really easy.
					//switch(if_while_stack[block_level].if_while_test1){
					r5 = HASH_CARRY;
					if(r3 == r5){
						//case HASH_CARRY: fprintf(code, "\tjc .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
						//r15 = code;
						echo_string(r15, '\tjc .B0_END_BLOCK_0000');
					} else {
						r5 = HASH_NOCARRY;
						if(r3 == r5){
						//case HASH_NOCARRY: fprintf(code, "\tjnc .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
						echo_string(r15, '\tjnc .B0_END_BLOCK_0000');
					} else {
						r5 = HASH_OVERFLOW;
						if(r3 == r5){
						//case HASH_OVERFLOW: fprintf(code, "\tjo .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
						echo_string(r15, '\tjo .B0_END_BLOCK_0000');
					} else {
						r5 = HASH_NOOVERFLOW;
						if(r3 == r5){
						//case HASH_NOOVERFLOW: fprintf(code, "\tjno .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
						echo_string(r15, '\tjno .B0_END_BLOCK_0000');
					} else {
						r5 = HASH_PARITY;
						if(r3 == r5){
						//case HASH_PARITY: fprintf(code, "\tjp .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
						echo_string(r15, '\tjp .B0_END_BLOCK_0000');
					} else {
						r5 = HASH_NOPARITY;
						if(r3 == r5){
						//case HASH_NOPARITY: fprintf(code, "\tjnp .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
						echo_string(r15, '\tjnp .B0_END_BLOCK_0000');
					} else {
						r5 = HASH_ZERO;
						if(r3 == r5){
						//case HASH_ZERO: 	fprintf(code, "\tjz .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
						echo_string(r15, '\tjz .B0_END_BLOCK_0000');
					} else {
						r5 = HASH_NOTZERO;
						if(r3 == r5){
						//case HASH_NOTZERO: fprintf(code, "\tjnz .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
						echo_string(r15, '\tjnz .B0_END_BLOCK_0000');
					} else {
						r5 = HASH_SIGN;
						if(r3 == r5){
						//case HASH_SIGN: 	fprintf(code, "\tjs .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
						echo_string(r15, '\tjs .B0_END_BLOCK_0000');
					} else {
						r5 = HASH_NOTSIGN;
						if(r3 == r5){
						//case HASH_NOTSIGN: fprintf(code, "\tjns .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
						echo_string(r15, '\tjns .B0_END_BLOCK_0000');
					} else {
						//default: abort_b0("Unknown CPU FLAG"); break;
						abort_b0('Unknown CPU FLAG');
					//}
					}}}}}}}}}}
					r1 = if_while_stack[r11].offset;
					r1 = r1 - 1;
					echo_integer(r15, r1);
					echo_string(r15, '\n\t.B0_END_BLOCK_0000');
					r1 = r1 + 1;
					echo_integer(r15, r1);
					echo_string(r15, ':\n');
				//} else {
				} else {
					r5 = TYPE_REG;
					//if (hash_table[if_while_stack[block_level].if_while_test1].token_type == TYPE_REG) {
					if(r4 == r5){
						// Int test
						//if ((hash_table[if_while_stack[block_level].if_while_test2].token_type != TYPE_REG) && (if_while_stack[block_level].if_while_test2 != HASH_zero))
							//abort_b0("Second operand MUST be a integer register");
						r1 = if_while_stack[r11].if_while_test2;
						r2 = HASH_zero;
						if(r1 != r2){
							r4 = hash_table[r1].token_type;
							if(r4 != r5){
								abort_b0('Second operand MUST be a integer register');
							}
						}
						//if (if_while_stack[block_level].if_while_test2 != HASH_zero) {
						if(r1 != r2){
							//fprintf(code, "\tcmp %s, %s\n", hash_table[if_while_stack[block_level].if_while_test1].token, hash_table[if_while_stack[block_level].if_while_test2].token );
							// r3 = test1; r1 = test2;
							echo_string(r15, '\tcmp ');
							r0 = &hash_table[r3].token;
							echo_string(r15, r0);
							echo_string(r15, ', ');
							r0 = &hash_table[r1].token;
							echo_string(r15, r0);
							echo_string(r15, '\n');
						//} else {
						} else {
							//fprintf(code, "\ttest %s, %s\n", hash_table[if_while_stack[block_level].if_while_test1].token, hash_table[if_while_stack[block_level].if_while_test1].token );
							echo_string(r15, '\ttest ');
							r0 = &hash_table[r3].token;
							echo_string(r15, r0);
							echo_string(r15, ', ');
							r0 = &hash_table[r3].token;
							echo_string(r15, r0);
							echo_string(r15, '\n');
						//}
						}
						r3 = if_while_stack[r11].comparison;
						//switch (if_while_stack[block_level].comparison) {
						r5 = TOKEN_EQUALS;
						if(r3 == r5){
							//case TOKEN_EQUALS :	fprintf(code, "\tje .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
							echo_string(r15, '\tje .B0_END_BLOCK_0000');
						} else {
							r5 = TOKEN_NOTEQUALS;
							if(r3 == r5){
							//case TOKEN_NOTEQUALS : fprintf(code, "\tjne .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
							echo_string(r15, '\tjne .B0_END_BLOCK_0000');
						} else {
							r5 = TOKEN_LESSTHAN;
							if(r3 == r5){
							//case TOKEN_LESSTHAN : fprintf(code, "\tjb .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset);	break;
							echo_string(r15, '\tjb .B0_END_BLOCK_0000');
						} else {
							r5 = TOKEN_GREATERTHAN;
							if(r3 == r5){
							//case TOKEN_GREATERTHAN : fprintf(code, "\tja .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
							echo_string(r15, '\tja .B0_END_BLOCK_0000');
						} else {
							r5 = TOKEN_LESSTHANEQUALS;
							if(r3 == r5){
							//case TOKEN_LESSTHANEQUALS : fprintf(code, "\tjbe .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset);	break;
							echo_string(r15, '\tjbe .B0_END_BLOCK_0000');
						} else {
							r5 = TOKEN_GREATERTHANEQUALS;
							if(r3 == r5){
							//case TOKEN_GREATERTHANEQUALS : fprintf(code, "\tjae .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
							echo_string(r15, '\tjae .B0_END_BLOCK_0000');
						} else {
							r5 = TOKEN_S_LESSTHAN;
							if(r3 == r5){
							//case TOKEN_S_LESSTHAN : fprintf(code, "\tjl .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset);	break;
							echo_string(r15, '\tjl .B0_END_BLOCK_0000');
						} else {
							r5 = TOKEN_S_GREATERTHAN;
							if(r3 == r5){
							//case TOKEN_S_GREATERTHAN : fprintf(code, "\tjg .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
							echo_string(r15, '\tjg .B0_END_BLOCK_0000');
						} else {
							r5 = TOKEN_S_LESSTHANEQUALS;
							if(r3 == r5){
							//case TOKEN_S_LESSTHANEQUALS : fprintf(code, "\tjle .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset);	break;
							echo_string(r15, '\tjle .B0_END_BLOCK_0000');
						} else {
							r5 = TOKEN_S_GREATERTHANEQUALS;
							if(r3 == r5){
							//case TOKEN_S_GREATERTHANEQUALS : fprintf(code, "\tjge .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
							echo_string(r15, '\tjge .B0_END_BLOCK_0000');
						} else {
							abort_b0('Unknown Comparison');
						//}
						}}}}}}}}}}
						r1 = if_while_stack[r11].offset;
						r1 = r1 - 1;
						echo_integer(r15, r1);
						echo_string(r15, '\n\t.B0_END_BLOCK_0000');
						r1 = r1 + 1;
						echo_integer(r15, r1);
						echo_string(r15, ':\n');
					//} else {
					} else {
						// FPU test
						r1 = if_while_stack[r11].if_while_test1;
						r4 = if_while_stack[r11].if_while_test2;
						r5 = HASH_zero;
						//if (if_while_stack[block_level].if_while_test2 != HASH_zero){
						if(r4 != r5){
							// Non-zero test
							//if (if_while_stack[block_level].if_while_test1 != HASH_fp0)
								//abort_b0("Floating point comparison requires that fp0 be the first operand");
							r5 = HASH_fp0;
							if(r1 != r5){
								abort_b0('Floating point comparison requires that fp0 be the first operand');
							}
							//if (hash_table[if_while_stack[block_level].if_while_test2].token_type != TYPE_REG_FPU)
								//abort_b0("Second operand MUST be a FPU register");
							r0 = hash_table[r4].token_type;
							r5 = TYPE_REG_FPU;
							if(r0 != r5){
								abort_b0('Second operand MUST be a FPU register');
							}
							//fprintf(code, "\tfcomi %s\n", hash_table[if_while_stack[block_level].if_while_test2].token );
							echo_string(r15, '\tfcomi ');
							r0 = &hash_table[r4].token;
							echo_string(r15, r0);
							echo_string(r15, '\n');
							//switch (if_while_stack[block_level].comparison) {
							r3 = if_while_stack[r11].comparison;
							r5 = TOKEN_EQUALS;
							if(r3 == r5){
								//case TOKEN_EQUALS :	fprintf(code, "\tje .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
								echo_string(r15, '\tje .B0_END_BLOCK_0000');
							} else {
								r5 = TOKEN_NOTEQUALS;
								if(r3 == r5){
								//case TOKEN_NOTEQUALS : fprintf(code, "\tjne .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
								echo_string(r15, '\tjne .B0_END_BLOCK_0000');
							} else {
								r5 = TOKEN_LESSTHAN;
								if(r3 == r5){
								//case TOKEN_LESSTHAN : fprintf(code, "\tjb .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset);	break;
								echo_string(r15, '\tjb .B0_END_BLOCK_0000');
							} else {
								r5 = TOKEN_GREATERTHAN;
								if(r3 == r5){
								//case TOKEN_GREATERTHAN : fprintf(code, "\tja .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
								echo_string(r15, '\tja .B0_END_BLOCK_0000');
							} else {
								r5 = TOKEN_LESSTHANEQUALS;
								if(r3 == r5){
								//case TOKEN_LESSTHANEQUALS : fprintf(code, "\tjbe .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset);	break;
								echo_string(r15, '\tjbe .B0_END_BLOCK_0000');
							} else {
								r5 = TOKEN_GREATERTHANEQUALS;
								if(r3 == r5){
								//case TOKEN_GREATERTHANEQUALS : fprintf(code, "\tjae .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
								echo_string(r15, '\tjae .B0_END_BLOCK_0000');
							} else {
								r5 = TOKEN_S_LESSTHAN;
								if(r3 == r5){
								//case TOKEN_S_LESSTHAN : fprintf(code, "\tjb .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset);	break;
								echo_string(r15, '\tjb .B0_END_BLOCK_0000');
							} else {
								r5 = TOKEN_S_GREATERTHAN;
								if(r3 == r5){
								//case TOKEN_S_GREATERTHAN : fprintf(code, "\tja .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
								echo_string(r15, '\tja .B0_END_BLOCK_0000');
							} else {
								r5 = TOKEN_S_LESSTHANEQUALS;
								if(r3 == r5){
								//case TOKEN_S_LESSTHANEQUALS : fprintf(code, "\tjbe .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset);	break;
								echo_string(r15, '\tjbe .B0_END_BLOCK_0000');
							} else {
								r5 = TOKEN_S_GREATERTHANEQUALS;
								if(r3 == r5){
								//case TOKEN_S_GREATERTHANEQUALS : fprintf(code, "\tjae .B0_END_BLOCK_0000%d\n\t.B0_END_BLOCK_0000%d:\n", (if_while_stack[block_level].offset-1), if_while_stack[block_level].offset); break;
								echo_string(r15, '\tjae .B0_END_BLOCK_0000');
							} else {
								abort_b0('Unknown Comparison');
							//}					
							}}}}}}}}}}
							r1 = if_while_stack[r11].offset;
							r1 = r1 - 1;
							echo_integer(r15, r1);
							echo_string(r15, '\n\t.B0_END_BLOCK_0000');
							r1 = r1 + 1;
							echo_integer(r15, r1);
							echo_string(r15, ':\n');
						//} else {
						} else {
							// Handle test against zero
							r4 = hash_table[r3].token_type;
							r5 = TYPE_REG_FPU;
							//if (hash_table[if_while_stack[block_level].if_while_test1].token_type != TYPE_REG_FPU)
								//abort_b0("Operand MUST be a register");
							if (r4 != r5){
								abort_b0('Operand MUST be a register');
							}
							//fprintf(code, "\tfldz\n\tfcomip ");
							echo_string(r15, '\tfldz\n\tfcomip ');
							//switch(if_while_stack[block_level].if_while_test1){
							r5 = HASH_fp0;
							if(r3 == r5){
								//case HASH_fp0: fprintf(code, "fp1\n"); break;
								echo_string(r15,'fp1\n');
							} else {
								r5 = HASH_fp1;
								if(r3 == r5){
								//case HASH_fp1: fprintf(code, "fp2\n"); break;
								echo_string(r15,'fp2\n');
							} else {
								r5 = HASH_fp2;
								if(r3 == r5){
								//case HASH_fp2: fprintf(code, "fp3\n"); break;
								echo_string(r15,'fp3\n');
							} else {
								r5 = HASH_fp3;
								if(r3 == r5){
								//case HASH_fp3: fprintf(code, "fp4\n"); break;
								echo_string(r15,'fp4\n');
							} else {
								r5 = HASH_fp4;
								if(r3 == r5){
								//case HASH_fp4: fprintf(code, "fp5\n"); break;
								echo_string(r15,'fp5\n');
							} else {
								r5 = HASH_fp5;
								if(r3 == r5){
								//case HASH_fp5: fprintf(code, "fp6\n"); break;
								echo_string(r15,'fp6\n');
							} else {
								r5 = HASH_fp6;
								if(r3 == r5){
								//case HASH_fp6: fprintf(code, "fp7\n"); break;
								echo_string(r15,'fp7\n');
							} else {
								r5 = HASH_fp7;
								if(r3 == r5){
								//case HASH_fp7: abort_b0("Error FPU stack overflow in WHILE construct"); break;
								abort_b0('Error FPU stack overflow in WHILE construct');
							}}}}}}}}
							//}
							//fprintf(code, "\tjne .B0_END_BLOCK_0000%d\n", if_while_stack[block_level].offset-1);
							r1 = if_while_stack[r11].offset;
							r1 = r1 - 1;
							echo_string(r15, '\tjne .B0_END_BLOCK_0000');
							echo_integer(r15, r1);
							echo_string(r15, '\n');
							//fprintf(code, "\t.B0_END_BLOCK_0000%d:\n", if_while_stack[block_level].offset);
							r1 = r1 + 1;
							echo_string(r15, '\t.B0_END_BLOCK_0000');
							echo_integer(r15, r1);
							echo_string(r15, ':\n');
							
						//}
						}
					//}
					}
				//}
				}
			//}
			}
		//}
		}
		//if_while_stack[block_level].type = 0;
		if_while_stack[r11].type = 0;
		// Else fall through
	//}
	}
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
	return(0);
};

proc block(){
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	//unsigned int do_process = 0;
	r9 = 0;
	//block_level++;
	r15 = block_level;
	r15 = r15 + 1;
	block_level = r15;
	r14 = DEBUG;
	//if(DEBUG)
		//printf("BLOCK_ Current Block Level is %d\n", block_level);
	if(r14){
		echo_string(STDOUT, 'BLOCK_ Current Block Level is ');
		echo_integer(STDOUT, r15);
		echo_string(STDOUT, '\n');
	}
	//if (block_level >= TOKEN_STACK_SIZE)
		//abort_b0("INTERNAL: Block Level is too large - too many nested blocks - Increase TOKEN_STACK_SIZE");
	r0 = TOKEN_STACK_SIZE;
	if(r15 >= r0){
		abort_b0('INTERNAL: Block Level is too large - too many nested blocks - Increase TOKEN_STACK_SIZE');
	}
	//block_num++;
	r13 = block_num;
	r13 = r13 + 1;
	block_num = r13;
	//getChar();				// Get next character
	getChar();
	r1 = ch;
	r2 = -1;
	//if (ch ==  0xffffffff) { //If EOF
	if(r1 == r2){
		if(r14){ echo_string(STDOUT, 'Closing file\n'); }
		//fclose(file[file_stack_ptr].handle); // Close current file
		r3 = file_stack_ptr;
		r4 = file[r3].handle;
		_fclose(r4);
		//file_stack_ptr--;	//Move the file stack pointer down one
		r3 = r3 - 1;
		file_stack_ptr = r3;
		if(r14){ echo_string(STDOUT, 'file_stack_ptr = '); echo_hex(STDOUT, r3); echo_string(STDOUT, '\n'); }
		//if (file_stack_ptr < 0) {
		r4 = 0;
		if(r3 ~< r4){
			pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
			//return(0);		// If we are now off the stack, exit
			//echo_string(STDOUT, 'Here\n');
			return(0);
		//} else {
		} else {
			//ch = file[file_stack_ptr].ch;
			r0 = file[r3].ch;
			ch = r0;
			//look_ahead_ch = file[file_stack_ptr].look_ahead_ch;
			r0 = file[r3].look_ahead_ch;
			look_ahead_ch = r0;
		//}
		}
		//process_token_stack();
		process_token_stack();
							// else process remaining tokens to flush the stack
							// before moving onto another file
		//block_level--;
		r15 = block_level;
		r15 = r15 - 1;
		block_level = r15;
		if(r14){
			echo_string(STDOUT, 'BLOCK_ Current Block Level is now ');
			echo_integer(STDOUT, r15);
			echo_string(STDOUT, ' after flush\n');
		}
	//}
	}
	r1 = ch;
	r2 = -1;
	//while (ch != 0xffffffff) {
	while(r1 != r2){
		//do_process = nextToken();
		r9 = nextToken();
		//if (DEBUG) 
			//printf("do_process = 0x%x, token = 0x%x\n", do_process, token);
		r8 = token;
		r14 = DEBUG;
		if(r14){
			echo_string(STDOUT, 'block_do_process = ');
			echo_hex(STDOUT, r9);
			echo_string(STDOUT, ', token = ');
			echo_hex(STDOUT, r8);
			echo_string(STDOUT, ', Block Level = ');
			r15 = block_level;
			echo_hex(STDOUT, r15);
			echo_string(STDOUT, '\n');
		}
		r0 = 0;
		//if (token != 0){
		if(r8 != r0){
			//switch(do_process){
			r0 = 1;
			if(r9 == r0){
				//case 1 : process_token_stack(); break;		// get the next token, and set token variable
				process_token_stack();
			} else {
				r0 = 2;
				if(r9 == r0){
				//case 2 : process_token_stack(); block(); break;
					process_token_stack(); 
					block();
				}
			}
			//}
		//}
		}
		//do_process = 0;
		r9 = 0;
		r1 = ch;
		r2 = -1;
	//}
	}
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
	//echo_string(STDOUT, 'Here2\n');
	return(0);
};

proc include_standard_output(){
	push r1;
	r1 = file[0].handle;
	#ifndef i386;
	echo_string(r1, '\n;Register renaming\n\nr0 equ rax\nr0d equ eax\nr0w equ ax\nr0b equ al\n');
	echo_string(r1, 'r1 equ rbx\nr1d equ ebx\nr1w equ bx\nr1b equ bl\n');
	echo_string(r1, 'r2 equ rcx\nr2d equ ecx\nr2w equ cx\nr2b equ cl\n');
	echo_string(r1, 'r3 equ rdx\nr3d equ edx\nr3w equ dx\nr3b equ dl\n');
	echo_string(r1, 'r4 equ rdi\nr4d equ edi\nr4w equ di\nr4b equ dil\n');
	echo_string(r1, 'r5 equ rsi\nr5d equ esi\nr5w equ si\nr5b equ sil\n');
	echo_string(r1, 'r6 equ rbp\nr6d equ ebp\nr6w equ bp\nr6b equ bpl\n');
	echo_string(r1, 'r7 equ rsp\nr7d equ esp\nr7w equ sp\nr7b equ spl\n\n');
	#else;
	echo_string(r1, '\n;Register renaming\n\nr0 equ eax\nr0w equ ax\nr0b equ al\n');
 	echo_string(r1, 'r1 equ ebx\nr1w equ bx\nr1b equ bl\n');
 	echo_string(r1, 'r2 equ ecx\nr2w equ cx\nr2b equ cl\n');
 	echo_string(r1, 'r3 equ edx\nr3w equ dx\nr3b equ dl\n');
 	echo_string(r1, 'r4 equ edi\nr4w equ di\n');
 	echo_string(r1, 'r5 equ esi\nr5w equ si\n');
 	echo_string(r1, 'r6 equ ebp\nr6w equ bp\n');
 	echo_string(r1, 'r7 equ esp\nr7w equ sp\n\n');
	#endif;
	
	echo_string(r1, 'fp0 equ ST0\nfp1 equ ST1\nfp2 equ ST2\nfp3 equ ST3\n');
	echo_string(r1, 'fp4 equ ST4\nfp5 equ ST5\nfp6 equ ST6\nfp7 equ ST7\n\n');
	

	echo_string(r1, ';Default Macros\n');
	echo_string(r1, 'macro UTF16_STRING name, [string]\n{\n');
	echo_string(r1, 'common\n\tname:\nlocal label,label2\n\tlabel:\n');
	echo_string(r1, '\tdw ((label2-label)/2)-3\n\tdw ((label2-label)/2)-3\n');
	echo_string(r1, '\tdw string\n\tlabel2:\n\tdw 0\n}\n\n');
	echo_string(r1, 'macro UTF8_STRING name, [string]\n{\n');
	echo_string(r1, 'common\n\tname:\nlocal label,label2\n\tlabel:\n');
	echo_string(r1, '\tdb ((label2-label)/2)-3\n\tdb ((label2-label)/2)-3\n');
	echo_string(r1, '\tdb string\n\tlabel2:\n\tdb 0\n}\n\n');
	pop r1;
};

proc include_public_extrns(){
	push r1, r2, r3, r4, r5;
	//unsigned int i;
	r1 = 0;
	r5 = file[0].handle;
	r2 = HASH_TABLE_SIZE;
	//for (i = 0; i < HASH_TABLE_SIZE; i++) {
	while (r1 < r2){
		//if ((hash_table[i].hash != 0)&&(hash_table[i].token_type == TYPE_PROC)){
		r0 = 0;
		r3 = hash_table[r1].hash;
		if(r3 != r0){
			r3 = hash_table[r1].token_type;
			r0 = TYPE_PROC;
			if(r3 == r0){
				r4 = 036768h;
				//if (i == 0x36768) {
				if(r1 == r4){
					//fprintf(file[0].handle, "public _B0_%s as 'main'\n", hash_table[i].token);
					echo_string(r5, 'public _B0_');
					r0 = &hash_table[r1].token;
					echo_string(r5, r0);
					echo_string(r5, ' as \'main\'\n');
				//} else {
				} else {
					//fprintf(file[0].handle, "public _B0_%s\n", hash_table[i].token);
					echo_string(r5, 'public _B0_');
					r0 = &hash_table[r1].token;
					echo_string(r5, r0);
					echo_string(r5, '\n');
				//}
				}
		//}
		}}
		r1 = r1 + 1;
	//};
	}
	//fprintf(file[0].handle, "\n\n");
	echo_string(r5, '\n\n');
	//for (i = 0; i < HASH_TABLE_SIZE; i++) {
		//if ((hash_table[i].hash != 0)&&(hash_table[i].token_type == TYPE_EPROC))
			//fprintf(file[0].handle, "extrn %s\n", hash_table[i].token);
	//};
	r1 = 0;
	while(r1 < r2){
		r0 = 0;
		r3 = hash_table[r1].hash;
		if(r3 != r0){
			r3 = hash_table[r1].token_type;
			r0 = TYPE_EPROC;
			if(r3 == r0){
				echo_string(r5, 'extrn ');
				r0 = &hash_table[r1].token;
				echo_string(r5, r0);
				echo_string(r5, '\n');
			}
		}
		r1 = r1 + 1;
	}
	//fprintf(file[0].handle, "\n\n");
	echo_string(r5, '\n\n');
	//for (i = 0; i < HASH_TABLE_SIZE; i++) {
		//if ((hash_table[i].hash != 0)&&(hash_table[i].token_type == 0))
			//fprintf(file[0].handle, "extrn _B0_%s\n", hash_table[i].token);
	//};
	r1 = 0;
	while(r1 < r2){
		r0 = 0;
		r3 = hash_table[r1].hash;
		if(r3 != r0){
			r3 = hash_table[r1].token_type;
			if(r3 == r0){
				echo_string(r5, 'extrn _B0_');
				r0 = &hash_table[r1].token;
				echo_string(r5, r0);
				echo_string(r5, '\n');
			}
		}
		r1 = r1 + 1;
	}
	pop r5, r4, r3, r2, r1;
};

proc include_public_extrns_pe(){
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	//unsigned int i = 0, j = 0;
	r15 = file[0].handle;
	r14 = HASH_TABLE_SIZE;
	r13 = DEBUG;
	
	// Let's start by scanning the hash_table and ensuring each EPROC has a parent ELIB defined
	//for (i = 0; i < HASH_TABLE_SIZE; i++) {
		//if (hash_table[i].token_type == TYPE_EPROC){
			//if (hash_table[i].token_import_lib == 0x0)
				//abort_b0("External Procedure has not been linked to a parent DLL");		
		//}
	//};	
	r0 = 0;
	r1 = r0;
	r2 = TYPE_EPROC;
	while (r1 < r14){
		r3 = hash_table[r1].token_type;
		if(r3 == r2){
			r4 = hash_table[r1].token_import_lib;
			if(r4 == r0){
				abort_b0('External Procedure has not been linked to a parent DLL');
			}
		}
		r1 = r1 + 1;
	}
	//for (i = 0; i < HASH_TABLE_SIZE; i++) {
		//if ((hash_table[i].token_type == TYPE_ELIB))
			//fprintf(file[0].handle, "dd 0,0,0, RVA %s_name, RVA %s_table\n", hash_table[i].token, hash_table[i].token);
	//};	
	r1 = 0;
	r2 = TYPE_ELIB;
	while (r1 < r14){
		r3 = hash_table[r1].token_type;
		if (r3 == r2){
			r4 = &hash_table[r1].token;
			echo_string(r15, 'dd 0,0,0, RVA ');
			echo_string(r15, r4);
			echo_string(r15, '_name, RVA ');
			echo_string(r15, r4);
			echo_string(r15, '_table\n');
		}
		r1 = r1 + 1;
	}

	//fprintf(file[0].handle, "dd 0,0,0,0,0\n\n");
	echo_string(r15, 'dd 0,0,0,0,0\n\n');

	r1 = 0;
	//for (i = 0; i < HASH_TABLE_SIZE; i++) {
	while(r1 < r14){
		r3 = hash_table[r1].token_type;
		//if ((hash_table[i].token_type == TYPE_ELIB)){
		if(r3 == r2){
			//fprintf(file[0].handle, "%s_table:\n", hash_table[i].token);
			r4 = &hash_table[r1].token;
			echo_string(r15, r4);
			echo_string(r15, '_table:\n"');
			r8 = 0;
			//for (j = 0; j < HASH_TABLE_SIZE; j++){
			while(r8 < r14){
				r9 = hash_table[r8].token_import_lib;
				//if (hash_table[j].token_import_lib == i){
				if(r9 == r1){
					// That is this token is matched to a known ELIB!
					r10 = &hash_table[r8].token;
					//#ifndef i386
					#ifndef i386;
					//fprintf(file[0].handle, "\t%s dq RVA _%s\n", hash_table[j].token, hash_table[j].token);
					echo_string(r15, '\t');
					echo_string(r15, r10);
					echo_string(r15, ' dq RVA _');
					echo_string(r15, r10);
					echo_string(r15, '\n');
					//#else
					#else;
					//fprintf(file[0].handle, "\t%s dd RVA _%s\n", hash_table[j].token, hash_table[j].token);
					echo_string(r15, '\t');
					echo_string(r15, r10);
					echo_string(r15, ' dd RVA _');
					echo_string(r15, r10);
					echo_string(r15, '\n');
					//#endif
					#endif;
				//}
				}
				r8 = r8 + 1;
			//}
			}
			//#ifndef i386
			#ifndef i386;
			//fprintf(file[0].handle, "\tdq 0\n\n");
			echo_string(r15, '\tdq 0\n\n');
			//#else
			#else;
			//fprintf(file[0].handle, "\tdd 0\n\n");
			echo_string(r15, '\tdd 0\n\n');
			//#endif
			#endif;
		//}
		}
		r1 = r1 + 1;
	//};
	}

	r1 = 0;
	//for (i = 0; i < HASH_TABLE_SIZE; i++) {
	while(r1 < r14){
		r3 = hash_table[r1].token_type;
		//if ((hash_table[i].token_type == TYPE_ELIB)){
		if(r3 == r2){
			//if (DEBUG)
				//printf("%s is '%s',0\n", hash_table[i].token, hash_table[i].token_import_name);
			if(r13){
				r0 = &hash_table[r1].token;
				echo_string(STDOUT, r0);
				echo_string(STDOUT, ' is \'');
				r0 = &hash_table[r1].token_import_name;
				echo_string(STDOUT, r0);
				echo_string(STDOUT, '\',0\n');
			}
			r0 = 0;
			r4 = hash_table[r1].token_import_name;
			r4 = r4 && 0ffh;
			//if (hash_table[i].token_import_name[0] == 0x0)
			if(r4 == r0){
				//abort_b0("External Library has not had DLL name defined");
				abort_b0('External Library has not had DLL name defined');
			}
			//fprintf(file[0].handle, "%s_name db '%s',0\n", hash_table[i].token, hash_table[i].token_import_name);
			r0 = &hash_table[r1].token;
			echo_string(r15, r0);
			echo_string(r15, '_name db \'');
			r0 = &hash_table[r1].token_import_name;
			echo_string(r15, r0);
			echo_string(r15, '\',0\n');
		//}
		}
		r1 = r1 + 1;
	//};		
	}
	//fprintf(file[0].handle, "\n");
	echo_string(r15, '\n');

	r1 = 0;
	r2 = TYPE_EPROC;
	//for (i = 0; i < HASH_TABLE_SIZE; i++) {
	while(r1 < r14){
		r3 = hash_table[r1].token_type;
		//if ((hash_table[i].token_type == TYPE_EPROC)){
		if(r3 == r2){
			//if (DEBUG)
				//printf("%s is '%s',0\n", hash_table[i].token, hash_table[i].token_import_name);
			if(r13){
				r0 = &hash_table[r1].token;
				echo_string(STDOUT, r0);
				echo_string(STDOUT, ' is \'');
				r0 = &hash_table[r1].token_import_name;
				echo_string(STDOUT, r0);
				echo_string(STDOUT, '\',0\n');
			}
			r0 = 0;
			r4 = hash_table[r1].token_import_name;
			r4 = r4 && 0ffh;
			//if (hash_table[i].token_import_name[0] == 0x0)
			if(r4 == r0){
				//abort_b0("External Procedure has not had a name defined");
				abort_b0('External Procedure has not had a name defined');
			}
			//fprintf(file[0].handle, "_%s dw 0\n\tdb '%s',0\n", hash_table[i].token, hash_table[i].token_import_name);
			echo_string(r15, '_');
			r0 = &hash_table[r1].token;
			echo_string(r15, r0);
			echo_string(r15, ' dw 0\n\tdb \'');
			r0 = &hash_table[r1].token_import_name;
			echo_string(r15, r0);
			echo_string(r15, '\',0\n');
		//}
		}
		r1 = r1 + 1;
	//};
	}
			
	//fprintf(file[0].handle, "\n\n");
	echo_string(r15, '\n\n');
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
};

proc main(){
	#ifdef LINUX;
	argc = r4;					// On application initialisation argc = edi
	argv = r5;					// and argv = rsi
	r6 = memInit();
	#endif;
	
	#ifdef UNIX_LIBC;			// I must assume that all other UNIX systems
	argc = r4;					// are using the SYS V 64bit ABI for x86-64.
	argv = r5;
	r6 = memInit();
	__Init_libc();				// Set our default file handles so that we
								// can talk to libc!
	#endif;
	
	#ifdef WIN64;				// Windows x64 still uses the x86 32bit ABI
	r0 = [r7-24];				// for 64bit applications! Way to go MS :P
	argc = r0;
	r0 = [r7-16];
	argv = r0;
	#endif;						// No need to call memInit() on Win64 as this 
								// Setup for us automatically.
	
	push r1, r2, r3, r4, r5, r8, r9, r10, r11, r12 ,r13, r14, r15;
	//#ifdef _MSC_VER
		//long long int i;
	//#else
		//long int i;
	//#endif
	//unsigned int j;
	//unsigned char *pdest;
	//const unsigned char *ptr;
	//int Help = 0;
	//int Version = 0;
	//int have_file = 0;
	m64 pdest;
	m64 ptr;
	m64 Help;
	m64 Version;
	m64 have_file;
	
	pdest = 0;
	ptr = 0;
	Help = 0;
	Version = 0;
	have_file = 0;

	//total_paths = 0;
	total_paths = 0;

	//time_start = clock();
	r1 = _clock();
	time_start = r1;
	
	//pp_ptr = 0;
	//pp_GenCode[pp_ptr] = 1;				// We want to generate code.
	pp_ptr = 0;
	pp_GenCode[0] = 1;
	
		
	r1 = argc;
	r2 = argv;
	
	//echo_string(STDOUT, 'argc = ');
	//echo_integer(STDOUT, r1);
	//echo_string(STDOUT, '; argv = ');
	//echo_hex(STDOUT, r2);
	//echo_string(STDOUT, '\n');
	
	r0 = 1;
	//if(argc > 1){
	if(r1 > r0){
		r2 = 0;
		r3 = 0;
		r15 = argv;
		//for(i=0;i<argc;i++){
		while(r2 < r1){
			r5 = [r15+r2*8];  	// r5 is a POINTER THE STRING!
			//push r2;
			//echo_string(STDOUT, '&argv[');
			//echo_hex(STDOUT, r2);
			//echo_string(STDOUT, '] = ');
			//echo_hex(STDOUT, r5);
			//echo_string(STDOUT, ' ; "');
			//r5 = r5 - 2;  // We do this as echo_string(); expects a b0 type string.
			//echo_string(STDOUT, r5);
			//echo_string(STDOUT, '"\n');
			//r5 = r5 + 2;
			//if(!strcmp(argv[i], "-DEBUG"))
				//DEBUG = 1;
			r4 = _strcmp(r5, '-DEBUG');
			if(r4 == r3){
				DEBUG = 1;
				//echo_string(STDOUT, 'DEBUG Output has been set\n');
			}

			//if(!strcmp(argv[i], "-UTF8"))
				//{ UTF8_STRINGS = 1; CLI_UTF8_STRINGS = 1; }
			r4 = _strcmp(r5, '-UTF8');
			if(r4 == r3){
				UTF8_STRINGS = 1;
				CLI_UTF8_STRINGS = 1;
				//echo_string(STDOUT, 'UTF8 encoding has been set\n');
			}
			//if(!strcmp(argv[i], "-UTF16"))
				//{ UTF8_STRINGS = 0; CLI_UTF8_STRINGS = 1; }
			r4 = _strcmp(r5, '-UTF16');
			if(r4 == r3){
				UTF8_STRINGS = 0;
				CLI_UTF8_STRINGS = 1;
				//echo_string(STDOUT, 'UTF16 encoding has been set\n');
			}
			//if(!strcmp(argv[i], "-?"))
				//Help = 1;
			r4 = _strcmp(r5, '-?');
			if(r4 == r3){
				Help = 1;
				//echo_string(STDOUT, 'Help has been set\n');
			}
			//if(!strcmp(argv[i], "-h"))
				//Help = 1;
			r4 = _strcmp(r5, '-h');
			if(r4 == r3){
				Help = 1;
				//echo_string(STDOUT, 'Help has been set\n');
			}
			//if(!strcmp(argv[i], "-v"))
				//Version = 1;
			r4 = _strcmp(r5, '-v');
			if(r4 == r3){
				Version = 1;
				//echo_string(STDOUT, 'Version has been set\n');
			}
			//if(!strcmp(argv[i], "-l")){
				//PrintHeader();
				//PrintLicense();
				//exit(0);
			//}
			r4 = _strcmp(r5, '-l');
			if(r4 == r3){
				PrintHeader();
				PrintLicense();
				exit(0);
			}
			//if(!strcmp(argv[i], "-W"))
				//WarningsDisabled = 1;
			r4 = _strcmp(r5, '-W');
			if(r4 == r3){
				WarningsDisabled = 1;
			}
			//if(!strcmp(argv[i], "-!"))
				//ContinueOnAbort = 1;
			r4 = _strcmp(r5, '-!');
			if(r4 == r3){
				ContinueOnAbort = 1;
				//echo_string(STDOUT, 'ContinueOnAbort has been set\n');
			}
			//if((argv[i][0] == '-') && (argv[i][1] == 'i')){
				//path = &argv[i][2]; // Set pointer to the CLI environment
			//}
			r8 = r8 ^ r8;
			r8b = [r5];
			r9 = CHAR_MINUS;
			if(r8 == r9){
				r8b = [r5+1];
				r9 = CHAR_i;
				if(r8 == r9){
					r5 = r5 + 2;
					ptr_path = r5;
					//if(path) scan_env(path);
					scan_env(r5);
					//echo_string(STDOUT, '&Path = ');
					//echo_hex(STDOUT, r5);
					//echo_string(STDOUT, ' or ');
					//r5 = r5 - 2;
					//echo_string(STDOUT, r5);
					//r5 = r5 + 2;
					//echo_string(STDOUT, '\n');
					r5 = r5 - 2;
				}
			}
			//if((argv[i][0] == '-') && (argv[i][1] == 'f')){
			r8 = r8 ^ r8;
			r8b = [r5];
			r9 = CHAR_MINUS;
			if(r8 == r9){
				r8b = [r5+1];
				r9 = CHAR_f;
				if(r8 == r9){
					//Set the type of Source Output = SOURCE_TYPE
					//if(!strcmp(argv[i], "-felf")){
						//SOURCE_TYPE = SOURCE_ELF;
						//SOURCE_CLI = 1;
					r4 = _strcmp(r5, '-felf');
					if(r4 == r3){
						SOURCE_TYPE = SOURCE_ELF;
						SOURCE_CLI = 1;
						//echo_string(STDOUT, 'Source is ELF\n');
					} else {
					//} else {
						//if(!strcmp(argv[i], "-fpe")){
							//SOURCE_TYPE = SOURCE_PE;
							//SOURCE_CLI = 1;
						r4 = _strcmp(r5, '-fpe');
						if(r4 == r3){
							SOURCE_TYPE = SOURCE_PE;
							SOURCE_CLI = 1;
							//echo_string(STDOUT, 'Source is PE\n');
						} else {
						//} else {
							//if(!strcmp(argv[i], "-felfo")){
								//SOURCE_TYPE = SOURCE_ELFO;
								//SOURCE_CLI = 1;
							r4 = _strcmp(r5, '-felfo');
							if(r4 == r3){
								SOURCE_TYPE = SOURCE_ELFO;
								SOURCE_CLI = 1;
								//echo_string(STDOUT, 'Source is ELFO\n');
							} else {
							//} else {
								//PrintHeader();
								//printf("Error: Unknown Output Format?\n");
								//exit(1);
								PrintHeader();
								echo_string(STDOUT, 'Error: Unknown Output Format?\n');
								exit(-1);
							//}
							}
						//}
						}
					//}
					}
				}
			}

			//}
			//if((argv[i][0] != '-') && (i != 0) && (have_file == 0)){
				// Else let's assume for now that it's our filename?
				//strcpy((char *) filename,argv[i]);
				//have_file = 1;
			//}

			if(r3 != r2){
				r0 = have_file;
				if(r0 == r3){
					r8 = r8 ^ r8;
					r8b = [r5];
					r9 = CHAR_MINUS;
					if(r8 != r9){
						//strcpy((char *) filename,argv[i]);
						r10 = &filename;
						r5 = r5 - 2;
						strcpy(r10, r5);
						r5 = r5 + 2;
						//have_file = 1;
						have_file = 1;
						//echo_string(STDOUT, '&Filename = ');
						////echo_hex(STDOUT, r5);
						//echo_string(STDOUT, ' or ');
						//r5 = r5 - 2;
						//echo_string(STDOUT, r5);
						//r5 = r5 + 2;
						//echo_string(STDOUT, '\n');
						//r5 = r5 - 2;
					}
				}
			}
			//pop r2;
			r2 = r2 + 1;
		//}
		}
	//} else {
	} else {
		//PrintHelp();
		PrintHelp();
	//}
	}

	//if ((Help)||(!have_file)||(Version)){
		//if(Help)
			//PrintHelp();
		
		//if((!have_file)&&(!Version))
		//	PrintHelp();
		
		//PrintHeader();
		//if(!have_file)
			//exit(0);
	//}

	r0 = 0;
	r1 = have_file;
	if(r1 == r0){ r0 = 1; }
	r1 = Help;
	if(r1){ r0 = 1; }
	r1 = Version;
	if(r1){ r0 = 1; }
	if(r0){
		r1 = Help;
		if(r1){
			PrintHelp();
		}
		r0 = 0;
		r1 = have_file;
		if(r1 == r0){
			r1 = Version;
			if(r1 == r0){
				PrintHelp();
			}
		}
		PrintHeader();
		r0 = 0;
		r1 = have_file;
		if(r1 == r0){
			exit(0);
		}
	}
	

	//b0_env = getenv("B0_INCLUDE");
	r0 = _getenv('B0_INCLUDE');
	ptr_b0_env = r0;
	
	//if(b0_env) scan_env(b0_env);
	r0 = ptr_b0_env;
	if(r0){
		scan_env(r0);
	}
	// If you have any directories to include they should already be added.
	// total_paths = number of paths we can search!
	
	//if(DEBUG){
		//PrintHeader();
		//switch(SOURCE_TYPE){
			//case SOURCE_ELF: printf("Output Format: ELF Executable\n"); break;
			//case SOURCE_ELFO: printf("Output Format: ELF Object\n"); break;
			//case SOURCE_PE: printf("Output Format: PE\n"); break;
		//}
		//if (UTF8_STRINGS == 1){
			//printf("Strings will be encoded as UTF8\n");
		//} else {
			//printf("Strings will be encoded as UTF16\n");
		//}
		//for (j=0;j<total_paths;j++){
			//printf("search path = %s\n", paths[j]);
	//}
	r15 = DEBUG;
	if(r15){
		PrintHeader();
		r1 = SOURCE_TYPE;
		r2 = SOURCE_ELF;
		if(r1 == r2){
			echo_string(STDOUT, 'Output Format: ELF Executable\n');
		} else {
			r2 = SOURCE_ELFO;
			if(r1 == r2){
				echo_string(STDOUT, 'Output Format: ELF Object\n');
			} else {
				r2 = SOURCE_PE;
				if(r1 == r2){
					echo_string(STDOUT, 'Output Format: PE\n');
				}
			}
		}
		r1 = UTF8_STRINGS;
		r2 = 1;
		if(r1 == r2){
			echo_string(STDOUT, 'Strings will be encoded as UTF8\n');
		} else {
			echo_string(STDOUT, 'Strings will be encoded as UTF16\n');
		}
		r1 = 0;
		r2 = total_paths;
		while (r1 < r2){
			echo_string(STDOUT, 'search path = ');
			r3 = &paths[r1];
			echo_string(STDOUT, r3);
			echo_string(STDOUT, '\n');
			r1 = r1 + 1;
		}
	}

	//}
	
	//for (i = 0; i < HASH_TABLE_SIZE; i++) {
		//hash_table[i].hash = 0;
	//};
	r1 = 0;
	r2 = HASH_TABLE_SIZE;
	while (r1 < r2){
		hash_table[r1].hash = 0;
		r1 = r1 + 1;
	}

	//Setup reserved labels within the hash table...
	
	//ptr = TOKEN_KEYWORD;
	//while(*ptr){
		//insert_token(ptr, TYPE_KEYWORD);
		//while(*ptr++);
	//};
	r1 = &TOKEN_KEYWORD;
	r1 = r1 + 2;  // Point to the first char.
	r0 = r0 ^ r0;
	r0b = [r1];
	while(r0){
		insert_token(r1, TYPE_KEYWORD);
		r0 = r0 ^ r0;
		r0b = [r1];
		while(r0){
			r1 = r1 + 1;
			r0b = [r1];
		}
		r1 = r1 + 1;
		r0 = r0 ^ r0;
		r0b = [r1];
	}
	
	//ptr = TOKEN_REG;
	//while(*ptr){
		//insert_token(ptr, TYPE_REG);
		//while(*ptr++);
	//};
	r1 = &TOKEN_REG;
	r1 = r1 + 2;
	r0 = r0 ^ r0;
	r0b = [r1];
	while(r0){
		insert_token(r1, TYPE_REG);
		r0 = r0 ^ r0;
		r0b = [r1];
		while(r0){
			r1 = r1 + 1;
			r0b = [r1];
		}
		r1 = r1 + 1;
		r0 = r0 ^ r0;
		r0b = [r1];
	}
	//ptr = TOKEN_REG_SHORT;
	//while(*ptr){
		//insert_token(ptr, TYPE_REG_SHORT);
		//while(*ptr++);
	//};
	r1 = &TOKEN_REG_SHORT;
	r1 = r1 + 2;
	r0 = r0 ^ r0;
	r0b = [r1];
	while(r0){
		insert_token(r1, TYPE_REG_SHORT);
		r0 = r0 ^ r0;
		r0b = [r1];
		while(r0){
			r1 = r1 + 1;
			r0b = [r1];
		}
		r1 = r1 + 1;
		r0 = r0 ^ r0;
		r0b = [r1];
	}
	//ptr = TOKEN_REG_SHORT2;
	//while(*ptr){
		//insert_token(ptr, TYPE_REG_SHORT);
		//while(*ptr++);
	//};
	r1 = &TOKEN_REG_SHORT2;
	r1 = r1 + 2;
	r0 = r0 ^ r0;
	r0b = [r1];
	while(r0){
		insert_token(r1, TYPE_REG_SHORT);
		r0 = r0 ^ r0;
		r0b = [r1];
		while(r0){
			r1 = r1 + 1;
			r0b = [r1];
		}
		r1 = r1 + 1;
		r0 = r0 ^ r0;
		r0b = [r1];
	}
	//ptr = TOKEN_REG_FPU;
	//while(*ptr){
		//insert_token(ptr, TYPE_REG_FPU);
		//while(*ptr++);
	//};
	r1 = &TOKEN_REG_FPU;
	r1 = r1 + 2;
	r0 = r0 ^ r0;
	r0b = [r1];
	while(r0){
		insert_token(r1, TYPE_REG_FPU);
		r0 = r0 ^ r0;
		r0b = [r1];
		while(r0){
			r1 = r1 + 1;
			r0b = [r1];
		}
		r1 = r1 + 1;
		r0 = r0 ^ r0;
		r0b = [r1];
	}
	//ptr = TOKEN_FLAG;
	//while(*ptr){
		//insert_token(ptr, TYPE_FLAG);
		//while(*ptr++);
	//};
	r1 = &TOKEN_FLAG;
	r1 = r1 + 2;
	r0 = r0 ^ r0;
	r0b = [r1];
	while(r0){
		insert_token(r1, TYPE_FLAG);
		r0 = r0 ^ r0;
		r0b = [r1];
		while(r0){
			r1 = r1 + 1;
			r0b = [r1];
		}
		r1 = r1 + 1;
		r0 = r0 ^ r0;
		r0b = [r1];
	}
	//ptr = TOKEN_RESERVED;
	//while(*ptr){
		//insert_token(ptr, TYPE_RESERVED);
		//while(*ptr++);
	//};
	r1 = &TOKEN_RESERVED;
	r1 = r1 + 2; 
	r0 = r0 ^ r0;
	r0b = [r1];
	while(r0){
		insert_token(r1, TYPE_RESERVED);
		r0 = r0 ^ r0;
		r0b = [r1];
		while(r0){
			r1 = r1 + 1;
			r0b = [r1];
		}
		r1 = r1 + 1;
		r0 = r0 ^ r0;
		r0b = [r1];
	}
	
	//state = 0;			// Reset code state to null;
	//file_stack_ptr = 0;
	//local_var_offset = 0;
	//dynamic_string_count = 0; //Number of dynamic string decl.
	
	state = 0;
	file_stack_ptr = 0;
	local_var_offset = 0;
	dynamic_string_count = 0;
 
	//if(DEBUG)
		//printf("Filename = %s\n", filename);
	
	if(r15){
		echo_string(STDOUT, 'Filename = "');
		r0 = &filename;
		echo_string(STDOUT, r0);
		echo_string(STDOUT, '"\n');
	}
	r1 = &filename;
	//file[file_stack_ptr].handle = fopen((char *)filename, "r");

	r0 = _fopen(r1, 'r');
	r2 = file_stack_ptr;
	file[r2].handle = r0;
	
	r3 = 0;
	//if (!file[file_stack_ptr].handle){
	if(r0 == r3){
		//printf("ERROR: Unable to open file: %s\n", filename);
		echo_string(STDOUT, 'ERROR: Unable to open file: "');
		echo_string(STDOUT, r1);
		echo_string(STDOUT, '"\n');
		//exit(1);
		exit(-1);
	//} else {
	} else {
		//strcpy((char *) file[file_stack_ptr].filename, (char *)filename);
		r4 = &file[r2].filename;
		strcpy(r4, r1);
		//file[file_stack_ptr].line_count = 1;
		file[r2].line_count = 1;
	///};
	}
	
	// Open our first pass asm files
	//code = fopen("c_output.tmp", "w+");
	//data = fopen("d_output.tmp", "w+");
	//bss  = fopen("b_output.tmp", "w+");
	//if (!code){
		//printf("ERROR: Unable to create temp file");
		//exit(1);
	//}
	//if (!data){
		//printf("ERROR: Unable to create temp file");
		//exit(1);
	//}
	//if (!bss){
		//printf("ERROR: Unable to create temp file");
		//exit(1);
	//}

	r1 = 0;
	r0 = _fopen('c_output.tmp', 'w+');
	code = r0;
	if (r1 == r0){
		echo_string(STDOUT, 'ERROR: Unable to create code temp file');
		exit(-1);
	}
	r0 = _fopen('d_output.tmp', 'w+');
	data = r0;
	if (r1 == r0){
		echo_string(STDOUT, 'ERROR: Unable to create data temp file');
		exit(-1);
	}
	r0 = _fopen('b_output.tmp', 'w+');
	bss = r0;
	if (r1 == r0){
		echo_string(STDOUT, 'ERROR: Unable to create bss temp file');
		exit(-1);
	}

	if(r15){
		echo_string(STDOUT, 'Src Handle = ');
		r0 = file[0].handle;
		echo_hex(STDOUT, r0);
		echo_string(STDOUT, '\nCode Handle = ');
		r0 = code;
		echo_hex(STDOUT, r0);
		echo_string(STDOUT, '\nData Handle = ');
		r0 = data;
		echo_hex(STDOUT, r0);
		echo_string(STDOUT, '\nBSS Handle = ');
		r0 = bss;
		echo_hex(STDOUT, r0);
		echo_string(STDOUT, '\n');
	}
	
	
	//look_ahead_ch = 0; 	// Prime the current char buffer
	//token = 0;
	//global = 0;			// We start from a global level
	//block_level = 0;
	//block_num = 0;
	
	look_ahead_ch = 0; 	// Prime the current char buffer
	token = 0;
	global = 0;			// We start from a global level
	block_level = 0;
	block_num = 0;
	
	//while (file_stack_ptr >= 0) {
		// As long as we have a file to read, let's keep going
		//block();
	//}
	r1 = 0;
	r2 = file_stack_ptr;
	while(r2 ~>= r1){
		block();
		r1 = 0;
		r2 = file_stack_ptr;
	}		
	
	//if(DEBUG){
		//printf("EOF reached\n");
		//For testing, dump the hash table!
		//printf("HASH TABLE----------\n");
		//for (i = 0; i < HASH_TABLE_SIZE; i++) {
			//if (hash_table[i].hash != 0)
				//printf("0x%lx -> 0x%lx = %s ,Type: 0x%x, Import = %s -> 0x%lx\n", i, hash_table[i].hash, hash_table[i].token, 
					//hash_table[i].token_type, hash_table[i].token_import_name, hash_table[i].token_import_lib);
		//};
	//}
	if(r15){
		echo_string(STDOUT, 'EOF reached\nHASH TABLE----------\n');
		r1 = 0;
		r2 = HASH_TABLE_SIZE;
		while (r1 < r2){
			r0 = hash_table[r1].hash;
			if(r0){
				echo_hex(STDOUT, r1);
				echo_string(STDOUT, ' -> ');
				r0 = hash_table[r1].hash;
				echo_hex(STDOUT, r0);
				echo_string(STDOUT, ' = ');
				r0 = &hash_table[r1].token;
				echo_string(STDOUT, r0);
				echo_string(STDOUT, ' , Type: ');
				r0 = hash_table[r1].token_type;
				echo_hex(STDOUT, r0);
				echo_string(STDOUT, ', Import = ');
				r0 = &hash_table[r1].token_import_name;
				echo_string(STDOUT, r0);
				echo_string(STDOUT, ' -> ');
				r0 = hash_table[r1].token_import_lib;
				echo_hex(STDOUT, r0);
				echo_string(STDOUT, '\n');
			}
			r1 = r1 + 1;
		}
	}
	
	//rewind(code);
	r1 = code;
	_rewind(r1);
	//rewind(data);
	r1 = data;
	_rewind(r1);
	//rewind(bss);
	r1 = bss;
	_rewind(r1);

	//strcpy((char *)filename, ( char *)file[0].filename); // Let's get our original name
	r1 = &filename;
	r2 = &file[0].filename;
	strcpy(r1, r2);  //dest, src
	
	//pdest = (unsigned char *) strrchr((char *)filename, '.');
	r3 = strrchr(r1, CHAR_STOP);
	
	pdest = r3;
	//if (pdest != NULL) {
		//i = pdest - filename;
		//if (DEBUG) 
			//printf("%s = %ld\n", filename, i);
		//filename[i] = '\0';			// Truncate the string at the last '.'
	//}
	if(r3){
		if(r15){
			echo_string(STDOUT, r1);
			echo_string(STDOUT, ' = ');
			echo_integer(STDOUT, r3);
			echo_string(STDOUT, '\n');
		}
		r4 = 0;
		[r1+r3+2] = r4b;
	}
	if(r15){
		echo_string(STDOUT, 'Trunc Filename = "');
		r0 = &filename;
		echo_string(STDOUT, r0);
		echo_string(STDOUT, '"\n');
	}
	//strcat((char *)filename, ".asm");			// Append .asm to the end!
	strcat(r1, '.asm');
	if(r15){
		echo_string(STDOUT, 'ASM Filename = "');
		r0 = &filename;
		echo_string(STDOUT, r0);
		echo_string(STDOUT, '"\n');
	}

	//file[0].handle = fopen((char *)filename, "w");
	r14 = _fopen(r1, 'w');
	file[0].handle = r14;
	//if (!file[0].handle){
		//printf("ERROR: Unable to create file: %s\n", filename);
		//exit(1);
	//}
	r0 = 0;
	if(r14 == r0){
		echo_string(STDOUT, 'ERROR: Unable to create file: ');
		echo_string(STDOUT, r1);
		echo_string(STDOUT, '\n');
		exit(-1);
	}

	r1 = SOURCE_TYPE;
	//switch(SOURCE_TYPE){
		//case SOURCE_PE:
	r2 = SOURCE_PE;
	if(r1 == r2){
			//fprintf(file[0].handle, ";; B0 EXECUTABLE\n;; PE FORMAT\n\n");
			echo_string(r14, ';; B0 EXECUTABLE\n;; PE FORMAT\n\n');
			//include_standard_output();  // Include default equates and macros.
			include_standard_output();
			//#ifndef i386
			//fprintf(file[0].handle, "format PE64 GUI 4.0\nuse64\n\nentry start\n\n");
			//#else
			//fprintf(file[0].handle, "format PE GUI 4.0\nuse32\n\nentry start\n\n");
			//#endif
			#ifndef i386;
			echo_string(r14, 'format PE64 GUI 4.0\nuse64\n\nentry start\n\n');
			#else;
			echo_string(r14, 'format PE GUI 4.0\nuse32\n\nentry start\n\n');
			#endif;

			//Now we do our data! (Since the data section also has our defines).
			//fprintf(file[0].handle, "\nsection '.data' data readable writeable\n\n");
			echo_string(r14, '\nsection \'.data\' data readable writeable\n\n');

			//ch = fgetc(data);
			//while (ch != 0xffffffff){
				//fprintf(file[0].handle, "%c", ch);
				//ch = fgetc(data);
			//}
			r13 = data;
			r1 = _fgetc(r13);
			r3 = 0ffffffffh;		// Convert EOF to -1;
			if(r1 == r3){ r1 = EOF; }
			r2 = EOF;
			while(r1 != r2){
				echo_character(r14, r1);
				r1 = _fgetc(r13);
				if(r1 == r3){ r1 = EOF; }
			}
			
			//fprintf(file[0].handle, "\ndb \"EXB0 %s\",0\n\n", B0_VERSION);
			echo_string(r14, '\ndb \"EXB0 ');
			r0 = &B0_VERSION;
			echo_string(r14, r0);
			echo_string(r14, '\",0\n\n');
			
			//Now we do our bss!
			//ch = fgetc(bss);
			//while (ch != 0xffffffff){
				//fprintf(file[0].handle, "%c", ch);
				//ch = fgetc(bss);
			//}
			r13 = bss;
			r1 = _fgetc(r13);
			r3 = 0ffffffffh;		// Convert EOF to -1;
			if(r1 == r3){ r1 = EOF; }
			r2 = EOF;
			while(r1 != r2){
				echo_character(r14, r1);
				r1 = _fgetc(r13);
				if(r1 == r3){ r1 = EOF; }
			}

			//fprintf(file[0].handle, "align 16\nDATA_END:\n");
			echo_string(r14, 'align 16\nDATA_END:\n');	
			
			//FUCKING NASTY HACK FOR PE
			//#ifndef i386
			//if ((hash_table[0x3270d].hash != 0)&&(hash_table[0x3270d].token_type == TYPE_DEFINE+TYPE_M64)) {
			//#else
			//if ((hash_table[0x3270d].hash != 0)&&(hash_table[0x3270d].token_type == TYPE_DEFINE+TYPE_M32)) {
			//#endif
				//fprintf(file[0].handle, "\trb %lxh\n", hash_table[0x3270d].define_int);
			//} else {
				//fprintf(file[0].handle, "\trb 1000000h\n");
			//} // PS. Hash 0x3270d == LOCAL_HEAP!
			
			r0 = 0;
			r1 = hash_table[03270dh].hash;
			if(r1 != r0){
				r2 = hash_table[03270dh].token_type;
				#ifndef i386;
				r3 = TYPE_DEFINE+TYPE_M64;
				#else;
				r3 = TYPE_DEFINE+TYPE_M32;
				#endif;
				if(r2 == r3){
					echo_string(r14, '\trb ');
					r0 = hash_table[03270dh].define_int;
					echo_hex(r14, r0);
					echo_string(r14, '\n');
				} else {
					echo_string(r14, '\trb 1000000h\n');
				}
			}
					

			// Now we do our code...
			//fprintf(file[0].handle, "\nsection '.code' code readable executable\n\n");
			echo_string(r14, '\nsection \'.code\' code readable executable\n\n');
			
			//fprintf(file[0].handle, "\nstart:\n");
			//fprintf(file[0].handle, "\tfinit\n\tlea r6,[DATA_END]\n\tcall _B0_main\n");
			//fprintf(file[0].handle, "\nB0_sys_exit:\n");
			echo_string(r14, '\nstart:\n\tfinit\n\tlea r6,[DATA_END]\n\tcall _B0_main\n\nB0_sys_exit:\n');
			//#ifndef i386
			//fprintf(file[0].handle, "\tmov ecx,eax\n\tcall [ExitProcess]\n");
			//#else
			//fprintf(file[0].handle, "\tpush r0\n\tcall [ExitProcess]\n");
			//#endif
			#ifndef i386;
			echo_string(r14, '\tmov ecx,eax\n\tcall [ExitProcess]\n');
			#else;
			echO_string(r14, '\tpush r0\n\tcall [ExitProcess]\n');
			#endif;

			//ch = fgetc(code);
			//while (ch != 0xffffffff){
				//fprintf(file[0].handle, "%c", ch);
				//ch = fgetc(code);
			//}
			r13 = code;
			r1 = _fgetc(r13);
			r3 = 0ffffffffh;		// Convert EOF to -1;
			if(r1 == r3){ r1 = EOF; }
			r2 = EOF;
			while(r1 != r2){
				echo_character(r14, r1);
				r1 = _fgetc(r13);
				if(r1 == r3){ r1 = EOF; }
			}
			
			//Now lastly, we do our import section. (This is a Windows thing, basically we list all our externs). 
			//fprintf(file[0].handle, "\nsection '.idata' import data readable writeable\n\n");
			echo_string(r14, '\nsection \'.idata\' import data readable writeable\n\n');
			//include_public_extrns_pe(); // Include the rest of the public's and externs.
			include_public_extrns_pe();
			//fprintf(file[0].handle, "\n\n;EOF\n");
			echo_string(r14, '\n\n;EOF\n');
			//break;

	} else {
		r2 = SOURCE_ELF;
		if(r1 == r2){
		//case SOURCE_ELF: 
		
			//if ((hash_table[0x36768].hash == 0) || (hash_table[0x36768].token_type != TYPE_PROC)){
				//if(HeaderPrinted == 0)
					//PrintHeader();
				//printf("WARNING: Procedure main(); not found?\n");
			//}
			r1 = 0;
			r2 = hash_table[36768h].hash;
			r0 = 0;
			if(r1 == r2) { r0 = 1; }
			r1 = TYPE_EPROC;
			r2 = hash_table[36768h].token_type;
			if(r1 == r2) { r0 = 1; };
			if(r0){
				r0 = 0;
				r1 = WarningsDisabled;
				if (r1 == r0){
					r1 = HeaderPrinted;
					if(r1 == r0){
						PrintHeader();
					}
					echo_string(STDOUT, 'WARNING: Procedure main(); not found?\n');
				}
			}
			
			//fprintf(file[0].handle, ";; B0 EXECUTABLE\n;; ELF FORMAT for Linux\n\n");
			echo_string(r14, ';; B0 EXECUTABLE\n;; ELF FORMAT for Linux\n\n');
			//#ifndef i386
			//fprintf(file[0].handle, "format ELF64 executable\nuse64\nentry main\n\n");
			//#else
			//fprintf(file[0].handle, "format ELF executable\nuse32\nentry main\n\n");
			//#endif
			#ifndef i386;
			echo_string(r14, 'format ELF64 executable\nuse64\nentry main\n\n');
			#else;
			echo_string(r14, 'format ELF executable\nuse32\nentry main\n\n');
			#endif;
			//include_standard_output();  // Include default equates and macros.
			include_standard_output();
			//fprintf(file[0].handle, "macro syscall\n{\n");
			//fprintf(file[0].handle, "\tint 80h\n}\n\n");
			//fprintf(file[0].handle, "macro sysret\n{\n");
			//fprintf(file[0].handle, "\tiret\n}\n\n");
			echo_string(r14, 'macro syscall\n{\n\tint 80h\n}\n\nmacro sysret\n{\n\tiret\n}\n\n');

			//fprintf(file[0].handle, "\n\nsegment readable writeable\n\n");
			echo_string(r14, '\n\nsegment readable writeable\n\n');
			//ch = fgetc(data);
			//while (ch != 0xffffffff){
				//fprintf(file[0].handle, "%c", ch);
				//ch = fgetc(data);
			//}
			r13 = data;
			r1 = _fgetc(r13);
			r3 = 0ffffffffh;		// Convert EOF to -1;
			if(r1 == r3){ r1 = EOF; }
			r2 = EOF;
			while(r1 != r2){
				echo_character(r14, r1);
				r1 = _fgetc(r13);
				if(r1 == r3){ r1 = EOF; }
			}
			//fprintf(file[0].handle, "\ndb \"EXB0 %s\",0\n\n", B0_VERSION);
			//fprintf(file[0].handle, "\nsegment executable\n\nmain:\n\tfinit\n\tcall _B0_main\n");
			//fprintf(file[0].handle, "\nB0_sys_exit:\n");
			//fprintf(file[0].handle, "\tmov ebx,eax ;our exit code\n\tmov eax,1\n\tint 0x80\n");
			//fprintf(file[0].handle, "\n;We assume Linux output for ELF?\n");
			echo_string(r14, '\ndb "EXB0 ');
			r0 = &B0_VERSION;
			echo_string(r14, r0);
			echo_string(r14, '",0\n\n');
			echo_string(r14, '\nsegment executable\n\nmain:\n\tfinit\n\tcall _B0_main\n\nB0_sys_exit:\n');
			echo_string(r14, '\tmov ebx,eax ;our exit code\n\tmov eax,1\n\tint 0x80\n\n;We assume Linux output for ELF?\n');
			//ch = fgetc(code);
			//while (ch != 0xffffffff){
				//fprintf(file[0].handle, "%c", ch);
				//ch = fgetc(code);
			//}
			r13 = code;
			r1 = _fgetc(r13);
			r3 = 0ffffffffh;		// Convert EOF to -1;
			if(r1 == r3){ r1 = EOF; }
			r2 = EOF;
			while(r1 != r2){
				echo_character(r14, r1);
				r1 = _fgetc(r13);
				if(r1 == r3){ r1 = EOF; }
			}
			//fprintf(file[0].handle, "\nsegment writeable readable\n");	// BSS Segment
			echo_string(r14, '\nsegment writeable readable\n');
			//ch = fgetc(bss);
			//while (ch != 0xffffffff){
				//fprintf(file[0].handle, "%c", ch);
				//ch = fgetc(bss);
			//}
			r13 = bss;
			r1 = _fgetc(r13);
			r3 = 0ffffffffh;		// Convert EOF to -1;
			if(r1 == r3){ r1 = EOF; }
			r2 = EOF;
			while(r1 != r2){
				echo_character(r14, r1);
				r1 = _fgetc(r13);
				if(r1 == r3){ r1 = EOF; }
			}
			//fprintf(file[0].handle, "\nsegment writeable readable\n");	// Workaround for bug, umm updated feature in Linux Kernel 2.6.11 series.
			//fprintf(file[0].handle, "\n\n;EOF\n");
			echo_string(r14, '\nsegment writeable readable\n\n\n;EOF\n');
			//break;
			
		} else {
			r2 = SOURCE_ELFO;
			if(r1 == r2){
		//case SOURCE_ELFO: 
			//fprintf(file[0].handle, ";; B0 OBJECT\n;; ELF OBJECT FORMAT for Linux\n\n");
			echo_string(r14, ';; B0 OBJECT\n;; ELF OBJECT FORMAT for Linux\n\n');
			//#ifndef i386
			//fprintf(file[0].handle, "format ELF64\nuse64\n\n");
			//#else
			//fprintf(file[0].handle, "format ELF\nuse32\n\n");
			//#endif
			#ifndef i386;
			echo_string(r14, 'format ELF64\nuse64\n\n');
			#else;
			echo_string(r14, 'format ELF\nuse32\n\n');
			#endif;
			//include_standard_output();  // Include default equates and macros.
			include_standard_output();
			//fprintf(file[0].handle, "macro syscall\n{\n");
			//fprintf(file[0].handle, "\tint 80h\n}\n\n");
			//fprintf(file[0].handle, "macro sysret\n{\n");
			//fprintf(file[0].handle, "\tiret\n}\n\n");
			echo_string(r14, 'macro syscall\n{\n\tint 80h\n}\n\nmacro sysret\n{\n\tiret\n}\n\n');

			// Now include our publics and externs
			//include_public_extrns(); // Include the rest of the public's and externs.
			include_public_extrns();
			
			//fprintf(file[0].handle, "\n;Externs for exit from application\nextrn exit\n");
			echo_string(r14, '\n;Externs for exit from application\nextrn exit\n');
			
			//fprintf(file[0].handle, "\n\nsection '.data' writeable\n\n");
			echo_string(r14, '\n\nsection \'.data\' writeable\n\n');
			//ch = fgetc(data);
			//while (ch != 0xffffffff){
				//fprintf(file[0].handle, "%c", ch);
				//ch = fgetc(data);
			//}
			r13 = data;
			r1 = _fgetc(r13);
			r3 = 0ffffffffh;		// Convert EOF to -1;
			if(r1 == r3){ r1 = EOF; }
			r2 = EOF;
			while(r1 != r2){
				echo_character(r14, r1);
				r1 = _fgetc(r13);
				if(r1 == r3){ r1 = EOF; }
			}
			//fprintf(file[0].handle, "\ndb \"EXB0 %s\",0\n\n", B0_VERSION);
			echo_string(r14, '\ndb "EXB0 ');
			r0 = &B0_VERSION;
			echo_string(r14, r0);
			echo_string(r14, '",0\n\n');
			//fprintf(file[0].handle, "\nsection '.bss' writeable\n\n");
			echo_string(r14, '\nsection \'.bss\' writeable\n\n');
			//ch = fgetc(bss);
			//while (ch != 0xffffffff){
				//fprintf(file[0].handle, "%c", ch);
				//ch = fgetc(bss);
			//}
			r13 = bss;
			r1 = _fgetc(r13);
			r3 = 0ffffffffh;		// Convert EOF to -1;
			if(r1 == r3){ r1 = EOF; }
			r2 = EOF;
			while(r1 != r2){
				echo_character(r14, r1);
				r1 = _fgetc(r13);
				if(r1 == r3){ r1 = EOF; }
			}
			//fprintf(file[0].handle, "\nsection '.text' executable\n\n");
			echo_string(r14, '\nsection \'.text\' executable\n\n');
			//ch = fgetc(code);
			//while (ch != 0xffffffff){
				//fprintf(file[0].handle, "%c", ch);
				//ch = fgetc(code);
			//}
			r13 = code;
			r1 = _fgetc(r13);
			r3 = 0ffffffffh;		// Convert EOF to -1;
			if(r1 == r3){ r1 = EOF; }
			r2 = EOF;
			while(r1 != r2){
				echo_character(r14, r1);
				r1 = _fgetc(r13);
				if(r1 == r3){ r1 = EOF; }
			}
			//fprintf(file[0].handle, "\nB0_sys_exit:\n");
			//fprintf(file[0].handle, "\tpush r0\n\tcall exit\n");
			//fprintf(file[0].handle, "\n\n;EOF\n");
			echo_string(r14, '\nB0_sys_exit:\n\tmov r4, r0\n\tmov r0, 0\n\tcall exit\n\n\n;EOF\n');
			//break;
	//}
	}}}
	
	//time_end = clock();
	r0 = _clock();
	time_end = r0;
	//duration = (double)(time_end - time_start) / CLOCKS_PER_SEC;
	
	r1 = time_end;
	r2 = time_start;
	r4 = r1 - r2;
	
	//if(DEBUG || Version)
		//printf( "Processing Time: %5.3f seconds\n", duration );
	r1 = DEBUG;
	r2 = Version;
	r1 = r1 + r2;
	if(r1){
		echo_string(STDOUT, 'Processing Time: ');
		echo_hex(STDOUT, r4);
		echo_string(STDOUT, ' clocks\n');
	}
		
	//fclose(code);
	r0 = code;
	_fclose(r0);
	//fclose(data);
	r0 = data;
	_fclose(r0);
	//fclose(bss);
	r0 = bss;
	_fclose(r0);
	//remove("c_output.tmp");
	_remove('c_output.tmp');
	//remove("d_output.tmp");
	_remove('d_output.tmp');
	//remove("b_output.tmp");
	_remove('b_output.tmp');
	//fclose(file[0].handle);
	_fclose(r14);
	pop r15, r14, r13, r12, r11, r10, r9, r8, r5, r4, r3, r2, r1;
	exit(0);
}


